/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/index.js */ \"./src/index.js\");\n\nconsole.log(\"hi\");\n\n//# sourceURL=webpack://js.package/./index.js?");

/***/ }),

/***/ "./src/dom-utils/ElementBuilder/elementBuilder.js":
/*!********************************************************!*\
  !*** ./src/dom-utils/ElementBuilder/elementBuilder.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ElementBuilder: () => (/* binding */ ElementBuilder)\n/* harmony export */ });\n/* harmony import */ var _validation_validation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../validation/validation */ \"./src/validation/validation.js\");\n\n\n/**\r\n * A class that extends ElementHandler and provides functionality for creating new HTML elements.\r\n * It includes methods for creating, manipulating, and managing the lifecycle of HTML elements.\r\n */\nclass ElementBuilder {\n  /**\r\n   * Creates a new HTML element with the specified tag name and sets its inner HTML.\r\n   *\r\n   * @param {string} tagName - The tag name of the element to be created.\r\n   * @param {string} innerHTML - The inner HTML content to be set for the created element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, logs an error and returns.\r\n   * \r\n   * @return {void} - This function does not return anything.\r\n   * \r\n   * @throw {Error} - Throws an error if the provided tag name is not a string.\r\n   * \r\n   * @example\r\n   *  Example usage:\r\n   *  ElementBuilder.createHTML('div', 'hello dany');\r\n   * \r\n   * @output {void} - This function does not return anything.\r\n   * \r\n   * @description\r\n   * This function creates a new HTML element with the specified tag name and sets its inner HTML content.\r\n   * If the 'tagName' parameter is not a string, it logs an error (if throwOnError is false) or throws an error.\r\n   */\n  static createHTML(tagName, innerHTML, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    })) {\n      _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"tagName\" must be a string.');\n      return;\n    }\n    const element = document.createElement(tagName);\n    element.innerHTML = innerHTML;\n    return element;\n  }\n\n  /**\r\n   * Creates an HTML element with specified tag name, attributes, and innerHTML content.\r\n   *\r\n   * @param {string} tagName - The tag name of the element to be created.\r\n   * @param {Object|null} attributes - Additional attributes to set for the element.\r\n   * @param {string|null} [innerHTML=null] - The innerHTML content for the element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The created HTML element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'tagName' parameter is not a string,\r\n   * or if 'innerHTML' is not a string or null.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const divElement = ElementBuilder.createElementWithAttributes('div', { id: 'example', class: 'sample' }, 'Hello World!');\r\n   *\r\n   * @output {HTMLElement|null} - The created HTML element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an HTML element with the specified tag name, attributes, and innerHTML content.\r\n   * Returns the created HTML element if successful, or null if an error occurs.\r\n   * Throws an error if the 'tagName' parameter is not a string,\r\n   * or if 'innerHTML' is not a string or null.\r\n   */\n  static createElementWithAttributes(tagName, attributes, innerHTML = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObjectOrNull({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isStringOrNull({\n      param: innerHTML,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const element = document.createElement(tagName);\n    if (attributes !== null) {\n      Object.entries(attributes).forEach(([key, value]) => {\n        element.setAttribute(key, value);\n      });\n    }\n    if (innerHTML !== null) {\n      element.innerHTML = innerHTML;\n    }\n    return element;\n  }\n\n  /**\r\n  * Appends a child element to a parent element.\r\n  *\r\n  * @param {HTMLElement} parent - The parent element.\r\n  * @param {HTMLElement} child - The child element to be appended.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n  *\r\n  * @return {boolean} - Returns true if the operation is successful; otherwise, false.\r\n  *\r\n  * @throws {Error} - Throws an error if the 'parent' or 'child' parameters are not objects or if 'parent' is not provided (when throwOnError is true).\r\n  *\r\n  * @example\r\n  *  Example usage:\r\n  *  const parentElement = ElementHandler.retrieveElementById('parent');\r\n  *  const childElement = ElementBuilder.createHTML('div', 'hello dany');\r\n  *  ElementBuilder.appendElement(parentElement, childElement);\r\n  *\r\n  * @output {boolean} - Returns true if the operation is successful; otherwise, false.\r\n  *\r\n  * @description\r\n  * This method appends a child element to a parent element. It returns true if the operation is successful; otherwise, false.\r\n  * Throws an error if the 'parent' or 'child' parameters are not objects or if 'parent' is not provided (when throwOnError is true).\r\n  */\n  static appendElement(parent, child, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: parent,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: child,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters: 'parent' and 'child' must be objects.\");\n    }\n    parent.appendChild(child);\n    return true;\n  }\n\n  /**\r\n   * Prepends a child element to a parent element.\r\n   *\r\n   * @param {HTMLElement} parent - The parent element.\r\n   * @param {HTMLElement} child - The child element to be prepended.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - Returns true if the operation is successful; otherwise, false.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'parent' or 'child' parameters are not objects or if 'parent' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const parentElement =ElementHandler.retrieveElementById('parent');\r\n   *  const childElement = document.createElement('div');\r\n   *  ElementBuilder.prependElement(parentElement, childElement);\r\n   *\r\n   * @output {boolean} - Returns true if the operation is successful; otherwise, false.\r\n   *\r\n   * @description\r\n   * This method prepends a child element to a parent element. It returns true if the operation is successful; otherwise, false.\r\n   * Throws an error if the 'parent' or 'child' parameters are not objects or if 'parent' is not provided (when throwOnError is true).\r\n   */\n  static prependElement(parent, child, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: parent,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: child,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters: 'parent' and 'child' must be objects.\");\n    }\n    parent.insertBefore(child, parent.firstChild);\n    return true;\n  }\n\n  /**\r\n  * Creates a new HTML element with the specified tag name, sets its innerHTML, and appends it to a parent element.\r\n  *\r\n  * @param {string} tagName - The tag name of the element to be created.\r\n  * @param {string} innerHTML - The innerHTML content to be set for the new element.\r\n  * @param {HTMLElement} parent - The parent element to which the new element will be appended.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n  *\r\n  * @return {boolean} - Returns true if the operation is successful; otherwise, false.\r\n  *\r\n  * @throws {Error} - Throws an error if the 'tagName', 'innerHTML', 'parent' parameters are not of the expected type, or if 'parent' is not provided (when throwOnError is true).\r\n  *\r\n  * @example\r\n  *  Example usage:\r\n  *  const parentElement = ElementHandler.retrieveElementById('parent');\r\n  *  ElementBuilder.createAndAppend('div', 'Hello World', parentElement);\r\n  *\r\n  * @output {boolean} - Returns true if the operation is successful; otherwise, false.\r\n  *\r\n  * @description\r\n  * This method creates a new HTML element with the specified tag name, sets its innerHTML, and appends it to a parent element.\r\n  * Returns true if the operation is successful; otherwise, false.\r\n  * Throws an error if the 'tagName', 'innerHTML', 'parent' parameters are not of the expected type, or if 'parent' is not provided (when throwOnError is true).\r\n  */\n  static createAndAppend(tagName, innerHTML, parent, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: innerHTML,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: parent,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const element = document.createElement(tagName);\n    element.innerHTML = innerHTML;\n    return ElementBuilder.appendElement(parent, element, throwOnError);\n  }\n\n  /**\r\n   * Creates a new HTML element with the specified tag name, sets its innerHTML, and prepends it to a parent element.\r\n   *\r\n   * @param {string} tagName - The tag name of the element to be created.\r\n   * @param {string} innerHTML - The innerHTML content to be set for the new element.\r\n   * @param {HTMLElement} parent - The parent element to which the new element will be prepended.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - Returns true if the operation is successful; otherwise, false.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'tagName', 'innerHTML', 'parent' parameters are not of the expected type, or if 'parent' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const parentElement = ElementHandler.retrieveElementById('parent');\r\n   *  ElementBuilder.createAndPrepend('div', 'Hello World', parentElement);\r\n   *\r\n   * @output {boolean} - Returns true if the operation is successful; otherwise, false.\r\n   *\r\n   * @description\r\n   * This method creates a new HTML element with the specified tag name, sets its innerHTML, and prepends it to a parent element.\r\n   * Returns true if the operation is successful; otherwise, false.\r\n   * Throws an error if the 'tagName', 'innerHTML', 'parent' parameters are not of the expected type, or if 'parent' is not provided (when throwOnError is true).\r\n   */\n  static createAndPrepend(tagName, innerHTML, parent, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: innerHTML,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: parent,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const element = document.createElement(tagName);\n    element.innerHTML = innerHTML;\n    return ElementBuilder.prependElement(parent, element, throwOnError);\n  }\n\n  /**\r\n   * Creates a deep copy (clone) of an HTML element, including all its children.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element to be cloned.\r\n   * @param {boolean} [deep=true] - If true, the clone will include all children and descendants; otherwise, only the element itself will be cloned.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement | null} - The cloned HTML element or null if the operation is unsuccessful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'element' parameter is not of the expected type (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const originalElement = ElementHandler.retrieveElementById('original');\r\n   *  const clonedElement = ElementBuilder.cloneElement(originalElement);\r\n   *\r\n   * @output {HTMLElement | null} - The cloned HTML element or null if the operation is unsuccessful.\r\n   *\r\n   * @description\r\n   * This method creates a deep copy (clone) of an HTML element, including all its children.\r\n   * If deep is true, the clone will include all children and descendants; otherwise, only the element itself will be cloned.\r\n   * Returns the cloned HTML element or null if the operation is unsuccessful.\r\n   * Throws an error if the 'element' parameter is not of the expected type (when throwOnError is true).\r\n   */\n  static cloneElement(element, deep = true, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    return element.cloneNode(deep);\n  }\n\n  /**\r\n   * Wraps an HTML element with a new parent element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element to be wrapped.\r\n   * @param {string} wrapperTagName - The tag name of the new parent element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement | null} - The newly created parent element wrapping the provided HTML element, or null if the operation is unsuccessful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'element' parameter is not of the expected type, or if the 'wrapperTagName' parameter is not a string (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const originalElement = ElementHandler.retrieveElementById('original');\r\n   *  const wrappedElement = ElementBuilder.wrapElement(originalElement, 'div');\r\n   *\r\n   * @output {HTMLElement | null} - The newly created parent element wrapping the provided HTML element, or null if the operation is unsuccessful.\r\n   *\r\n   * @description\r\n   * This method wraps an HTML element with a new parent element created using the specified tag name.\r\n   * Returns the newly created parent element wrapping the provided HTML element, or null if the operation is unsuccessful.\r\n   * Throws an error if the 'element' parameter is not of the expected type, or if the 'wrapperTagName' parameter is not a string (when throwOnError is true).\r\n   */\n  static wrapElement(element, wrapperTagName, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: wrapperTagName,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const wrapperElement = document.createElement(wrapperTagName);\n    element.parentNode.replaceChild(wrapperElement, element);\n    wrapperElement.appendChild(element);\n    return wrapperElement;\n  }\n\n  /**\r\n   * Unwraps an HTML element by removing its parent and keeping the child in its place.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element to be unwrapped.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - True if the element is successfully unwrapped, false otherwise.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'element' parameter is not of the expected type (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const childElement = ElementHandler.retrieveElementById('child');\r\n   *  const success = ElementBuilder.unwrapElement(childElement);\r\n   *\r\n   * @output {boolean} - True if the element is successfully unwrapped, false otherwise.\r\n   *\r\n   * @description\r\n   * This method unwraps an HTML element by removing its parent and keeping the child in its place.\r\n   * Returns true if the element is successfully unwrapped, false otherwise.\r\n   * Throws an error if the 'element' parameter is not of the expected type (when throwOnError is true).\r\n   */\n  static unwrapElement(fromElement, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: fromElement,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const parentElement = fromElement.parentElement;\n    if (parentElement) {\n      while (fromElement.firstChild) {\n        parentElement.insertBefore(fromElement.firstChild, fromElement);\n      }\n      parentElement.removeChild(fromElement);\n      return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * Creates an HTML image element with the specified source (src) and optional attributes.\r\n   *\r\n   * @param {string} src - The source URL of the image.\r\n   * @param {Object} [attributes={}] - Optional attributes to be added to the image element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLImageElement|null} - The newly created HTML image element with the specified source and attributes, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'src' parameter is not a string or if the 'attributes' parameter is not an object (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const imageElement = ElementBuilder.createImageElement('path/to/image.jpg', { alt: 'An example image', width: 300, height: 200 });\r\n   *\r\n   * @output {HTMLImageElement|null} - The newly created HTML image element or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an HTML image element with the specified source (src) and optional attributes.\r\n   * Returns the newly created image element or null if an error occurs.\r\n   * Throws an error if the 'src' parameter is not a string or if the 'attributes' parameter is not an object (when throwOnError is true).\r\n   */\n  static createImageElement(src, attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: src,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const imageElement = document.createElement('img');\n    imageElement.src = src;\n    Object.entries(attributes).forEach(([key, value]) => {\n      imageElement.setAttribute(key, value);\n    });\n    return imageElement;\n  }\n\n  /**\r\n   * Inserts the specified element before the reference element.\r\n   *\r\n   * @param {HTMLElement} elementToInsert - The element to be inserted.\r\n   * @param {HTMLElement} referenceElement - The reference element before which the new element will be inserted.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - True if the insertion is successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'elementToInsert' or 'referenceElement' parameters are not objects (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const newElement = ElementBuilder.createElement('div');\r\n   *  const referenceElement = ElementHandler.retrieveElementById('referenceElement');\r\n   *  ElementBuilder.insertBefore(newElement, referenceElement);\r\n   *\r\n   * @output {boolean|null} - True if the insertion is successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method inserts the specified element before the reference element.\r\n   * Returns true if the insertion is successful, or null if an error occurs.\r\n   * Throws an error if the 'elementToInsert' or 'referenceElement' parameters are not objects (when throwOnError is true).\r\n   */\n  static insertBefore(elementToInsert, referenceElement, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: elementToInsert,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: referenceElement,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const parent = referenceElement.parentElement;\n    if (!parent) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Reference element has no parent.');\n    }\n    parent.insertBefore(elementToInsert, referenceElement);\n    return true;\n  }\n\n  /**\r\n   * Inserts the specified element after the reference element.\r\n   *\r\n   * @param {HTMLElement} elementToInsert - The element to be inserted.\r\n   * @param {HTMLElement} referenceElement - The reference element after which the new element will be inserted.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - True if the insertion is successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'elementToInsert' or 'referenceElement' parameters are not objects (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const newElement = ElementBuilder.createElement('div');\r\n   *  const referenceElement = ElementHandler.retrieveElementById('referenceElement');\r\n   *  ElementBuilder.insertAfter(newElement, referenceElement);\r\n   *\r\n   * @output {boolean|null} - True if the insertion is successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method inserts the specified element after the reference element.\r\n   * Returns true if the insertion is successful, or null if an error occurs.\r\n   * Throws an error if the 'elementToInsert' or 'referenceElement' parameters are not objects (when throwOnError is true).\r\n   */\n  static insertAfter(elementToInsert, referenceElement, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: elementToInsert,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: referenceElement,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const parent = referenceElement.parentElement;\n    if (!parent) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Reference element has no parent.');\n    }\n    const nextSibling = referenceElement.nextElementSibling;\n    if (nextSibling) {\n      parent.insertBefore(elementToInsert, nextSibling);\n    } else {\n      parent.appendChild(elementToInsert);\n    }\n    return true;\n  }\n\n  /**\r\n   * Replaces an existing element with a new element.\r\n   *\r\n   * @param {HTMLElement} newElement - The new element to replace the existing element.\r\n   * @param {HTMLElement} oldElement - The existing element to be replaced.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - True if the replacement is successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'newElement' or 'oldElement' parameters are not objects (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const newElement = ElementBuilder.createHTML('div');\r\n   *  const oldElement = ElementHandler.retrieveElementById('oldElement');\r\n   *  ElementBuilder.replaceElement(newElement, oldElement);\r\n   *\r\n   * @output {boolean|null} - True if the replacement is successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method replaces an existing element with a new element.\r\n   * Returns true if the replacement is successful, or null if an error occurs.\r\n   * Throws an error if the 'newElement' or 'oldElement' parameters are not objects (when throwOnError is true).\r\n   */\n  static replaceElement(newElement, oldElement, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: newElement,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: oldElement,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const parent = oldElement.parentElement;\n    if (!parent) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Old element has no parent.');\n    }\n    parent.replaceChild(newElement, oldElement);\n    return true;\n  }\n\n  /**\r\n   * Removes all child nodes from an element.\r\n   *\r\n   * @param {HTMLElement} element - The element from which to remove all child nodes.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - True if the removal of child nodes is successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const parentElement = ElementHandler.retrieveElementById('parentElement');\r\n   *  ElementBuilder.emptyElement(parentElement);\r\n   *\r\n   * @output {boolean|null} - True if the removal of child nodes is successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method removes all child nodes from the specified element.\r\n   * Returns true if the removal is successful, or null if an error occurs.\r\n   * Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   */\n  static emptyElement(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n    return true;\n  }\n\n  /**\r\n   * Removes an element from the DOM.\r\n   *\r\n   * @param {HTMLElement} element - The element to be removed from the DOM.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - True if the removal of the element is successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const elementToRemove = ElementHandler.retrieveElementById('elementToRemove');\r\n   *  ElementBuilder.removeElement(elementToRemove);\r\n   *\r\n   * @output {boolean|null} - True if the removal of the element is successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method removes the specified element from the DOM.\r\n   * Returns true if the removal is successful, or null if an error occurs.\r\n   * Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   */\n  static removeElement(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const parent = element.parentElement;\n    if (!parent) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Element has no parent.');\n    }\n    parent.removeChild(element);\n    return true;\n  }\n\n  /**\r\n   * Creates a text node and appends it to an element.\r\n   *\r\n   * @param {HTMLElement} parentElement - The element to which the text node will be appended.\r\n   * @param {string} text - The text content of the text node.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {Text|null} - The created text node if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'parentElement' parameter is not an object or 'text' parameter is not a string (when throwOnError is true).\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const parentElement = ElementHandler.retrieveElementById('parentElement');\r\n   *  ElementBuilder.createTextElement(parentElement, 'Hello, World!');\r\n   *\r\n   * @output {Text|null} - The created text node if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a text node with the specified text content and appends it to the provided element.\r\n   * Returns the created text node if successful, or null if an error occurs.\r\n   * Throws an error if the 'parentElement' parameter is not an object or 'text' parameter is not a string (when throwOnError is true).\r\n   */\n  static createTextElement(parentElement, text, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: parentElement,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: text,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const textNode = document.createTextNode(text);\n    parentElement.appendChild(textNode);\n    return textNode;\n  }\n\n  /**\r\n   * Creates a link element with specified attributes.\r\n   *\r\n   * @param {string} href - The href attribute for the link element.\r\n   * @param {string} innerHTML - The innerHTML text content for the link element.\r\n   * @param {boolean} newTab - If true, opens the link in a new tab; otherwise, opens it in the same tab.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLLinkElement|null} - The created link element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'href' or 'innerHTML' parameters are not strings.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const linkElement = DOMCreation.createLinkElement('https://example.com', 'Visit Example', true);\r\n   *\r\n   * @output {HTMLLinkElement|null} - The created link element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a link element with the specified href, innerHTML, and newTab attributes.\r\n   * Returns the created link element if successful, or null if an error occurs.\r\n   * Throws an error if the 'href' or 'innerHTML' parameters are not strings.\r\n   */\n  static createLinkElement(href, innerHTML, newTab = true, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: href,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: innerHTML,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const linkElement = document.createElement('a');\n    linkElement.href = href;\n    linkElement.innerHTML = innerHTML;\n    if (newTab) {\n      linkElement.target = '_blank';\n      linkElement.rel = 'noopener noreferrer';\n    }\n    return linkElement;\n  }\n\n  /**\r\n   * Creates a map element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the map element.\r\n   * @param {string|null} [innerHTML=null] - The innerHTML content for the map element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLMapElement|null} - The created map element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const mapElement = ElementBuilder.createMapElement({ name: 'example-map' });\r\n   *\r\n   * @output {HTMLMapElement|null} - The created map element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a map element with the specified attributes.\r\n   * Returns the created map element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   */\n  static createMapElement(attributes = {}, innerHTML = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isStringOrNull({\n      param: innerHTML,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const mapElement = this.createElementWithAttributes('map', attributes, innerHTML, throwOnError);\n    return mapElement;\n  }\n\n  /**\r\n   * Creates an <area> element with specified attributes for use in an image map.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <area> element.\r\n   * @param {string|null} [innerHTML=null] - The innerHTML content for the <area> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLAreaElement|null} - The created <area> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const areaElement = ElementBuilder.createAreaElement({ shape: 'rect', coords: '0,0,50,50', href: 'link1.html' });\r\n   *\r\n   * @output {HTMLAreaElement|null} - The created <area> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an <area> element with the specified attributes for use in an image map.\r\n   * Returns the created <area> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   */\n  static createAreaElement(attributes = {}, innerHTML = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isStringOrNull({\n      param: innerHTML,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const areaElement = this.createElementWithAttributes('area', attributes, innerHTML, throwOnError);\n    return areaElement;\n  }\n\n  /**\r\n   * Creates a <select> element with specified attributes and options.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <select> element.\r\n   * @param {Array<Object>} options - An array of option objects, each containing 'value' and 'text' properties.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLSelectElement|null} - The created <select> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'options' parameter is not an array, or if any option is missing 'value' or 'text' properties.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const selectElement = ElementBuilder.createSelectElement(\r\n   *    { id: 'example-select', name: 'example', class: 'custom-select' },\r\n   *    [\r\n   *      { value: 'option1', text: 'Option 1' },\r\n   *      { value: 'option2', text: 'Option 2' },\r\n   *      { value: 'option3', text: 'Option 3' }\r\n   *    ]\r\n   *  );\r\n   *\r\n   * @output {HTMLSelectElement|null} - The created <select> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <select> element with the specified attributes and options.\r\n   * Returns the created <select> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'options' parameter is not an array, or if any option is missing 'value' or 'text' properties.\r\n   */\n  static createSelectElement(attributes = {}, options = [], throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArray({\n      param: options,\n      throwOnError\n    }) || options.some(option => !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: option,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: option.value,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: option.text,\n      throwOnError\n    }))) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const selectElement = this.createElementWithAttributes('select', attributes, null, throwOnError);\n    options.forEach(option => {\n      const optionElement = document.createElement('option');\n      optionElement.value = option.value;\n      optionElement.text = option.text;\n      selectElement.appendChild(optionElement);\n    });\n    return selectElement;\n  }\n\n  /**\r\n   * Creates an <option> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <option> element.\r\n   * @param {string} text - The text content for the <option> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLOptionElement|null} - The created <option> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if the 'text' parameter is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const optionElement = ElementBuilder.createOptionElement(\r\n   *    { value: 'option1', disabled: true },\r\n   *    'Option 1'\r\n   *  );\r\n   *\r\n   * @output {HTMLOptionElement|null} - The created <option> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an <option> element with the specified attributes.\r\n   * Returns the created <option> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if the 'text' parameter is not a string.\r\n   */\n  static createOptionElement(attributes = {}, text, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: text,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const optionElement = this.createElementWithAttributes('option', attributes, text, throwOnError);\n    return optionElement;\n  }\n\n  /**\r\n   * Creates an <optgroup> element with specified attributes and child options.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <optgroup> element.\r\n   * @param {Array<Object>} options - An array of option objects to be included as children of the <optgroup> element.\r\n   * Each option object should have 'attributes' and 'text' properties.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLOptGroupElement|null} - The created <optgroup> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'options' parameter is not an array of objects with 'attributes' and 'text' properties,\r\n   * or if any option's 'attributes' or 'text' is invalid.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const optgroupElement = ElementBuilder.createOptgroupElement(\r\n   *    { label: 'Group 1', disabled: true },\r\n   *    [\r\n   *      { attributes: { value: 'option1', disabled: true }, text: 'Option 1' },\r\n   *      { attributes: { value: 'option2' }, text: 'Option 2' }\r\n   *    ]\r\n   *  );\r\n   *\r\n   * @output {HTMLOptGroupElement|null} - The created <optgroup> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an <optgroup> element with the specified attributes and child options.\r\n   * Returns the created <optgroup> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'options' parameter is not an array of objects with 'attributes' and 'text' properties,\r\n   * or if any option's 'attributes' or 'text' is invalid.\r\n   */\n  static createOptgroupElement(attributes = {}, options = [], throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const optgroupElement = this.createElementWithAttributes('optgroup', attributes, null, throwOnError);\n    options.forEach(option => {\n      const {\n        attributes: optionAttributes,\n        text: optionText\n      } = option;\n      const optionElement = this.createOptionElement(optionAttributes, optionText, throwOnError);\n      if (optionElement) {\n        optgroupElement.appendChild(optionElement);\n      }\n    });\n    return optgroupElement;\n  }\n\n  /**\r\n   * Creates a <textarea> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <textarea> element.\r\n   * @param {string|null} [value=null] - The initial value for the <textarea> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLTextAreaElement|null} - The created <textarea> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const textareaElement = ElementBuilder.createTextareaElement({ rows: 4, cols: 50 }, 'Initial value');\r\n   *\r\n   * @output {HTMLTextAreaElement|null} - The created <textarea> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <textarea> element with the specified attributes.\r\n   * Returns the created <textarea> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createTextareaElement(attributes = {}, value = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const textareaElement = this.createElementWithAttributes('textarea', attributes, null, throwOnError);\n    if (value !== null) {\n      textareaElement.value = value;\n    }\n    return textareaElement;\n  }\n\n  /**\r\n   * Creates a <label> element with specified attributes and associated input element.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <label> element.\r\n   * @param {string|null} [forId=null] - The ID of the associated input element.\r\n   * @param {string|null} [textContent=null] - The text content for the <label> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLLabelElement|null} - The created <label> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const labelElement = ElementBuilder.createLabelElement({ class: 'form-label' }, 'inputId', 'Enter your name:');\r\n   *\r\n   * @output {HTMLLabelElement|null} - The created <label> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <label> element with the specified attributes and associates it with an input element.\r\n   * Returns the created <label> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createLabelElement(attributes = {}, forId = null, textContent = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const labelElement = this.createElementWithAttributes('label', attributes, textContent, throwOnError);\n    if (forId !== null) {\n      labelElement.setAttribute('for', forId);\n    }\n    return labelElement;\n  }\n\n  /**\r\n   * Creates a <fieldset> element with specified attributes and associated legend element.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <fieldset> element.\r\n   * @param {string|null} [legendText=null] - The text content for the associated <legend> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLFieldSetElement|null} - The created <fieldset> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const fieldsetElement = ElementBuilder.createFieldsetElement({ class: 'form-fieldset' }, 'User Details');\r\n   *\r\n   * @output {HTMLFieldSetElement|null} - The created <fieldset> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <fieldset> element with the specified attributes and associates it with a <legend> element.\r\n   * Returns the created <fieldset> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createFieldsetElement(attributes = {}, legendText = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const fieldsetElement = this.createElementWithAttributes('fieldset', attributes, null, throwOnError);\n    if (legendText !== null) {\n      const legendElement = this.createElementWithAttributes('legend', {}, legendText, throwOnError);\n      fieldsetElement.appendChild(legendElement);\n    }\n    return fieldsetElement;\n  }\n\n  /**\r\n   * Creates a legend element with specified text content.\r\n   *\r\n   * @param {string} legendText - The text content for the legend element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLLegendElement|null} - The created legend element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'legendText' parameter is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const legendElement = ElementBuilder.createLegendElement('Form Legend');\r\n   *\r\n   * @output {HTMLLegendElement|null} - The created legend element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a legend element with the specified text content.\r\n   * Returns the created legend element if successful, or null if an error occurs.\r\n   * Throws an error if the 'legendText' parameter is not a string.\r\n   */\n  static createLegendElement(legendText, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: legendText,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    return this.createElementWithAttributes('legend', {}, legendText, throwOnError);\n  }\n\n  /**\r\n   * Creates a table element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the table element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLTableElement|null} - The created table element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const tableElement = ElementBuilder.createTableElement({ border: '1', cellspacing: '0', cellpadding: '5' });\r\n   *\r\n   * @output {HTMLTableElement|null} - The created table element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a table element with the specified attributes.\r\n   * Returns the created table element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createTableElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    return this.createElementWithAttributes('table', attributes, null, throwOnError);\n  }\n\n  /**\r\n   * Creates a table row element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the table row element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLTableRowElement|null} - The created table row element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const rowElement = ElementBuilder.createTableRowElement({ class: 'table-row', 'data-id': '1' });\r\n   *\r\n   * @output {HTMLTableRowElement|null} - The created table row element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a table row element with the specified attributes.\r\n   * Returns the created table row element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createTableRowElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    return this.createElementWithAttributes('tr', attributes, null, throwOnError);\n  }\n\n  /**\r\n   * Creates a table head (thead) element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the table head element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLTableSectionElement|null} - The created table head (thead) element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const theadElement = ElementBuilder.createTableHeadElement({ class: 'table-header' });\r\n   *\r\n   * @output {HTMLTableSectionElement|null} - The created table head (thead) element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a table head (thead) element with the specified attributes.\r\n   * Returns the created table head (thead) element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createTableHeadElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    return this.createElementWithAttributes('thead', attributes, null, throwOnError);\n  }\n\n  /**\r\n   * Creates a table foot (tfoot) element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the table foot element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLTableSectionElement|null} - The created table foot (tfoot) element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const tfootElement = ElementBuilder.createTableFootElement({ class: 'table-footer' });\r\n   *\r\n   * @output {HTMLTableSectionElement|null} - The created table foot (tfoot) element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a table foot (tfoot) element with the specified attributes.\r\n   * Returns the created table foot (tfoot) element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createTableFootElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    return this.createElementWithAttributes('tfoot', attributes, null, throwOnError);\n  }\n\n  /**\r\n   * Creates a form element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the form element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLFormElement|null} - The created form element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const formElement = ElementBuilder.createFormElement({ action: '/submit', method: 'post' });\r\n   *\r\n   * @output {HTMLFormElement|null} - The created form element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a form element with the specified attributes.\r\n   * Returns the created form element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createFormElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const formElement = this.createElementWithAttributes('form', attributes, null, throwOnError);\n    return formElement;\n  }\n\n  /**\r\n   * Creates an input element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the input element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLInputElement|null} - The created input element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const inputElement = ElementBuilder.createInputElement({ type: 'text', name: 'username', placeholder: 'Enter your username' });\r\n   *\r\n   * @output {HTMLInputElement|null} - The created input element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an input element with the specified attributes.\r\n   * Returns the created input element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createInputElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const inputElement = this.createElementWithAttributes('input', attributes, null, throwOnError);\n    return inputElement;\n  }\n\n  /**\r\n   * Creates a button element with specified attributes and innerHTML content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the button element.\r\n   * @param {string|null} innerHTML - The innerHTML content for the button element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLButtonElement|null} - The created button element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const buttonElement = ElementBuilder.createButtonElement({ type: 'button', onclick: 'handleClick()' }, 'Click me');\r\n   *\r\n   * @output {HTMLButtonElement|null} - The created button element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a button element with the specified attributes and innerHTML content.\r\n   * Returns the created button element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   */\n  static createButtonElement(attributes = {}, innerHTML = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isStringOrNull({\n      param: innerHTML,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const buttonElement = this.createElementWithAttributes('button', attributes, innerHTML, throwOnError);\n    return buttonElement;\n  }\n\n  /**\r\n   * Creates a checkbox input element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the checkbox input element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLInputElement|null} - The created checkbox input element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const checkboxElement = ElementBuilder.createCheckboxElement({ id: 'check', name: 'checkbox' });\r\n   *\r\n   * @output {HTMLInputElement|null} - The created checkbox input element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a checkbox input element (`<input type=\"checkbox\">`) with the specified attributes.\r\n   * Returns the created checkbox input element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createCheckboxElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    attributes.type = 'checkbox'; // Ensure type is set to 'checkbox'\n    const checkboxElement = this.createElementWithAttributes('input', attributes, null, throwOnError);\n    return checkboxElement;\n  }\n\n  /**\r\n   * Creates a radio input element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the radio input element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLInputElement|null} - The created radio input element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const radioElement = ElementBuilder.createInputRadioElement({ id: 'radio', name: 'radio-group' });\r\n   *\r\n   * @output {HTMLInputElement|null} - The created radio input element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a radio input element (`<input type=\"radio\">`) with the specified attributes.\r\n   * Returns the created radio input element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createInputRadioElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    attributes.type = 'radio'; // Ensure type is set to 'radio'\n    const radioElement = this.createElementWithAttributes('input', attributes, null, throwOnError);\n    return radioElement;\n  }\n\n  /**\r\n   * Creates a list element (ul or ol) with specified attributes and list items.\r\n   *\r\n   * @param {string} listType - The type of list ('ul' for unordered list or 'ol' for ordered list).\r\n   * @param {Object} attributes - Additional attributes to set for the list element.\r\n   * @param {Array} items - An array of objects representing list items with their attributes and text content.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLUListElement|HTMLOListElement|null} - The created list element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'listType', 'attributes', or 'items' parameters are not of the expected types.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const unorderedList = ElementBuilder.createListElement('ul', \r\n   * { class: 'my-list' },\r\n   * [{ text: 'Item 1' }, { text: 'Item 2' }]);\r\n   * \r\n   * const unorderedList = js.ElementBuilder.createListElement('ul', { class: 'my-list' }, [\r\n   *  { text: 'Item 1', attributes: { 'data-id': '1', 'data-type': 'item' } },\r\n   *  { text: 'Item 2', attributes: { 'data-id': '2', 'data-type': 'item' } }\r\n   *  ]);\r\n   * \r\n   *  const orderedList = ElementBuilder.createListElement('ol', { start: 3 }, [{ text: 'Item 1' }, { text: 'Item 2' }]);\r\n   *\r\n   * @output {HTMLUListElement|HTMLOListElement|null} - The created list element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a list element (ul or ol) with specified attributes and list items.\r\n   * Returns the created list element if successful, or null if an error occurs.\r\n   * Throws an error if the 'listType', 'attributes', or 'items' parameters are not of the expected types.\r\n   */\n  static createListElement(listType, attributes = {}, items = [], throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: listType,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArrayOfObjects({\n      param: items,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const listElement = this.createElementWithAttributes(listType, attributes, null, throwOnError);\n    items.forEach(item => {\n      const listItemAttributes = item.attributes || {};\n      const listItem = this.createElementWithAttributes('li', listItemAttributes, item.text, throwOnError);\n      listElement.appendChild(listItem);\n    });\n    return listElement;\n  }\n\n  /**\r\n   * Creates a paragraph element with specified attributes and text content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the paragraph element.\r\n   * @param {string} textContent - The text content for the paragraph element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLParagraphElement|null} - The created paragraph element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object or if 'textContent' is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const paragraphElement = ElementBuilder.createParagraphElement({ class: 'my-paragraph' }, 'This is a paragraph.');\r\n   *\r\n   * @output {HTMLParagraphElement|null} - The created paragraph element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a paragraph element with the specified attributes and text content.\r\n   * Returns the created paragraph element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object or if 'textContent' is not a string.\r\n   */\n  static createParagraphElement(attributes = {}, textContent = '', throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: textContent,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const paragraphElement = this.createElementWithAttributes('p', attributes, textContent, throwOnError);\n    return paragraphElement;\n  }\n\n  /**\r\n   * Creates a heading element with specified attributes and text content.\r\n   *\r\n   * @param {number} level - The heading level (1 to 6).\r\n   * @param {Object} attributes - Additional attributes to set for the heading element.\r\n   * @param {string} textContent - The text content for the heading element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLHeadingElement|null} - The created heading element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'level' parameter is not a number,\r\n   * if the 'attributes' parameter is not an object, or if 'textContent' is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const headingElement = ElementBuilder.createHeadingElement(2, { class: 'my-heading' }, 'Heading Text');\r\n   *\r\n   * @output {HTMLHeadingElement|null} - The created heading element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a heading element with the specified level, attributes, and text content.\r\n   * Returns the created heading element if successful, or null if an error occurs.\r\n   * Throws an error if the 'level' parameter is not a number,\r\n   * if the 'attributes' parameter is not an object, or if 'textContent' is not a string.\r\n   */\n  static createHeadingElement(level, attributes = {}, textContent = '', throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: level,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: textContent,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    if (level < 1 || level > 6) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid heading level');\n    }\n    const headingTag = `h${level}`;\n    const headingElement = this.createElementWithAttributes(headingTag, attributes, textContent, throwOnError);\n    return headingElement;\n  }\n\n  /**\r\n   * Creates a span element with specified attributes and text content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the span element.\r\n   * @param {string} textContent - The text content for the span element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLSpanElement|null} - The created span element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object, or if 'textContent' is not a string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const spanElement = ElementBuilder.createSpanElement({ class: 'my-span' }, 'Span Text');\r\n   *\r\n   * @output {HTMLSpanElement|null} - The created span element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a span element with the specified attributes and text content.\r\n   * Returns the created span element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object, or if 'textContent' is not a string.\r\n   */\n  static createSpanElement(attributes = {}, textContent = '', throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: textContent,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const spanElement = this.createElementWithAttributes('span', attributes, textContent, throwOnError);\n    return spanElement;\n  }\n\n  /**\r\n   * Creates an HR (horizontal line) element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the HR element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLHRElement|null} - The created HR element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const hrElement = ElementBuilder.createHRLineElement({ class: 'my-hr', size: '2' });\r\n   *\r\n   * @output {HTMLHRElement|null} - The created HR element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an HR (horizontal line) element with the specified attributes.\r\n   * Returns the created HR element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createHRLineElement(attributes = {}, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const hrElement = this.createElementWithAttributes('hr', attributes, null, throwOnError);\n    return hrElement;\n  }\n\n  /**\r\n   * Creates a <div> element with specified attributes and inner HTML content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <div> element.\r\n   * @param {string|null} innerHTML - The inner HTML content for the <div> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLDivElement|null} - The created <div> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const divElement = ElementBuilder.createDivElement({ id: 'example', class: 'sample' }, 'Hello World!');\r\n   *\r\n   * @output {HTMLDivElement|null} - The created <div> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <div> element with the specified attributes and inner HTML content.\r\n   * Returns the created <div> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerHTML' is not a string or null.\r\n   */\n  static createDivElement(attributes = {}, innerHTML = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isStringOrNull({\n      param: innerHTML,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const divElement = this.createElementWithAttributes('div', attributes, innerHTML, throwOnError);\n    return divElement;\n  }\n\n  /**\r\n   * Creates an HTML element with specified tag name, attributes, and innerHTML content in a given namespace.\r\n   *\r\n   * @param {string} namespaceURI - The namespace URI for the element.\r\n   * @param {string} tagName - The tag name of the element to be created.\r\n   * @param {Object|null} attributes - Additional attributes to set for the element.\r\n   * @param {string|null} [innerHTML=null] - The innerHTML content for the element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The created HTML element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'namespaceURI' or 'tagName' parameter is not a string,\r\n   * or if 'innerHTML' is not a string or null.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const svgElement = ElementBuilder.createElementWithAttributesNS('http://www.w3.org/2000/svg', 'svg', { width: '100', height: '100' }, '<circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />');\r\n   *\r\n   * @output {HTMLElement|null} - The created HTML element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an HTML element with the specified tag name, attributes, and innerHTML content in a given namespace.\r\n   * Returns the created HTML element if successful, or null if an error occurs.\r\n   * Throws an error if the 'namespaceURI' or 'tagName' parameter is not a string,\r\n   * or if 'innerHTML' is not a string or null.\r\n   */\n  static _createElementWithAttributesNS(namespaceURI, tagName, attributes, innerHTML = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: namespaceURI,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObjectOrNull({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isStringOrNull({\n      param: innerHTML,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const element = document.createElementNS(namespaceURI, tagName);\n    if (attributes !== null) {\n      Object.entries(attributes).forEach(([key, value]) => {\n        element.setAttribute(key, value);\n      });\n    }\n    if (innerHTML !== null) {\n      element.innerHTML = innerHTML;\n    }\n    return element;\n  }\n\n  /**\r\n   * Creates an SVG element with specified attributes and inner content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the SVG element.\r\n   * @param {string|null} innerContent - The inner content for the SVG element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {SVGSVGElement|null} - The created SVG element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerContent' is not a string or null.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const svgElement = ElementBuilder.createSVGElement(\r\n   *  { width: '100', height: '100' },\r\n   *  '<circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />'\r\n   * );\r\n   *\r\n   * @output {SVGSVGElement|null} - The created SVG element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an SVG element with the specified attributes and inner content.\r\n   * Returns the created SVG element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'innerContent' is not a string or null.\r\n   */\n  static createSVGElement(attributes = {}, innerContent = null, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isStringOrNull({\n      param: innerContent,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const svgElement = this._createElementWithAttributesNS('http://www.w3.org/2000/svg', 'svg', attributes, innerContent, throwOnError);\n    return svgElement;\n  }\n\n  /**\r\n   * Creates an <audio> element with specified attributes and source elements.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <audio> element.\r\n   * @param {Array<Object>} sources - An array of source elements with attributes for the <audio> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLAudioElement|null} - The created <audio> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object or if 'sources' is not an array of objects.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const audioElement = ElementBuilder.createAudioElement(\r\n   *    { controls: true },\r\n   *    [\r\n   *      { src: 'audio.mp3', type: 'audio/mp3' },\r\n   *      { src: 'audio.ogg', type: 'audio/ogg' }\r\n   *    ]\r\n   *  );\r\n   *\r\n   * @output {HTMLAudioElement|null} - The created <audio> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an <audio> element with the specified attributes and source elements.\r\n   * Returns the created <audio> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object or if 'sources' is not an array of objects.\r\n   */\n  static createAudioElement(attributes, sources, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArrayOfObjects({\n      param: sources,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const audioElement = document.createElement('audio');\n\n    // Set attributes for the audio element\n    Object.entries(attributes).forEach(([key, value]) => {\n      audioElement.setAttribute(key, value);\n    });\n\n    // Add source elements to the audio element\n    sources.forEach(source => {\n      const sourceElement = document.createElement('source');\n      Object.entries(source).forEach(([key, value]) => {\n        sourceElement.setAttribute(key, value);\n      });\n      audioElement.appendChild(sourceElement);\n    });\n    return audioElement;\n  }\n\n  /**\r\n   * Creates a <video> element with specified attributes and source elements.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <video> element.\r\n   * @param {Array<Object>} sources - An array of source elements with attributes for the <video> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLVideoElement|null} - The created <video> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object or if 'sources' is not an array of objects.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const videoElement = ElementBuilder.createVideoElement(\r\n   *    { controls: true, width: '640', height: '360' },\r\n   *    [\r\n   *      { src: 'video.mp4', type: 'video/mp4' },\r\n   *      { src: 'video.webm', type: 'video/webm' }\r\n   *    ]\r\n   *  );\r\n   *\r\n   * @output {HTMLVideoElement|null} - The created <video> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <video> element with the specified attributes and source elements.\r\n   * Returns the created <video> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object or if 'sources' is not an array of objects.\r\n   */\n  static createVideoElement(attributes, sources, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArrayOfObjects({\n      param: sources,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const videoElement = document.createElement('video');\n\n    // Set attributes for the video element\n    Object.entries(attributes).forEach(([key, value]) => {\n      videoElement.setAttribute(key, value);\n    });\n\n    // Add source elements to the video element\n    sources.forEach(source => {\n      const sourceElement = document.createElement('source');\n      Object.entries(source).forEach(([key, value]) => {\n        sourceElement.setAttribute(key, value);\n      });\n      videoElement.appendChild(sourceElement);\n    });\n    return videoElement;\n  }\n\n  /**\r\n   * Creates a <canvas> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <canvas> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLCanvasElement|null} - The created <canvas> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const canvasElement = ElementBuilder.createCanvasElement({ width: 800, height: 600 });\r\n   *\r\n   * @output {HTMLCanvasElement|null} - The created <canvas> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <canvas> element with the specified attributes.\r\n   * Returns the created <canvas> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createCanvasElement(attributes, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const canvasElement = document.createElement('canvas');\n    Object.entries(attributes).forEach(([key, value]) => {\n      canvasElement.setAttribute(key, value);\n    });\n    return canvasElement;\n  }\n\n  /**\r\n   * Creates an <iframe> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <iframe> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLIFrameElement|null} - The created <iframe> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const iframeElement = ElementBuilder.createIframeElement({ src: 'https://example.com', width: 800, height: 600 });\r\n   *\r\n   * @output {HTMLIFrameElement|null} - The created <iframe> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an <iframe> element with the specified attributes.\r\n   * Returns the created <iframe> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createIframeElement(attributes, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const iframeElement = document.createElement('iframe');\n\n    // Set attributes for the iframe element\n    Object.entries(attributes).forEach(([key, value]) => {\n      iframeElement.setAttribute(key, value);\n    });\n    return iframeElement;\n  }\n\n  /**\r\n   * Creates a <footer> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <footer> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The created <footer> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const footerElement = ElementBuilder.createFooterElement({ class: 'footer', id: 'footer1' });\r\n   *\r\n   * @output {HTMLElement|null} - The created <footer> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <footer> element with the specified attributes.\r\n   * Returns the created <footer> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createFooterElement(attributes, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const footerElement = this.createElementWithAttributes('footer', attributes, null, throwOnError);\n    return footerElement;\n  }\n\n  /**\r\n   * Creates a <section> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <section> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The created <section> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const sectionElement = ElementBuilder.createSectionElement({ class: 'main-section', id: 'section1' });\r\n   *\r\n   * @output {HTMLElement|null} - The created <section> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <section> element with the specified attributes.\r\n   * Returns the created <section> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createSectionElement(attributes, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const sectionElement = this.createElementWithAttributes('section', attributes, null, throwOnError);\n    return sectionElement;\n  }\n\n  /**\r\n   * Creates an <article> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <article> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The created <article> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const articleElement = ElementBuilder.createArticleElement({ class: 'blog-post', id: 'post1' });\r\n   *\r\n   * @output {HTMLElement|null} - The created <article> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates an <article> element with the specified attributes.\r\n   * Returns the created <article> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object.\r\n   */\n  static createArticleElement(attributes, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const articleElement = this.createElementWithAttributes('article', attributes, null, throwOnError);\n    return articleElement;\n  }\n\n  /**\r\n   * Creates a <time> element with specified attributes and text content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <time> element.\r\n   * @param {string} dateTime - The value for the 'datetime' attribute of the <time> element.\r\n   * @param {string} textContent - The text content for the <time> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The created <time> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object, or if 'dateTime' or 'textContent' is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const timeElement = ElementBuilder.createTimeElement({ class: 'event-time' }, '2024-02-14T12:00:00', '12:00 PM');\r\n   *\r\n   * @output {HTMLElement|null} - The created <time> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <time> element with the specified attributes, 'datetime' value, and text content.\r\n   * Returns the created <time> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object, or if 'dateTime' or 'textContent' is not a string.\r\n   */\n  static createTimeElement(attributes, dateTime, textContent, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: dateTime,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: textContent,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const timeElement = this.createElementWithAttributes('time', attributes, textContent, throwOnError);\n    timeElement.setAttribute('datetime', dateTime);\n    return timeElement;\n  }\n\n  /**\r\n   * Creates a <progress> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <progress> element.\r\n   * @param {number} value - The initial value for the 'value' attribute of the <progress> element.\r\n   * @param {number} max - The maximum value for the 'max' attribute of the <progress> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLProgressElement|null} - The created <progress> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'value' or 'max' is not a number.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const progressElement = ElementBuilder.createProgressElement({ class: 'loading-bar' }, 50, 100);\r\n   *\r\n   * @output {HTMLProgressElement|null} - The created <progress> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <progress> element with the specified attributes, initial value, and maximum value.\r\n   * Returns the created <progress> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'value' or 'max' is not a number.\r\n   */\n  static createProgressElement(attributes, value, max, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: value,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: max,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const progressElement = this.createElementWithAttributes('progress', attributes, null, throwOnError);\n    progressElement.value = value;\n    progressElement.max = max;\n    return progressElement;\n  }\n\n  /**\r\n  * Creates a <meter> element with specified attributes.\r\n  *\r\n  * @param {Object} attributes - Additional attributes to set for the <meter> element.\r\n  * @param {number} value - The initial value for the 'value' attribute of the <meter> element.\r\n  * @param {number} min - The minimum value for the 'min' attribute of the <meter> element.\r\n  * @param {number} max - The maximum value for the 'max' attribute of the <meter> element.\r\n  * @param {number} low - The 'low' value for the <meter> element.\r\n  * @param {number} high - The 'high' value for the <meter> element.\r\n  * @param {number} optimum - The 'optimum' value for the <meter> element.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n  *\r\n  * @return {HTMLMeterElement|null} - The created <meter> element if successful, or null if an error occurs.\r\n  *\r\n  * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n  * or if 'value', 'min', 'max', 'low', 'high', or 'optimum' is not a number.\r\n  *\r\n  * @example\r\n  *  Example usage:\r\n  *  const meterElement = ElementBuilder.createMeterElement({ class: 'power-meter' }, 75, 0, 100, 25, 50, 75);\r\n  *\r\n  * @output {HTMLMeterElement|null} - The created <meter> element if successful, or null if an error occurs.\r\n  *\r\n  * @description\r\n  * This method creates a <meter> element with the specified attributes,\r\n  * initial value, minimum value, maximum value, 'low', 'high', and 'optimum' values.\r\n  * Returns the created <meter> element if successful, or null if an error occurs.\r\n  * Throws an error if the 'attributes' parameter is not an object,\r\n  * or if 'value', 'min', 'max', 'low', 'high', or 'optimum' is not a number.\r\n  */\n  static createMeterElement(attributes, value, min, max, low, high, optimum, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: value,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: min,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: max,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: low,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: high,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: optimum,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const meterElement = this.createElementWithAttributes('meter', attributes, null, throwOnError);\n    meterElement.value = value;\n    meterElement.min = min;\n    meterElement.max = max;\n    meterElement.low = low;\n    meterElement.high = high;\n    meterElement.optimum = optimum;\n    return meterElement;\n  }\n\n  /**\r\n   * Creates a <details> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <details> element.\r\n   * @param {boolean} [open=false] - If true, the <details> element will be open; otherwise, it will be closed.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLDetailsElement|null} - The created <details> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'open' is not a boolean.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const detailsElement = ElementBuilder.createDetailsElement({ class: 'info-box' }, true);\r\n   *\r\n   * @output {HTMLDetailsElement|null} - The created <details> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <details> element with the specified attributes and open state.\r\n   * Returns the created <details> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if 'open' is not a boolean.\r\n   */\n  static createDetailsElement(attributes, open = false, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isBoolean({\n      param: open,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const detailsElement = this.createElementWithAttributes('details', attributes, null, throwOnError);\n    detailsElement.open = open;\n    return detailsElement;\n  }\n\n  /**\r\n   * Creates a <summary> element with specified attributes and text content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <summary> element.\r\n   * @param {string} text - The text content for the <summary> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLSummaryElement|null} - The created <summary> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * or if the 'text' parameter is not a string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const summaryElement = ElementBuilder.createSummaryElement({ class: 'section-header' }, 'Section Title');\r\n   *\r\n   * @output {HTMLSummaryElement|null} - The created <summary> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <summary> element with the specified attributes and text content.\r\n   * Returns the created <summary> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * or if the 'text' parameter is not a string.\r\n   */\n  static createSummaryElement(attributes, text, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: text,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const summaryElement = this.createElementWithAttributes('summary', attributes, text, throwOnError);\n    return summaryElement;\n  }\n\n  /**\r\n   * Creates a <datalist> element with specified attributes and option elements.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <datalist> element.\r\n   * @param {Array} options - An array of objects representing option elements with attributes and text content.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLDataListElement|null} - The created <datalist> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'options' parameter is not an array of objects,\r\n   * or if any option object has invalid attributes.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const dataListElement = ElementBuilder.createDatalistElement(\r\n   *    { id: 'colors' },\r\n   *    [\r\n   *      { value: 'red', label: 'Red' },\r\n   *      { value: 'green', label: 'Green' },\r\n   *      { value: 'blue', label: 'Blue' }\r\n   *    ]\r\n   *  );\r\n   *\r\n   * @output {HTMLDataListElement|null} - The created <datalist> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <datalist> element with the specified attributes and option elements.\r\n   * Returns the created <datalist> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'options' parameter is not an array of objects,\r\n   * or if any option object has invalid attributes.\r\n   */\n  static createDatalistElement(attributes, options, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArrayOfObjects({\n      param: options,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const dataListElement = this.createElementWithAttributes('datalist', attributes, null, throwOnError);\n    options.forEach(option => {\n      const {\n        value,\n        label\n      } = option;\n      if (_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n        param: option,\n        throwOnError\n      })) {\n        const optionElement = this.createElementWithAttributes('option', {\n          value,\n          label\n        }, null, throwOnError);\n        dataListElement.appendChild(optionElement);\n      }\n    });\n    return dataListElement;\n  }\n\n  /**\r\n   * Creates a <script> element with specified attributes and content.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <script> element.\r\n   * @param {string} content - The content (JavaScript code) to be included in the <script> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLScriptElement|null} - The created <script> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'content' parameter is not a string,\r\n   * or if the 'attributes' object contains invalid attributes.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const scriptElement = ElementBuilder.createScriptElement(\r\n   *    { src: 'script.js', type: 'text/javascript' },\r\n   *    'console.log(\"Hello, world!\");'\r\n   *  );\r\n   *\r\n   * @output {HTMLScriptElement|null} - The created <script> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <script> element with the specified attributes and content.\r\n   * Returns the created <script> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object,\r\n   * if the 'content' parameter is not a string,\r\n   * or if the 'attributes' object contains invalid attributes.\r\n   */\n  static createScriptElement(attributes, content, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: content,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const scriptElement = this.createElementWithAttributes('script', attributes, null, throwOnError);\n    scriptElement.textContent = content;\n    return scriptElement;\n  }\n\n  /**\r\n   * Creates a <meta> element with specified attributes.\r\n   *\r\n   * @param {Object} attributes - Additional attributes to set for the <meta> element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLMetaElement|null} - The created <meta> element if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'attributes' parameter is not an object\r\n   * or if the 'attributes' object contains invalid attributes.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const metaElement = ElementBuilder.createMetaElement({ charset: 'UTF-8' });\r\n   *\r\n   * @output {HTMLMetaElement|null} - The created <meta> element if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a <meta> element with the specified attributes.\r\n   * Returns the created <meta> element if successful, or null if an error occurs.\r\n   * Throws an error if the 'attributes' parameter is not an object\r\n   * or if the 'attributes' object contains invalid attributes.\r\n   */\n  static createMetaElement(attributes, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: attributes,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    const metaElement = this.createElementWithAttributes('meta', attributes, null, throwOnError);\n    return metaElement;\n  }\n\n  /**\r\n   * Creates a comment node with specified text content.\r\n   *\r\n   * @param {string} text - The text content of the comment node.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {Comment|null} - The created comment node if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'text' parameter is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const commentNode = ElementBuilder.createCommentNode('This is a comment.');\r\n   *\r\n   * @output {Comment|null} - The created comment node if successful, or null if an error occurs.\r\n   *\r\n   * @description\r\n   * This method creates a comment node with the specified text content.\r\n   * Returns the created comment node if successful, or null if an error occurs.\r\n   * Throws an error if the 'text' parameter is not a string.\r\n   */\n  static createCommentNode(text, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: text,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n    }\n    return document.createComment(text);\n  }\n\n  /**\r\n   * Logs all the available static functions in the ElementBuilder class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // ElementBuilder.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available static functions in the ElementBuilder class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(ElementBuilder).filter(name => typeof ElementBuilder[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    console.log(`Available static functions in ElementBuilder class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/dom-utils/ElementBuilder/elementBuilder.js?");

/***/ }),

/***/ "./src/dom-utils/ElementExplorer/elementExplorer.js":
/*!**********************************************************!*\
  !*** ./src/dom-utils/ElementExplorer/elementExplorer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ElementExplorer: () => (/* binding */ ElementExplorer)\n/* harmony export */ });\n/* harmony import */ var _ElementHandler_elementHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ElementHandler/elementHandler */ \"./src/dom-utils/ElementHandler/elementHandler.js\");\n/* harmony import */ var _validation_validation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../validation/validation */ \"./src/validation/validation.js\");\n\n\n\n/**\r\n * Class representing an Element Explorer for advanced manipulation and exploration of HTML elements.\r\n * Extends the functionality of the ElementHandler class by providing additional methods for in-depth exploration and manipulation of HTML elements.\r\n * This class is designed to offer advanced functionality beyond basic element handling, making it suitable for complex DOM interactions.\r\n *\r\n * @extends ElementHandler\r\n */\n\nclass ElementExplorer extends _ElementHandler_elementHandler__WEBPACK_IMPORTED_MODULE_0__.ElementHandler {\n  /**\r\n   * Retrieves the parent element of the given HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose parent is to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {HTMLElement|null} - The parent element, or null if the element has no parent.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'childElement' is an HTML element.\r\n   * const parentElement = ElementExplorer.getParent(childElement);\r\n   * \r\n   * @output {HTMLElement|null} - The parent element of the given child element.\r\n   * \r\n   * @description\r\n   * This method retrieves the parent element of the provided HTML element.\r\n   * If the 'element' parameter is not an object or has no parent, it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n   * \r\n   * Note: The parent element is the direct ancestor in the HTML hierarchy.\r\n   * If the 'element' is the root element or not an HTML element, it returns null.\r\n   */\n  static getParent(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    if (!element) {\n      throw new Error(\"'element' parameter is required.\");\n    }\n    return element.parentElement || null;\n  }\n\n  /**\r\n   * Retrieves an array of ancestor elements for the given HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose ancestors are to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {Array<HTMLElement>|null} - An array of ancestor elements, or null if the element has no ancestors.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'targetElement' is an HTML element.\r\n   * const ancestors = ElementExplorer.getAncestors(targetElement);\r\n   * \r\n   * @output {Array<HTMLElement>|null} - An array containing the ancestor elements of the provided HTML element.\r\n   * \r\n   * @description\r\n   * This method retrieves an array of ancestor elements for the provided HTML element.\r\n   * An ancestor element is any parent, grandparent, or further ancestor in the HTML hierarchy.\r\n   * If the 'element' parameter is not an object or has no ancestors, it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n   */\n  static getAncestors(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const ancestors = [];\n    let currentElement = element;\n    while (currentElement.parentElement) {\n      ancestors.push(currentElement.parentElement);\n      currentElement = currentElement.parentElement;\n    }\n    return ancestors;\n  }\n\n  /**\r\n  * Retrieves an array of child elements for the given HTML element.\r\n  *\r\n  * @param {HTMLElement} element - The HTML element whose child elements are to be retrieved.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n  * \r\n  * @return {Array<HTMLElement>|null} - An array of child elements, or null if the element has no children.\r\n  * \r\n  * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n  * \r\n  * @example\r\n  * // Example usage:\r\n  * // Assuming 'parentElement' is an HTML element.\r\n  * const children = ElementExplorer.getChildren(parentElement);\r\n  * \r\n  * @output {Array<HTMLElement>|null} - An array containing the child elements of the provided HTML element.\r\n  * \r\n  * @description\r\n  * This method retrieves an array of child elements for the provided HTML element.\r\n  * If the 'element' parameter is not an object or has no children, it returns null.\r\n  * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n  */\n  static getChildren(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    return Array.from(element.children) || null;\n  }\n\n  /**\r\n   * Retrieves the first child element for the given HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose first child is to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {HTMLElement|null} - The first child element, or null if the element has no children.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element.\r\n   * const firstChild = ElementExplorer.getFirstChild(parentElement);\r\n   * \r\n   * @output {HTMLElement|null} - The first child element of the provided HTML element.\r\n   * \r\n   * @description\r\n   * This method retrieves the first child element for the provided HTML element.\r\n   * If the 'element' parameter is not an object or has no children, it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n   */\n  static getFirstChild(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    return element.firstElementChild || null;\n  }\n\n  /**\r\n   * Retrieves the last child element for the given HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose last child is to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {HTMLElement|null} - The last child element, or null if the element has no children.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element.\r\n   * const lastChild = ElementExplorer.getLastChild(parentElement);\r\n   * \r\n   * @output {HTMLElement|null} - The last child element of the provided HTML element.\r\n   * \r\n   * @description\r\n   * This method retrieves the last child element for the provided HTML element.\r\n   * If the 'element' parameter is not an object or has no children, it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n   */\n  static getLastChild(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    return element.lastElementChild || null;\n  }\n\n  /**\r\n  * Retrieves the next sibling element for the given HTML element.\r\n  *\r\n  * @param {HTMLElement} element - The HTML element whose next sibling is to be retrieved.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n  * \r\n  * @return {HTMLElement|null} - The next sibling element, or null if there is no next sibling.\r\n  * \r\n  * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n  * \r\n  * @example\r\n  * // Example usage:\r\n  * // Assuming 'currentElement' is an HTML element.\r\n  * // const nextSibling = ElementExplorer.getNextSibling(currentElement);\r\n  * \r\n  * @output {HTMLElement|null} - The next sibling element of the provided HTML element.\r\n  * \r\n  * @description\r\n  * This method retrieves the next sibling element for the provided HTML element.\r\n  * If the 'element' parameter is not an object or has no next sibling, it returns null.\r\n  * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n  */\n  static getNextSibling(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    return element.nextElementSibling || null;\n  }\n\n  /**\r\n   * Retrieves the previous sibling element for the given HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose previous sibling is to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {HTMLElement|null} - The previous sibling element, or null if there is no previous sibling.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'currentElement' is an HTML element.\r\n   * // const previousSibling = ElementExplorer.getPreviousSibling(currentElement);\r\n   * \r\n   * @output {HTMLElement|null} - The previous sibling element of the provided HTML element.\r\n   * \r\n   * @description\r\n   * This method retrieves the previous sibling element for the provided HTML element.\r\n   * If the 'element' parameter is not an object or has no previous sibling, it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n   */\n  static getPreviousSibling(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    return element.previousElementSibling || null;\n  }\n\n  /**\r\n   * Retrieves an array of all sibling elements for the given HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose siblings are to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {Array<HTMLElement>|null} - An array of sibling elements, or null if there are no siblings.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or if it's not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   *  Example usage:\r\n   *  Assuming 'currentElement' is an HTML element.\r\n   *  const siblings = ElementExplorer.getAllSiblings(currentElement);\r\n   * \r\n   * @output {Array<HTMLElement>|null} - An array containing all sibling elements of the provided HTML element.\r\n   * \r\n   * @description\r\n   * This method retrieves an array of all sibling elements for the provided HTML element.\r\n   * If the 'element' parameter is not an object or has no siblings, it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n   */\n  static getAllSiblings(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const siblings = Array.from(element.parentElement.children);\n    const index = siblings.indexOf(element);\n    if (index !== -1) {\n      siblings.splice(index, 1);\n    }\n    return siblings.length > 0 ? siblings : null;\n  }\n\n  /**\r\n   * Retrieves the child element at the specified index for the given HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose child is to be retrieved.\r\n   * @param {number} index - The index of the child element to retrieve.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {HTMLElement|null} - The child element at the specified index, or null if not found.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object, if the 'index' parameter is not a number,\r\n   * or if 'element' is not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   *  Example usage:\r\n   *  Assuming 'parentElement' is an HTML element.\r\n   *  const childAtIndex = ElementExplorer.getChildByIndex(parentElement, 2);\r\n   * \r\n   * @output {HTMLElement|null} - The child element at the specified index of the provided HTML element.\r\n   * \r\n   * @description\r\n   * This method retrieves the child element at the specified index for the provided HTML element.\r\n   * If the 'element' parameter is not an object, the 'index' parameter is not a number, or the child is not found,\r\n   * it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n   */\n  static getChildByIndex(element, index, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isNumber({\n      param: index,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const children = Array.from(element.children);\n    return children[index] || null;\n  }\n\n  /**\r\n  * Retrieves all descendants (children, grandchildren, etc.) of the provided HTML element.\r\n  *\r\n  * @param {HTMLElement} element - The HTML element whose descendants are to be retrieved.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n  * \r\n  * @return {Array<HTMLElement>} - An array containing all descendants of the provided HTML element.\r\n  * \r\n  * @throw {Error} - Throws an error if the 'element' parameter is not an object or if 'element' is not provided (when throwOnError is true).\r\n  * \r\n  * @example\r\n  * // Example usage:\r\n  * // Assuming 'parentElement' is an HTML element.\r\n  * // const descendants = ElementExplorer.getDescendants(parentElement);\r\n  * \r\n  * @output {Array<HTMLElement>} - An array of all descendants of the provided HTML element.\r\n  * \r\n  * @description\r\n  * This method retrieves all descendants (children, grandchildren, etc.) of the provided HTML element.\r\n  * If the 'element' parameter is not an object or is not provided, it returns an empty array.\r\n  * If throwOnError is true and 'element' is not provided or is not an object, it throws an error.\r\n  */\n  static getDescendants(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const descendants = [];\n    const queue = [element];\n    while (queue.length > 0) {\n      const currentElement = queue.shift();\n      descendants.push(...currentElement.children);\n      queue.push(...currentElement.children);\n    }\n    return descendants;\n  }\n\n  /**\r\n  * Retrieves descendants of the provided HTML element based on the specified tag name.\r\n  *\r\n  * @param {HTMLElement} element - The HTML element whose descendants are to be retrieved.\r\n  * @param {string} tagName - The tag name of the descendants to filter.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n  * \r\n  * @return {Array<HTMLElement>} - An array containing descendants with the specified tag name.\r\n  * \r\n  * @throw {Error} - Throws an error if the 'element' parameter is not an object, the 'tagName' parameter is not a string, or if 'element' is not provided (when throwOnError is true).\r\n  * \r\n  * @example\r\n  * // Example usage:\r\n  * // Assuming 'parentElement' is an HTML element and 'div' is the tag name.\r\n  * // const descendantsByTagName = ElementExplorer.getDescendantsByTagName(parentElement, 'div');\r\n  * \r\n  * @output {Array<HTMLElement>} - An array of descendants with the specified tag name.\r\n  * \r\n  * @description\r\n  * This method retrieves descendants of the provided HTML element based on the specified tag name.\r\n  * If the 'element' parameter is not an object, the 'tagName' parameter is not a string, or 'element' is not provided, it returns an empty array.\r\n  * If throwOnError is true and 'element' or 'tagName' is not provided or is not of the expected type, it throws an error.\r\n  */\n  static getDescendantsByTagName(element, tagName, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const descendants = Array.from(element.getElementsByTagName(tagName));\n    return descendants;\n  }\n\n  /**\r\n   * Filters the descendants of the provided HTML element based on the specified class name.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose descendants are to be filtered.\r\n   * @param {string} className - The class name used for filtering descendants.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   *\r\n   * @throws {Error} Throws an error if the 'element' parameter is not an object, the 'className' parameter is not a string, or if 'element' is not provided (when throwOnError is true).\r\n   *\r\n   * @return {Array<HTMLElement>} - An array containing descendants with the specified class name.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element and 'exampleClass' is the class name.\r\n   * // const descendantsByClass = ElementExplorer.filterByClass(parentElement, 'exampleClass');\r\n   *\r\n   * @output {Array<HTMLElement>} - An array of descendants with the specified class name.\r\n   *\r\n   * @description\r\n   * This method filters the descendants of the provided HTML element based on the specified class name.\r\n   * If the 'element' parameter is not an object, the 'className' parameter is not a string, or 'element' is not provided, it returns an empty array.\r\n   * If throwOnError is true and 'element' or 'className' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static filterByClass(element, className, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: className,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const descendants = Array.from(element.getElementsByClassName(className));\n    return descendants;\n  }\n\n  /**\r\n   * Filters the descendants of the provided HTML element based on the specified attribute and its value.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose descendants are to be filtered.\r\n   * @param {string} attribute - The attribute used for filtering descendants.\r\n   * @param {string} value - The value of the attribute to filter descendants.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   *\r\n   * @throws {Error} Throws an error if the 'element' parameter is not an object, the 'attribute' parameter is not a string, the 'value' parameter is not a string, or if 'element' is not provided (when throwOnError is true).\r\n   *\r\n   * @return {Array<HTMLElement>} - An array containing descendants with the specified attribute and value.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element, 'data-type' is the attribute, and 'exampleValue' is the value.\r\n   * // const descendantsByAttribute = ElementExplorer.filterByAttribute(parentElement, 'data-type', 'exampleValue');\r\n   *\r\n   * @output {Array<HTMLElement>} - An array of descendants with the specified attribute and value.\r\n   *\r\n   * @description\r\n   * This method filters the descendants of the provided HTML element based on the specified attribute and its value.\r\n   * If the 'element' parameter is not an object, the 'attribute' parameter is not a string, the 'value' parameter is not a string, or 'element' is not provided, it returns an empty array.\r\n   * If throwOnError is true and 'element', 'attribute', or 'value' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static filterByAttribute(element, attribute, value, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: attribute,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: value,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const descendants = Array.from(element.querySelectorAll(`[${attribute}=\"${value}\"]`));\n    return descendants;\n  }\n\n  /**\r\n   * Retrieves the position of the provided HTML element among its siblings.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose position is to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {number|null} - The position of the element among its siblings (zero-based index) or null if the element has no parent.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or if 'element' is not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'childElement' is an HTML element.\r\n   * // const position = ElementExplorer.getPositionInParent(childElement);\r\n   * \r\n   * @output {number|null} - The position of the element among its siblings.\r\n   * \r\n   * @description\r\n   * This method retrieves the position of the provided HTML element among its siblings.\r\n   * If the 'element' parameter is not an object or 'element' is not provided, it returns null.\r\n   * If throwOnError is true and 'element' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static getPositionInParent(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    if (!element || !element.parentElement) {\n      return null;\n    }\n    const siblings = Array.from(element.parentElement.children);\n    return siblings.indexOf(element);\n  }\n\n  /**\r\n   * Retrieves the insertion point for a new HTML element relative to its siblings.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element for which the insertion point is to be determined.\r\n   * @param {boolean} [before=true] - If true, retrieves the insertion point before the element; otherwise, retrieves it after the element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   * \r\n   * @return {number|null} - The insertion point index relative to the element's siblings or null if the element has no parent.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object, if 'element' is not provided, or if 'before' is not a boolean (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'childElement' is an HTML element.\r\n   * // const insertionPoint = ElementExplorer.getInsertionPoint(childElement, true);\r\n   * \r\n   * @output {number|null} - The insertion point index relative to the element's siblings.\r\n   * \r\n   * @description\r\n   * This method retrieves the insertion point for a new HTML element relative to its siblings.\r\n   * If the 'element' parameter is not an object, 'element' is not provided, or 'before' is not a boolean, it returns null.\r\n   * If throwOnError is true and 'element' is not provided, is not of the expected type, or 'before' is not a boolean, it throws an error.\r\n   */\n  static getInsertionPoint(element, before = true, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isBoolean({\n      param: before,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    if (!element || !element.parentElement) {\n      return null;\n    }\n    const siblings = Array.from(element.parentElement.children);\n    const currentIndex = siblings.indexOf(element);\n    return before ? currentIndex : currentIndex + 1;\n  }\n\n  /**\r\n   * Adds a delegated event listener to a parent element for the specified event type and target selector.\r\n   *\r\n   * @param {HTMLElement} parentElement - The parent element to attach the event listener to.\r\n   * @param {string} eventType - The type of event to listen for (e.g., 'click', 'change').\r\n   * @param {string} targetSelector - The CSS selector for the target elements within the parent.\r\n   * @param {Function} callback - The function to call when the event occurs on a target element.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, logs a warning.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'parentElement', 'eventType', 'targetSelector', or 'callback' parameters are invalid or missing.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element, 'click' is the event type,\r\n   * // '.button' is the target selector, and 'clickHandler' is the callback function.\r\n   * // ElementExplorer.addDelegatedEventListener(parentElement, 'click', 'button', clickHandler);\r\n   *\r\n   * @description\r\n   * This method adds a delegated event listener to a parent element for the specified event type and target selector.\r\n   * The provided callback function is called only when an event occurs on an element matching the target selector within the parent.\r\n   * If throwOnError is true and any parameter is invalid or missing, it throws an error; otherwise, it logs a warning.\r\n   */\n  static addDelegatedEventListener(parentElement, eventType, targetSelector, callback, throwOnError = true) {\n    // Validation logic\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: parentElement,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: eventType,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: targetSelector,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isFunction({\n      param: callback,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    parentElement.addEventListener(eventType, event => {\n      const targetElement = event.target.closest(targetSelector);\n      if (targetElement) {\n        callback(event, targetElement);\n      }\n    });\n  }\n\n  /**\r\n   * Retrieves the path from a given HTML element to a specified ancestor element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element for which the path is to be retrieved.\r\n   * @param {HTMLElement} ancestor - The ancestor HTML element to which the path is calculated.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   * \r\n   * @return {Array<HTMLElement>} - An array containing the HTML elements representing the path from 'element' to 'ancestor'.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' or 'ancestor' parameters are not objects, or if 'element' or 'ancestor' are not provided (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'childElement' and 'ancestorElement' are HTML elements.\r\n   * // const pathToAncestor = ElementExplorer.getPathToAncestor(childElement, ancestorElement);\r\n   * \r\n   * @output {Array<HTMLElement>} - An array of HTML elements representing the path from 'element' to 'ancestor'.\r\n   * \r\n   * @description\r\n   * This method retrieves the path from a given HTML element to a specified ancestor element.\r\n   * If the 'element' or 'ancestor' parameters are not objects, or 'element' or 'ancestor' are not provided, it returns an empty array.\r\n   * If throwOnError is true and 'element' or 'ancestor' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static getPathToAncestor(element, ancestor, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: ancestor,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const path = [];\n    let currentElement = element;\n    while (currentElement && currentElement !== ancestor) {\n      path.push(currentElement);\n      currentElement = currentElement.parentElement;\n    }\n    if (currentElement === ancestor) {\n      path.push(currentElement);\n      return path.reverse();\n    } else {\n      return [];\n    }\n  }\n\n  /**\r\n   * Retrieves the closest ancestor of a given HTML element with a specified tag name.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element for which the ancestor is to be retrieved.\r\n   * @param {string} tagName - The tag name of the ancestor to search for.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The closest ancestor HTML element with the specified tag name, or null if not found.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object, the 'tagName' parameter is not a string, or if 'element' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'childElement' is an HTML element and 'ancestorTag' is the tag name.\r\n   * // const closestAncestorByTag = ElementExplorer.getClosestAncestorByTag(childElement, 'ancestorTag');\r\n   *\r\n   * @output {HTMLElement|null} - The closest ancestor HTML element with the specified tag name, or null if not found.\r\n   *\r\n   * @description\r\n   * This method retrieves the closest ancestor of a given HTML element with a specified tag name.\r\n   * If the 'element' parameter is not an object, the 'tagName' parameter is not a string, or 'element' is not provided, it returns null.\r\n   * If throwOnError is true and 'element' or 'tagName' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static getClosestAncestorByTag(element, tagName, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    let currentElement = element.parentElement;\n    while (currentElement) {\n      if (currentElement.tagName.toLowerCase() === tagName.toLowerCase()) {\n        return currentElement;\n      }\n      currentElement = currentElement.parentElement;\n    }\n    return null;\n  }\n\n  /**\r\n   * Retrieves visible children of the provided HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose visible children are to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   *\r\n   * @return {Array<HTMLElement>} - An array containing visible children of the specified HTML element.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or 'element' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element.\r\n   * // const visibleChildren = ElementExplorer.getVisibleChildren(parentElement);\r\n   *\r\n   * @output {Array<HTMLElement>} - An array containing visible children of the specified HTML element.\r\n   *\r\n   * @description\r\n   * This method retrieves visible children of the provided HTML element.\r\n   * If the 'element' parameter is not an object or 'element' is not provided, it returns an empty array.\r\n   * If throwOnError is true and 'element' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static getVisibleChildren(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const visibleChildren = Array.from(element.children).filter(child => {\n      const styles = window.getComputedStyle(child);\n      return styles && styles.display !== 'none' && styles.visibility !== 'hidden';\n    });\n    return visibleChildren;\n  }\n\n  /**\r\n   * Retrieves invisible children of the provided HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose invisible children are to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   *\r\n   * @return {Array<HTMLElement>} - An array containing invisible children of the specified HTML element.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object or 'element' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element.\r\n   * // const invisibleChildren = ElementExplorer.getInvisibleChildren(parentElement);\r\n   *\r\n   * @output {Array<HTMLElement>} - An array containing invisible children of the specified HTML element.\r\n   *\r\n   * @description\r\n   * This method retrieves invisible children of the provided HTML element.\r\n   * If the 'element' parameter is not an object or 'element' is not provided, it returns an empty array.\r\n   * If throwOnError is true and 'element' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static getInvisibleChildren(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, 'invalid parameters');\n    }\n    const invisibleChildren = Array.from(element.children).filter(child => {\n      const styles = window.getComputedStyle(child);\n      return styles && (styles.display === 'none' || styles.visibility === 'hidden');\n    });\n    return invisibleChildren;\n  }\n\n  /**\r\n   * Retrieves the first child element of the provided HTML element based on the specified tag name.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose first child is to be retrieved.\r\n   * @param {string} tagName - The tag name of the child element to search for.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The first child element with the specified tag name, or null if not found.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object, the 'tagName' parameter is not a string,\r\n   * or if 'element' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element and 'div' is the tag name.\r\n   * // const firstChildDiv = ElementExplorer.getFirstChildByTag(parentElement, 'div');\r\n   *\r\n   * @output {HTMLElement|null} - The first child element with the specified tag name, or null if not found.\r\n   *\r\n   * @description\r\n   * This method retrieves the first child element of the provided HTML element based on the specified tag name.\r\n   * If the 'element' parameter is not an object, the 'tagName' parameter is not a string, or 'element' is not provided,\r\n   * it returns null. If throwOnError is true and 'element' or 'tagName' is not provided or is not of the expected type,\r\n   * it throws an error.\r\n   */\n  static getFirstChildByTag(element, tagName, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    const children = element.getElementsByTagName(tagName);\n    return children.length > 0 ? children[0] : null;\n  }\n\n  /**\r\n   * Retrieves the last child element of the provided HTML element based on the specified tag name.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose last child is to be retrieved.\r\n   * @param {string} tagName - The tag name of the child element to search for.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {HTMLElement|null} - The last child element with the specified tag name, or null if not found.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object, the 'tagName' parameter is not a string,\r\n   * or if 'element' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element and 'div' is the tag name.\r\n   * // const lastChildDiv = ElementExplorer.getLastChildByTag(parentElement, 'div');\r\n   *\r\n   * @output {HTMLElement|null} - The last child element with the specified tag name, or null if not found.\r\n   *\r\n   * @description\r\n   * This method retrieves the last child element of the provided HTML element based on the specified tag name.\r\n   * If the 'element' parameter is not an object, the 'tagName' parameter is not a string, or 'element' is not provided,\r\n   * it returns null. If throwOnError is true and 'element' or 'tagName' is not provided or is not of the expected type,\r\n   * it throws an error.\r\n   */\n  static getLastChildByTag(element, tagName, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isString({\n      param: tagName,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    const children = element.getElementsByTagName(tagName);\n    return children.length > 0 ? children[children.length - 1] : null;\n  }\n\n  /**\r\n   * Retrieves the index of the provided HTML element among its parent's children.\r\n   *\r\n   * @param {HTMLElement} child - The HTML element whose index is to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns -1.\r\n   *\r\n   * @return {number} - The index of the provided element among its parent's children, or -1 if it has no parent.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'child' parameter is not an object or 'child' is not provided (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'childElement' is an HTML element.\r\n   * // const index = ElementExplorer.getChildIndex(childElement);\r\n   *\r\n   * @output {number} - The index of the provided element among its parent's children, or -1 if it has no parent.\r\n   *\r\n   * @description\r\n   * This method retrieves the index of the provided HTML element among its parent's children.\r\n   * If the 'child' parameter is not an object or 'child' is not provided, it returns -1.\r\n   * If throwOnError is true and 'child' is not provided or is not of the expected type, it throws an error.\r\n   */\n  static getChildIndex(child, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: child,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    const parent = child.parentElement;\n    return parent ? Array.from(parent.children).indexOf(child) : -1;\n  }\n\n  /**\r\n   * Swaps the positions of two HTML elements within their common parent.\r\n   *\r\n   * @param {HTMLElement} element1 - The first HTML element to be swapped.\r\n   * @param {HTMLElement} element2 - The second HTML element to be swapped.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - True if the elements were successfully swapped, false otherwise.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element1' or 'element2' parameters are not objects, either element has no parent, or the elements are not siblings (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'elementA' and 'elementB' are HTML elements.\r\n   * // const success = ElementExplorer.swapElements(elementA, elementB);\r\n   *\r\n   * @output {boolean} - True if the elements were successfully swapped, false otherwise.\r\n   *\r\n   * @description\r\n   * This method swaps the positions of two HTML elements within their common parent.\r\n   * If the 'element1' or 'element2' parameters are not objects, either element has no parent, or the elements are not siblings, it returns false.\r\n   * If throwOnError is true and any of the above conditions are met, it throws an error.\r\n   */\n  static swapElements(element1, element2, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element1,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element2,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    const parent = element1.parentElement;\n    if (!parent) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Element1 has no parent.\");\n    }\n    const index1 = Array.from(parent.children).indexOf(element1);\n    const index2 = Array.from(parent.children).indexOf(element2);\n    if (index1 === -1 || index2 === -1) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Elements are not siblings.\");\n    }\n    parent.insertBefore(element1, element2);\n    parent.insertBefore(element2, parent.children[index1]);\n    return true;\n  }\n\n  /**\r\n   * Checks if an HTML element is currently visible on the page.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element to be checked for visibility.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - True if the element is visible, false otherwise.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'targetElement' is an HTML element.\r\n   * // const isVisible = ElementExplorer.isVisible(targetElement);\r\n   *\r\n   * @output {boolean} - True if the element is visible, false otherwise.\r\n   *\r\n   * @description\r\n   * This method checks if an HTML element is currently visible on the page.\r\n   * If the 'element' parameter is not an object, it returns false.\r\n   * If throwOnError is true and 'element' is not of the expected type, it throws an error.\r\n   */\n  static isVisible(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    const style = window.getComputedStyle(element);\n    return style.display !== 'none' && style.visibility !== 'hidden';\n  }\n\n  /**\r\n   * Checks if the provided HTML element is invisible based on its CSS styling.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element to check for invisibility.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   * \r\n   * @return {boolean} - True if the element is invisible, false otherwise.\r\n   * \r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   * \r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'targetElement' is an HTML element.\r\n   * // const isElementInvisible = ElementExplorer.isInvisible(targetElement);\r\n   * \r\n   * @output {boolean} - True if the element is invisible, false otherwise.\r\n   * \r\n   * @description\r\n   * This method checks if the provided HTML element is invisible based on its CSS styling.\r\n   * If the 'element' parameter is not an object and throwOnError is true, it throws an error.\r\n   */\n  static isInvisible(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    const style = window.getComputedStyle(element);\n    return style.display === 'none' && style.visibility === 'hidden';\n  }\n\n  /**\r\n   * Retrieves the computed style of an HTML element.\r\n   *\r\n   * @param {HTMLElement} element - The HTML element whose computed style is to be retrieved.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {CSSStyleDeclaration | null} - The computed style of the element or null if the element is not provided or is not of the expected type.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'targetElement' is an HTML element.\r\n   * // const computedStyle = ElementExplorer.getComputedStyle(targetElement);\r\n   *\r\n   * @output {CSSStyleDeclaration | null} - The computed style of the element or null if the element is not provided or is not of the expected type.\r\n   *\r\n   * @description\r\n   * This method retrieves the computed style of an HTML element.\r\n   * If the 'element' parameter is not an object, it returns null.\r\n   * If throwOnError is true and 'element' is not of the expected type, it throws an error.\r\n   */\n  static getComputedStyle(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    return window.getComputedStyle(element);\n  }\n\n  /**\r\n   * Checks if the provided object is an HTML element or document.\r\n   *\r\n   * @param {Object} obj - The object to be checked.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - True if the object is an HTML element or document, false otherwise.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'obj' parameter is not an object (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'targetObject' is an object.\r\n   * // const isElement = ElementExplorer.isElement(targetObject);\r\n   *\r\n   * @output {boolean} - True if the object is an HTML element or document, false otherwise.\r\n   *\r\n   * @description\r\n   * This method checks if the provided object is an HTML element or document.\r\n   * If the 'obj' parameter is not an object, it returns false.\r\n   * If throwOnError is true and 'obj' is not of the expected type, it throws an error.\r\n   */\n\n  static isElement(obj, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: obj,\n      throwOnError\n    })) {\n      return throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    return obj instanceof Element || obj instanceof HTMLDocument;\n  }\n\n  /**\r\n   * Checks if the provided element is a child of the specified parent element.\r\n   *\r\n   * @param {HTMLElement} child - The child element to be checked.\r\n   * @param {HTMLElement} parent - The parent element to compare against.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - True if the child is a direct child of the parent, false otherwise.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'child' or 'parent' parameters are not objects (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'childElement' and 'parentElement' are HTML elements.\r\n   * // const isChild = ElementExplorer.isChildOf(childElement, parentElement);\r\n   *\r\n   * @output {boolean} - True if the child is a direct child of the parent, false otherwise.\r\n   *\r\n   * @description\r\n   * This method checks if the provided element is a child of the specified parent element.\r\n   * If the 'child' or 'parent' parameters are not objects, it returns false.\r\n   * If throwOnError is true and 'child' or 'parent' is not of the expected type, it throws an error.\r\n   */\n  static isChildOf(child, parent, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: child,\n      throwOnError\n    }) || !_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: parent,\n      throwOnError\n    })) {\n      return throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    return child.parentElement === parent;\n  }\n\n  /**\r\n   * Checks if the provided element has any child elements.\r\n   *\r\n   * @param {HTMLElement} element - The element to be checked for child elements.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns false.\r\n   *\r\n   * @return {boolean} - True if the element has child elements, false otherwise.\r\n   *\r\n   * @throw {Error} - Throws an error if the 'element' parameter is not an object (when throwOnError is true).\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // Assuming 'parentElement' is an HTML element.\r\n   * // const hasChildren = ElementExplorer.hasChildren(parentElement);\r\n   *\r\n   * @output {boolean} - True if the element has child elements, false otherwise.\r\n   *\r\n   * @description\r\n   * This method checks if the provided element has any child elements.\r\n   * If the 'element' parameter is not an object, it returns false.\r\n   * If throwOnError is true and 'element' is not of the expected type, it throws an error.\r\n   */\n  static hasChildren(element, throwOnError = true) {\n    if (!_validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.isObject({\n      param: element,\n      throwOnError\n    })) {\n      return _validation_validation__WEBPACK_IMPORTED_MODULE_1__.DomValidator.throwOrReturnOnError(throwOnError, \"Invalid parameters.\");\n    }\n    return element.children.length > 0;\n  }\n\n  /**\r\n   * Logs all the available static functions in the ElementExplorer class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // ElementBuilder.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available static functions in the ElementBuilder class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(ElementExplorer).filter(name => typeof ElementExplorer[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    console.log(`Available functions in ElementExplorer class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/dom-utils/ElementExplorer/elementExplorer.js?");

/***/ }),

/***/ "./src/dom-utils/ElementHandler/elementHandler.js":
/*!********************************************************!*\
  !*** ./src/dom-utils/ElementHandler/elementHandler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ElementHandler: () => (/* binding */ ElementHandler)\n/* harmony export */ });\n/* harmony import */ var _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../validation/validation.js */ \"./src/validation/validation.js\");\n/**\r\n * A class for handling DOM elements with utility methods.\r\n */\n\n\n\n/**\r\n * Utility class for handling DOM elements with various methods.\r\n *\r\n * The `ElementHandler` class provides utility methods for interacting with DOM elements,\r\n * including retrieving elements by ID or class, managing classes, updating element attributes, and more.\r\n * It offers a set of actions for class management such as adding, toggling, and removing classes.\r\n * This class aims to simplify common tasks related to DOM manipulation in web development.\r\n *\r\n * @class\r\n */\nclass ElementHandler {\n  /**\r\n   * An object containing possible actions for managing classes.\r\n   * @type {{add: string, toggle: string, remove: string}}\r\n   */\n\n  static ACTIONS = {\n    add: 'add',\n    toggle: 'toggle',\n    remove: 'remove'\n  };\n\n  /**\r\n   * Retrieves an element from the DOM by its ID.\r\n   *\r\n   * @param {string} elementId - The ID of the element to retrieve.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw an error if the element is not found.\r\n   *\r\n   * @returns {HTMLElement|null} The DOM element with the given ID, or null if not found and throwOnError is false.\r\n   *\r\n   * @throws {Error} If the element is not found and throwOnError is true.\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Retrieve an element by its ID\r\n   * const headerElement = ElementHandler.retrieveElementById('header');\r\n   *\r\n   * @output\r\n   * // If element is found, returns the HTMLElement; otherwise, throws an error.\r\n   *\r\n   * @description\r\n   * The `retrieveElementById` function retrieves an element from the DOM by its ID.\r\n   * It takes an optional parameter `throwOnError` to control whether an error is thrown if the element is not found.\r\n   * If the element is found, it returns the corresponding HTMLElement; otherwise, it returns null or throws an error based on the `throwOnError` parameter.\r\n   */\n  static retrieveElementById(elementId, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: elementId,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    const element = document.getElementById(elementId);\n    if (!element && throwOnError) {\n      throw new Error(`Element with id ${elementId} does not exist`);\n    }\n    return element;\n  }\n\n  /**\r\n   * Retrieves elements from the DOM by class name.\r\n   *\r\n   * @param {string} className - The class name to search for.\r\n   * @param {'HTMLCollection'|'array'} [returnType='HTMLCollection'] - The type of object to return.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw an error for invalid parameters.\r\n   *\r\n   * @returns {HTMLCollection | Array} The matching elements as an HTMLCollection or Array.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Retrieve elements by class name\r\n   * const headerElements = ElementHandler.retrieveElementByClass('header');\r\n   *\r\n   * @output\r\n   * // Returns an HTMLCollection or Array of matching elements; throws an error if parameters are invalid and throwOnError is true.\r\n   *\r\n   * @description\r\n   * The `retrieveElementByClass` function retrieves elements from the DOM by their class name.\r\n   * It takes an optional parameter `returnType` to specify the type of object to return (HTMLCollection or Array).\r\n   * The optional parameter `throwOnError` controls whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it returns the matching elements as an HTMLCollection or Array.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static retrieveElementByClass(className, returnType = 'HTMLCollection', throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: className,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.existInArray({\n      param: returnType,\n      throwOnError\n    }, ['array', 'HTMLCollection'], 'HTMLCollection')) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    const elements = document.getElementsByClassName(className);\n    return returnType === 'array' ? Array.from(elements) : elements;\n  }\n\n  /**\r\n   * Retrieve a single DOM element using a CSS selector.\r\n   *\r\n   * @param {string} selector - The CSS selector to use.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {HTMLElement|null} The matching DOM element or null if not found and throwOnError is false.\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * const element = ElementHandler.retreiveByQuery('.example-class');\r\n   * ConsoleLogger.log(element); // Returns the matching DOM element or null if not found.\r\n   *\r\n   * @description\r\n   * The `retreiveByQuery` function retrieves a single DOM element using the provided CSS selector.\r\n   * It returns the matching element or null if not found, depending on the `throwOnError` parameter.\r\n   */\n  static retreiveByQuery(selector, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: selector,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    const element = document.querySelector(selector);\n    if (!element && throwOnError) {\n      throw new Error(`No element found with selector: ${selector}`);\n    }\n    return element;\n  }\n\n  /**\r\n   * Retrieve DOM elements using a CSS selector.\r\n   *\r\n   * @param {string} selector - The CSS selector to use.\r\n   * @param {'NodeList'|'array'} [returnType='NodeList'] - The type of object to return.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {NodeList|Array} The matching DOM elements as a NodeList or Array.\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * const elements = ElementHandler.retreiveAllByQuery('.example-class');\r\n   * ConsoleLogger.log(elements); // Returns the matching DOM elements as a NodeList or Array.\r\n   *\r\n   * @description\r\n   * The `retreiveAllByQuery` function retrieves DOM elements using the provided CSS selector.\r\n   * It returns the matching elements as a NodeList or Array, depending on the `returnType` parameter,\r\n   * or null if not found and throwOnError is false.\r\n   */\n  static retreiveAllByQuery(selector, returnType = 'NodeList', throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: selector,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.existInArray({\n      param: returnType,\n      throwOnError\n    }, ['array', 'NodeList'], 'NodeList')) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    const elements = document.querySelectorAll(selector);\n    if (!elements.length && throwOnError) {\n      throw new Error(`No elements found with selector: ${selector}`);\n    }\n    return returnType === 'array' ? Array.from(elements) : elements;\n  }\n\n  /**\r\n   * Removes the id attribute from a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to remove the id from.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw an error for invalid parameters.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Remove the id attribute from an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * ElementHandler.removeId(myElement);\r\n   *\r\n   * @description\r\n   * The `removeId` function removes the id attribute from a DOM element.\r\n   * It takes an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it removes the id attribute from the specified element.\r\n   * If parameters are invalid, it throws an error or returns early based on the `throwOnError` parameter.\r\n   */\n  static removeId(targetElement, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return;\n      }\n    }\n    targetElement.removeAttribute('id');\n  }\n\n  /**\r\n   * Updates the id of a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to update.\r\n   * @param {string} newId - The new id to set on the element.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw an error for invalid parameters.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Update the id of an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * ElementHandler.updateId(myElement, 'newId');\r\n   *\r\n   * @description\r\n   * The `updateId` function updates the id of a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to update,\r\n   * the `newId` parameter, which is the new id to set on the element,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it updates the id of the specified element.\r\n   * If parameters are invalid, it throws an error or returns early based on the `throwOnError` parameter.\r\n   */\n  static updateId(targetElement, newId, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: newId,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return;\n      }\n    }\n    targetElement.id = newId;\n  }\n\n  /**\r\n   * Removes all classes from a DOM element.\r\n   *\r\n   * @param {HTMLElement} element - The element to remove classes from.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw an error for invalid parameters.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Remove all classes from an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * ElementHandler.removeAllClasses(myElement);\r\n   *\r\n   * @description\r\n   * The `removeAllClasses` function removes all classes from a DOM element.\r\n   * It takes the `element` parameter, which is the element to remove classes from,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it removes all classes from the specified element.\r\n   * If parameters are invalid, it throws an error or returns early based on the `throwOnError` parameter.\r\n   */\n  static removeAllClasses(targetElement, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return;\n      }\n    }\n    targetElement.className = '';\n  }\n\n  /**\r\n   * Removes specific classes from a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to remove classes from.\r\n   * @param {Array<string>} arrayClasses - Array of class names to remove.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Remove specific classes from an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const classesToRemove = ['class1', 'class2'];\r\n   * ElementHandler.removeSpecificClasses(myElement, classesToRemove);\r\n   *\r\n   * @description\r\n   * The `removeClassesByNameList` function removes specific classes from a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to remove classes from,\r\n   * the `arrayClasses` parameter, which is an array of class names to remove,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it removes the specified classes from the element.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static removeClassesByNameList(targetElement, arrayClasses, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArray({\n      param: arrayClasses,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.classList.remove(...arrayClasses);\n  }\n\n  /**\r\n   * Adds a class to a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to add the class to.\r\n   * @param {string} className - The class name to add.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Add a class to an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const newClass = 'newClass';\r\n   * ElementHandler.addClass(myElement, newClass);\r\n   *\r\n   * @description\r\n   * The `addClass` function adds a class to a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to add the class to,\r\n   * the `className` parameter, which is the class name to add,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it adds the specified class to the element.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static addClass(targetElement, className, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: className,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.classList.add(className);\n  }\n\n  /**\r\n   * Toggles a class on a DOM element by adding or removing it.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to toggle the class on.\r\n   * @param {string} className - The class name to toggle.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Toggle a class on an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const toggleClass = 'toggleClass';\r\n   * ElementHandler.toggleClass(myElement, toggleClass);\r\n   *\r\n   * @description\r\n   * The `toggleClass` function toggles a class on a DOM element by adding it if it doesn't exist\r\n   * or removing it if it already exists.\r\n   * It takes the `targetElement` parameter, which is the element to toggle the class on,\r\n   * the `className` parameter, which is the class name to toggle,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it toggles the specified class on the element.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static toggleClass(targetElement, className, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: className,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.classList.toggle(className);\n  }\n\n  /**\r\n   * Checks if a DOM element contains a specific class name.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to check.\r\n   * @param {string} className - The class name to check for.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {boolean|null} Returns true if the element contains the class, false otherwise.\r\n   *                        Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Check if an element has a specific class\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const checkClass = 'checkClass';\r\n   * const hasClass = ElementHandler.hasClass(myElement, checkClass);\r\n   * ConsoleLogger.log(`Element has class ${checkClass}: ${hasClass}`);\r\n   *\r\n   * @description\r\n   * The `hasClass` function checks if a DOM element contains a specific class name.\r\n   * It takes the `targetElement` parameter, which is the element to check,\r\n   * the `className` parameter, which is the class name to check for,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it returns true if the element contains the class and false otherwise.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static hasClass(targetElement, className, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: className,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    return targetElement.classList.contains(className);\n  }\n\n  /**\r\n   * Toggles multiple classes on a DOM element by adding or removing them.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to toggle classes on.\r\n   * @param {Array<string>} arrayClasses - Array of class names to toggle.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Toggle multiple classes on an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const classesToToggle = ['class1', 'class2', 'class3'];\r\n   * ElementHandler.toggleClasses(myElement, classesToToggle);\r\n   *\r\n   * @description\r\n   * The `toggleClasses` function toggles multiple classes on a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to toggle classes on,\r\n   * the `arrayClasses` parameter, which is an array of class names to toggle,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it toggles each class in the array on the element.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static toggleClasses(targetElement, arrayClasses, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArray({\n      param: arrayClasses,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    arrayClasses.forEach(className => {\n      targetElement.classList.toggle(className);\n    });\n  }\n\n  /**\r\n   * Manages classes on a DOM element by adding, removing, or toggling them.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to manage classes on.\r\n   * @param {string} className - The class to manage.\r\n   * @param {'add'|'remove'|'toggle'} action - The action to perform on the class.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   * @throws {Error} If action is invalid.\r\n   *\r\n   * @example\r\n   * // Manage a class on an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const className = 'myClass';\r\n   * ElementHandler.manageClass(myElement, className, 'add');\r\n   *\r\n   * @description\r\n   * The `manageClass` function manages classes on a DOM element by adding, removing, or toggling them.\r\n   * It takes the `targetElement` parameter, which is the element to manage classes on,\r\n   * the `className` parameter, which is the class to manage,\r\n   * the `action` parameter, which is the action to perform on the class ('add', 'remove', or 'toggle'),\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it performs the specified action on the class.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static manageClass(targetElement, className, action = 'add', throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: className,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.existInArray({\n      param: action,\n      throwOnError\n    }, ['add', 'remove', 'toggle'], 'add')) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    switch (action) {\n      case ElementHandler.ACTIONS.add:\n        targetElement.classList.add(className);\n        break;\n      case ElementHandler.ACTIONS.toggle:\n        targetElement.classList.toggle(className);\n        break;\n      case ElementHandler.ACTIONS.remove:\n        targetElement.classList.remove(className);\n        break;\n      default:\n        throw new Error('Invalid action');\n    }\n  }\n\n  /**\r\n   * Replaces one class with another on a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to modify.\r\n   * @param {string} classToRemove - The class to remove.\r\n   * @param {string} classToAdd - The class to add.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Replace a class on an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const classToRemove = 'oldClass';\r\n   * const classToAdd = 'newClass';\r\n   * ElementHandler.replaceClass(myElement, classToRemove, classToAdd);\r\n   *\r\n   * @description\r\n   * The `replaceClass` function replaces one class with another on a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to modify,\r\n   * the `classToRemove` parameter, which is the class to remove,\r\n   * the `classToAdd` parameter, which is the class to add,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it removes the specified class and adds the new class.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static replaceClass(targetElement, classToRemove, classToAdd, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: classToRemove,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: classToAdd,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.classList.remove(classToRemove);\n    targetElement.classList.add(classToAdd);\n  }\n\n  /**\r\n   * Gets the value of a specific attribute on a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to retrieve the attribute from.\r\n   * @param {string} attributeName - The name of the attribute to retrieve.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {string|null} The value of the attribute or null if the attribute is not present.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Get the value of a specific attribute\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const attributeValue = ElementHandler.getAttribute(myElement, 'data-custom');\r\n   * ConsoleLogger.log(`Attribute value: ${attributeValue}`);\r\n   *\r\n   * @description\r\n   * The `getAttribute` function gets the value of a specific attribute on a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to retrieve the attribute from,\r\n   * the `attributeName` parameter, which is the name of the attribute to retrieve,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it returns the value of the attribute or null if the attribute is not present.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static getAttribute(targetElement, attributeName, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: attributeName,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {}\n    }\n    return targetElement.getAttribute(attributeName);\n  }\n\n  /**\r\n   * Sets the value of a specific attribute on a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to update.\r\n   * @param {string} attributeName - The name of the attribute to set.\r\n   * @param {string} attributeValue - The value to set for the attribute.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Set the value of a specific attribute\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * ElementHandler.setAttribute(myElement, 'data-custom', '123');\r\n   *\r\n   * @description\r\n   * The `setAttribute` function sets the value of a specific attribute on a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to update,\r\n   * the `attributeName` parameter, which is the name of the attribute to set,\r\n   * the `attributeValue` parameter, which is the value to set for the attribute,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it sets the value of the specified attribute.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static setAttribute(targetElement, attributeName, attributeValue, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: attributeName,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: attributeValue,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.setAttribute(attributeName, attributeValue);\n  }\n\n  /**\r\n   * Removes a specific attribute from a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to remove the attribute from.\r\n   * @param {string} attributeName - The name of the attribute to remove.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Remove a specific attribute from an element\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * ElementHandler.removeAttribute(myElement, 'data-custom');\r\n   *\r\n   * @description\r\n   * The `removeAttribute` function removes a specific attribute from a DOM element.\r\n   * It takes the `targetElement` parameter, which is the element to remove the attribute from,\r\n   * the `attributeName` parameter, which is the name of the attribute to remove,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it removes the specified attribute.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static removeAttribute(targetElement, attributeName, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: attributeName,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.removeAttribute(attributeName);\n  }\n\n  /**\r\n   * Checks if an element has a specific class name and/or ID.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to check.\r\n   * @param {string} className - The class name to check for.\r\n   * @param {string} id - The ID to check for.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {object|null}\r\n   * Returns an object with the following properties:\r\n   * - hasElement: Whether the target element exists.\r\n   * - hasClass: Whether the element has the specified class.\r\n   * - hasId: Whether the element has the specified ID.\r\n   * Returns null if an error occurs and throwOnError is false.\r\n   *\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Check if an element has a class and an ID\r\n   * const myElement = ElementHandler.retrieveElementById('myElement');\r\n   * const className = 'exampleClass';\r\n   * const id = 'exampleId';\r\n   * const result = ElementHandler.checkAttribute(myElement, className, id);\r\n   * ConsoleLogger.log(result);\r\n   *\r\n   * @description\r\n   * The `checkAttribute` function checks if an element has a specific class name and/or ID.\r\n   * It takes the `targetElement` parameter, which is the element to check,\r\n   * the `className` parameter, which is the class name to check for,\r\n   * the `id` parameter, which is the ID to check for,\r\n   * and an optional parameter `throwOnError` to control whether an error is thrown for invalid parameters.\r\n   * If the parameters are valid, it returns an object indicating whether the element exists, has the specified class, and has the specified ID.\r\n   * If parameters are invalid, it throws an error or returns null based on the `throwOnError` parameter.\r\n   */\n  static checkAttribute(targetElement, className, id, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: className,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: id,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    const hasClass = targetElement.classList.contains(className);\n    const hasId = targetElement.id === id;\n    return {\n      hasElement: true,\n      hasClass: `${className} / ${hasClass}`,\n      hasId: `${id} / ${hasId}`\n    };\n  }\n\n  /**\r\n   * Set the text content of a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to update.\r\n   * @param {string} text - The new text content to set.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if error and throwOnError is false.\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Set text content of an element\r\n   * const element = ElementHandler.retrieveElementById('myElement');\r\n   * ElementHandler.setTextContent(element, 'New Content');\r\n   *\r\n   * @description\r\n   * The `setTextContent` function sets the text content of a given DOM element.\r\n   * It requires the `targetElement` parameter, representing the element to update,\r\n   * the `text` parameter, representing the new text content to set, and an optional\r\n   * `throwOnError` parameter to control error handling.\r\n   */\n  static setTextContent(targetElement, text, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: text,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.textContent = text;\n  }\n\n  /**\r\n   * Set the inner HTML of a DOM element.\r\n   *\r\n   * @param {HTMLElement} targetElement - The element to update.\r\n   * @param {string} html - The new HTML content to set.\r\n   * @param {boolean} [throwOnError=true] - Whether to throw errors for invalid parameters.\r\n   *\r\n   * @returns {void|null} Returns null if error and throwOnError is false.\r\n   * @throws {Error} If parameters are invalid and throwOnError is true.\r\n   *\r\n   * @example\r\n   * // Set inner HTML of an element\r\n   * const element = ElementHandler.retrieveElementById('myElement');\r\n   * ElementHandler.setInnerHTML(element, '<p>New HTML Content</p>');\r\n   *\r\n   * @description\r\n   * The `setInnerHTML` function sets the inner HTML content of a given DOM element.\r\n   * It requires the `targetElement` parameter, representing the element to update,\r\n   * the `html` parameter, representing the new HTML content to set, and an optional\r\n   * `throwOnError` parameter to control error handling.\r\n   */\n  static setInnerHTML(targetElement, html, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: targetElement,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: html,\n      throwOnError\n    })) {\n      if (throwOnError) {\n        throw new Error('Invalid parameters');\n      } else {\n        return null;\n      }\n    }\n    targetElement.innerHTML = html;\n  }\n\n  /**\r\n   * Logs all the available static functions in the ElementHandler class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // ElementBuilder.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available static functions in the ElementBuilder class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(ElementHandler).filter(name => typeof ElementHandler[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    console.log(`Available functions in ElementHandler class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/dom-utils/ElementHandler/elementHandler.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuditLogger: () => (/* reexport safe */ _logger_AuditLogger_auditLogger_js__WEBPACK_IMPORTED_MODULE_6__.AuditLogger),\n/* harmony export */   ConsoleLogger: () => (/* reexport safe */ _logger_consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_1__.ConsoleLogger),\n/* harmony export */   CustomConsoleLogger: () => (/* reexport safe */ _logger_customConsoleLogger_customConsoleLogger_js__WEBPACK_IMPORTED_MODULE_7__.CustomConsoleLogger),\n/* harmony export */   ElementBuilder: () => (/* reexport safe */ _dom_utils_ElementBuilder_elementBuilder_js__WEBPACK_IMPORTED_MODULE_9__.ElementBuilder),\n/* harmony export */   ElementExplorer: () => (/* reexport safe */ _dom_utils_ElementExplorer_elementExplorer_js__WEBPACK_IMPORTED_MODULE_8__.ElementExplorer),\n/* harmony export */   ElementHandler: () => (/* reexport safe */ _dom_utils_ElementHandler_elementHandler_js__WEBPACK_IMPORTED_MODULE_0__.ElementHandler),\n/* harmony export */   EventLogger: () => (/* reexport safe */ _logger_eventLogger_eventLogger_js__WEBPACK_IMPORTED_MODULE_5__.EventLogger),\n/* harmony export */   FileLogger: () => (/* reexport safe */ _logger_fileLogger_fileLogger_js__WEBPACK_IMPORTED_MODULE_2__.FileLogger),\n/* harmony export */   LoggerBase: () => (/* reexport safe */ _logger_base_loggerBase_js__WEBPACK_IMPORTED_MODULE_3__.LoggerBase),\n/* harmony export */   PerformanceLogger: () => (/* reexport safe */ _logger_performanceLogger_performanceLogger_js__WEBPACK_IMPORTED_MODULE_4__.PerformanceLogger),\n/* harmony export */   StorageManager: () => (/* reexport safe */ _storage_Manager_storageManager_js__WEBPACK_IMPORTED_MODULE_10__.StorageManager)\n/* harmony export */ });\n/* harmony import */ var _dom_utils_ElementHandler_elementHandler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/ElementHandler/elementHandler.js */ \"./src/dom-utils/ElementHandler/elementHandler.js\");\n/* harmony import */ var _logger_consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger/consoleLogger/consoleLogger.js */ \"./src/logger/consoleLogger/consoleLogger.js\");\n/* harmony import */ var _logger_fileLogger_fileLogger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logger/fileLogger/fileLogger.js */ \"./src/logger/fileLogger/fileLogger.js\");\n/* harmony import */ var _logger_base_loggerBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger/base/loggerBase.js */ \"./src/logger/base/loggerBase.js\");\n/* harmony import */ var _logger_performanceLogger_performanceLogger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logger/performanceLogger/performanceLogger.js */ \"./src/logger/performanceLogger/performanceLogger.js\");\n/* harmony import */ var _logger_eventLogger_eventLogger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./logger/eventLogger/eventLogger.js */ \"./src/logger/eventLogger/eventLogger.js\");\n/* harmony import */ var _logger_AuditLogger_auditLogger_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./logger/AuditLogger/auditLogger.js */ \"./src/logger/AuditLogger/auditLogger.js\");\n/* harmony import */ var _logger_customConsoleLogger_customConsoleLogger_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./logger/customConsoleLogger/customConsoleLogger.js */ \"./src/logger/customConsoleLogger/customConsoleLogger.js\");\n/* harmony import */ var _dom_utils_ElementExplorer_elementExplorer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/ElementExplorer/elementExplorer.js */ \"./src/dom-utils/ElementExplorer/elementExplorer.js\");\n/* harmony import */ var _dom_utils_ElementBuilder_elementBuilder_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-utils/ElementBuilder/elementBuilder.js */ \"./src/dom-utils/ElementBuilder/elementBuilder.js\");\n/* harmony import */ var _storage_Manager_storageManager_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./storage-Manager/storageManager,.js */ \"./src/storage-Manager/storageManager,.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://js.package/./src/index.js?");

/***/ }),

/***/ "./src/logger/AuditLogger/auditLogger.js":
/*!***********************************************!*\
  !*** ./src/logger/AuditLogger/auditLogger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuditLogger: () => (/* binding */ AuditLogger)\n/* harmony export */ });\n/* harmony import */ var _base_loggerBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/loggerBase.js */ \"./src/logger/base/loggerBase.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-saver */ \"./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../consoleLogger/consoleLogger.js */ \"./src/logger/consoleLogger/consoleLogger.js\");\n\n\n\n\n/**\r\n * Audit logger class for capturing and logging actions for auditing purposes.\r\n * Extends the functionality of the base logger.\r\n *\r\n * @class\r\n * @extends LoggerBase\r\n */\nclass AuditLogger extends _base_loggerBase_js__WEBPACK_IMPORTED_MODULE_0__.LoggerBase {\n  /**\r\n   * Create an AuditLogger instance.\r\n   *\r\n   * @param {string} auditLogPath - The path or destination for storing audit logs.\r\n   * @param {boolean} [logRotation=false] - Whether log rotation is enabled.\r\n   * @param {number} [maxLogs=10] - Maximum number of logs to keep when log rotation is enabled.\r\n   *\r\n   * @returns {AuditLogger} A new instance of the AuditLogger class.\r\n   *\r\n   * @example\r\n   * const auditLogger = new AuditLogger('/path/to/audit/logs', true, 10);\r\n   *\r\n   * @description\r\n   * The constructor initializes a new instance of the `AuditLogger` class, which extends the `LoggerBase` class.\r\n   * It requires an `auditLogPath` parameter, which specifies the path or destination for storing audit logs.\r\n   * The optional parameters `logRotation` and `maxLogs` can be used to enable log rotation and set the maximum number of logs to keep.\r\n   */\n  constructor(auditLogPath, logRotation = false, maxLogs = 10, saveIntoFile = true) {\n    super();\n    this.auditLogPath = auditLogPath;\n    this.logRotation = logRotation;\n    this.maxLogs = maxLogs;\n    this.saveIntoFile = saveIntoFile;\n  }\n\n  /**\r\n   * Log an auditable action.\r\n   *\r\n   * @param {string} action - The auditable action to log.\r\n   * @param {object} metadata - Additional metadata or details related to the auditable action.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const auditLogger = new AuditLogger('/path/to/audit/logs', true, 10);\r\n   * auditLogger.logAuditAction('User login', { username: 'john_doe', ipAddress: '192.168.1.100' });\r\n   *\r\n   * @output\r\n   * // If logToFileSystem is true:\r\n   * // Storing audit log at /path/to/audit/logs: 2022-01-09T12:00:00.000Z - User login - {\"username\":\"john_doe\",\"ipAddress\":\"192.168.1.100\"}\r\n   *\r\n   * // If logToFileSystem is false:\r\n   * // 2022-01-09T12:00:00.000Z - User login - {\"username\":\"john_doe\",\"ipAddress\":\"192.168.1.100\"}\r\n   *\r\n   * @description\r\n   * The `logAuditAction` function logs an auditable action along with additional metadata.\r\n   * It captures actions for compliance and accountability.\r\n   * The log can be saved to the file system or logged to the console based on the configuration.\r\n   */\n  logAuditAction(action, metadata) {\n    const timestamp = new Date().toISOString();\n    const log = `${timestamp} - ${action} - ${JSON.stringify(metadata)}`;\n    if (this.saveIntoFile) {\n      this.logToFileSystem(log);\n    } else {\n      _consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_2__.ConsoleLogger.log(log);\n    }\n  }\n\n  /**\r\n   * Save a log entry to the file system.\r\n   *\r\n   * @param {string} log - The log entry to be saved.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const auditLogger = new AuditLogger('/path/to/audit/logs', true, 10);\r\n   * auditLogger.logToFileSystem('2022-01-09T12:00:00.000Z - User login - {\"username\":\"john_doe\",\"ipAddress\":\"192.168.1.100\"}');\r\n   *\r\n   * @description\r\n   * The `logToFileSystem` function saves a log entry to the file system using the 'file-saver' library.\r\n   * It creates a Blob from the log entry and triggers the download using the `saveAs` function.\r\n   * If log rotation is enabled, it checks and rotates logs if needed based on the configured maximum logs.\r\n   */\n  logToFileSystem(log) {\n    const blob = new Blob([`${log}\\n`], {\n      type: 'text/plain;charset=utf-8'\n    });\n    (0,file_saver__WEBPACK_IMPORTED_MODULE_1__.saveAs)(blob, this.auditLogPath, {\n      autoBom: true\n    });\n    if (this.logRotation) {\n      this.rotateLogsIfNeeded();\n    }\n  }\n\n  /**\r\n   * Rotate logs if the number of logs exceeds the maximum allowed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * Automatically called when log rotation is enabled and the maximum logs are exceeded.\r\n   * auditLogger.rotateLogsIfNeeded();\r\n   *\r\n   * @description\r\n   * The `rotateLogsIfNeeded` function checks if the number of logs exceeds the maximum allowed.\r\n   * If the condition is met, it removes old logs beyond the maximum allowed to control log storage size.\r\n   */\n  rotateLogsIfNeeded() {\n    if (this.logs.length > this.maxLogs) {\n      this.logs.splice(0, this.logs.length - this.maxLogs);\n    }\n  }\n\n  /**\r\n   * Log a security incident.\r\n   *\r\n   * @param {string} action - The description of the security incident.\r\n   * @param {object} metadata - Additional metadata or details related to the security incident.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * auditLogger.logSecurityIncident('Unauthorized access attempt', { ipAddress: '192.168.1.100' });\r\n   *\r\n   * @output\r\n   * Depending on the configuration:\r\n   * - If saving to the file system, the security incident log is stored at the specified path.\r\n   * - If logging to the console, the security incident log is displayed in the console.\r\n   *\r\n   * @description\r\n   * The `logSecurityIncident` function logs a security incident along with additional metadata.\r\n   * It captures security-related events or suspicious activities in an application.\r\n   * The log can be saved to the file system or logged to the console based on the configuration.\r\n   */\n  logSecurityIncident(action, metadata) {\n    const timestamp = new Date().toISOString();\n    const log = `${timestamp} - SECURITY INCIDENT - ${action} - ${JSON.stringify(metadata)}`;\n    if (this.saveIntoFile) {\n      this.logToFileSystem(log);\n    } else {\n      _consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_2__.ConsoleLogger.log(log);\n    }\n  }\n\n  /**\r\n   * Log user activity.\r\n   *\r\n   * @param {string} username - The username associated with the user activity.\r\n   * @param {string} activity - The description of the user activity.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * auditLogger.logUserActivity('john_doe', 'Viewed profile page');\r\n   *\r\n   * @output\r\n   * Depending on the configuration:\r\n   * - If saving to the file system, the user activity log is stored at the specified path.\r\n   * - If logging to the console, the user activity log is displayed in the console.\r\n   *\r\n   * @description\r\n   * The `logUserActivity` function logs user activity along with the associated username and activity description.\r\n   * It captures actions performed by users in the application.\r\n   * The log can be saved to the file system or logged to the console based on the configuration.\r\n   */\n  logUserActivity(username, activity) {\n    const timestamp = new Date().toISOString();\n    const log = `${timestamp} - USER ACTIVITY - ${username} - ${activity}`;\n    if (this.saveIntoFile) {\n      this.logToFileSystem(log);\n    } else {\n      _consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_2__.ConsoleLogger.log(log);\n    }\n  }\n\n  /**\r\n   * Log a system error.\r\n   *\r\n   * @param {string} errorMessage - The error message associated with the system error.\r\n   * @param {string} stackTrace - The stack trace related to the system error.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * auditLogger.logSystemError('Critical issue', 'Error in file.js at line 42');\r\n   *\r\n   * @output\r\n   * Depending on the configuration:\r\n   * - If saving to the file system, the system error log is stored at the specified path.\r\n   * - If logging to the console, the system error log is displayed in the console as an error message.\r\n   *\r\n   * @description\r\n   * The `logSystemError` function logs a system error along with the associated error message and stack trace.\r\n   * It is used to capture critical issues or errors in the application.\r\n   * The log can be saved to the file system or logged to the console based on the configuration.\r\n   */\n  logSystemError(errorMessage, stackTrace) {\n    const timestamp = new Date().toISOString();\n    const log = `${timestamp} - SYSTEM ERROR - ${errorMessage}\\n${stackTrace}`;\n    if (this.saveIntoFile) {\n      this.logToFileSystem(log);\n    } else {\n      console.error(log);\n    }\n  }\n\n  /**\r\n   * Log a data access event.\r\n   *\r\n   * @param {string} entity - The entity or data being accessed.\r\n   * @param {string} action - The action or operation performed on the data (e.g., read, write).\r\n   * @param {string} user - The user responsible for the data access event.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * auditLogger.logDataAccessEvent('Customer', 'Read', 'john_doe');\r\n   *\r\n   * @output\r\n   * Depending on the configuration:\r\n   * - If saving to the file system, the data access event log is stored at the specified path.\r\n   * - If logging to the console, the data access event log is displayed in the console.\r\n   *\r\n   * @description\r\n   * The `logDataAccessEvent` function logs a data access event, capturing details such as the entity, action, and user.\r\n   * It is used for auditing and tracking data access activities in the application.\r\n   * The log can be saved to the file system or logged to the console based on the configuration.\r\n   */\n  logDataAccessEvent(entity, action, user) {\n    const timestamp = new Date().toISOString();\n    const log = `${timestamp} - DATA ACCESS - ${action} on ${entity} by ${user}`;\n    if (this.saveIntoFile) {\n      this.logToFileSystem(log);\n    } else {\n      _consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_2__.ConsoleLogger.log(log);\n    }\n  }\n\n  /**\r\n   * Log an authorization event.\r\n   *\r\n   * @param {string} user - The user for whom the authorization event is logged.\r\n   * @param {string} resource - The resource or feature being accessed.\r\n   * @param {boolean} success - A boolean indicating whether the access was granted (true) or denied (false).\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * auditLogger.logAuthorizationEvent('john_doe', 'Admin Panel', true);\r\n   *\r\n   * @output\r\n   * Depending on the configuration:\r\n   * - If saving to the file system, the authorization event log is stored at the specified path.\r\n   * - If logging to the console, the authorization event log is displayed in the console.\r\n   *\r\n   * @description\r\n   * The `logAuthorizationEvent` function logs an authorization event, capturing details such as the user, resource, and access status.\r\n   * It is used for auditing and tracking authorization activities in the application.\r\n   * The log can be saved to the file system or logged to the console based on the configuration.\r\n   */\n  logAuthorizationEvent(user, resource, success) {\n    const timestamp = new Date().toISOString();\n    const status = success ? 'GRANTED' : 'DENIED';\n    const log = `${timestamp} - AUTHORIZATION - ${status} access to ${resource} for user: ${user}`;\n    if (this.saveIntoFile) {\n      this.logToFileSystem(log);\n    } else {\n      _consoleLogger_consoleLogger_js__WEBPACK_IMPORTED_MODULE_2__.ConsoleLogger.log(log);\n    }\n  }\n\n  /**\r\n   * Logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // AuditLogger.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(AuditLogger).filter(name => typeof AuditLogger[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    const nonStaticFunctionNames = Object.getOwnPropertyNames(AuditLogger.prototype).filter(name => typeof AuditLogger.prototype[name] === 'function' && name !== 'constructor');\n    console.log(\"*************************************************\");\n    console.log(`Available static functions in AuditLogger class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n    console.log(\"*************************************************\");\n    console.log(\"\");\n    console.log(`\\nAvailable non-static functions in AuditLogger class:`);\n    nonStaticFunctionNames.forEach(name => console.log(`- ${name}`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/logger/AuditLogger/auditLogger.js?");

/***/ }),

/***/ "./src/logger/base/loggerBase.js":
/*!***************************************!*\
  !*** ./src/logger/base/loggerBase.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LOG_LEVELS: () => (/* binding */ LOG_LEVELS),\n/* harmony export */   LoggerBase: () => (/* binding */ LoggerBase)\n/* harmony export */ });\n/* harmony import */ var _validator_validation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../validator/validation.js */ \"./src/logger/validator/validation.js\");\n/**\r\n * Import the LoggerValidation module from \"../validator/validation.\".\r\n * This module is used to validate log levels and log messages.\r\n * @type {Object}\r\n */\n\n\n/**\r\n* Enum representing the available log levels.\r\n* @readonly\r\n* @enum {string}\r\n*/\nconst LOG_LEVELS = {\n  DEBUG: 'DEBUG',\n  INFO: 'INFO',\n  WARN: 'WARN'\n};\n\n/**\r\n * Validator instance for validating file names and log levels.\r\n * @type {VALIDATE_LOGGER}\r\n */\nconst validator = new _validator_validation_js__WEBPACK_IMPORTED_MODULE_0__.LoggerValidation();\n\n/**\r\n * Base logger class for writing log messages to custom targets.\r\n * Provides methods for setting log levels, formatting messages, \r\n * and storing logs for retrieval.\r\n * \r\n * @class\r\n */\nclass LoggerBase {\n  /**\r\n   * Create a LoggerBase instance.\r\n   *\r\n   * @param {('DEBUG'|'INFO'|'WARN')} [level=LOG_LEVELS.INFO] - Initial log level.\r\n   * The log level determines the severity of the log messages that will be\r\n   * logged. The available log levels are 'DEBUG', 'INFO', and 'WARN'.\r\n   * If no level is provided, the default log level is 'INFO'.\r\n   */\n  constructor(level = LOG_LEVELS.INFO) {\n    // Validate the log level.\n    validator._validateLogLevel({\n      level\n    });\n    this.level = level;\n\n    // Initialize the logs array.\n    /**\r\n     * @type {Array<Object>}\r\n     * @private\r\n     */\n    this.logs = [];\n  }\n\n  /**\r\n   * Set the log level for the logger.\r\n   *\r\n   * @param {('INFO'|'DEBUG'|'WARN')} level - The desired log level.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * LoggerBase.setLogLevel('DEBUG'); // Sets the log level to 'DEBUG'\r\n   * LoggerBase.setLogLevel('INFO');  // Sets the log level to 'INFO'\r\n   * LoggerBase.setLogLevel('WARN');  // Sets the log level to 'WARN'\r\n   *\r\n   * @output\r\n   * // No output in the console. Updates the log level for subsequent log entries.\r\n   *\r\n   * @description\r\n   * The `setLogLevel` function allows the user to set the log level for the logger.\r\n   * It takes a `level` parameter representing the desired log level and validates it using the `validateLogLevel` method.\r\n   * The function then updates the log level property of the logger, affecting the severity of subsequent log entries.\r\n   */\n  setLogLevel(level) {\n    validator._validateLogLevel({\n      level\n    });\n    this.level = level;\n  }\n\n  /**\r\n   * Get the log level from a log message.\r\n   *\r\n   * @param {string} logMessage - The log message from which to extract the log level.\r\n   *\r\n   * @returns {('INFO'|'DEBUG'|'WARN')} The log level extracted from the log message.\r\n   *\r\n   * @example\r\n   * const logMessage = 'INFO - This is an informational log message.';\r\n   * const level = LoggerBase.getLogLevel(logMessage); // Returns 'INFO'\r\n   *\r\n   * @output\r\n   * // No output in the console. Returns the log level extracted from the log message.\r\n   *\r\n   * @description\r\n   * The `getLogLevel` function extracts the log level from a given log message.\r\n   * It takes a `logMessage` parameter, typically in the format 'LOG_LEVEL - Log message content'.\r\n   * The function splits the log message using the separator ' - ' and extracts the first part, which represents the log level.\r\n   * The extracted log level is then returned, mapping it to the predefined log levels using the `LOG_LEVELS` object.\r\n   */\n  getLogLevel(logMessage) {\n    const parts = logMessage.split(' - ');\n    const logLevel = parts[0];\n    return LOG_LEVELS[logLevel];\n  }\n\n  /**\r\n   * Format a log message with its log level.\r\n   *\r\n   * @param {string} msg - The log message content.\r\n   * @param {('INFO'|'DEBUG'|'WARN')} level - The log level associated with the log message.\r\n   *\r\n   * @returns {string} The formatted log message with its log level.\r\n   *\r\n   * @example\r\n   * const message = 'This is a log message.';\r\n   * const logLevel = 'INFO';\r\n   * const formattedMessage = LoggerBase.format(message, logLevel); // Returns '[INFO] - This is a log message.'\r\n   *\r\n   * @output\r\n   * // No output in the console. Returns the formatted log message with its log level.\r\n   *\r\n   * @description\r\n   * The `format` function takes a log message content (`msg`) and its associated log level (`level`).\r\n   * It returns a formatted log message with the log level enclosed in square brackets, followed by a hyphen and the log message content.\r\n   * This function is useful for creating standardized log entries with consistent formatting.\r\n   */\n  format(msg, level) {\n    return `[${level}] - ${msg}`;\n  }\n\n  /**\r\n   * Check if a given log level is valid.\r\n   *\r\n   * @param {string} level - The log level to check for validity.\r\n   *\r\n   * @returns {boolean} `true` if the log level is valid, `false` otherwise.\r\n   *\r\n   * @example\r\n   * const logLevel = 'INFO';\r\n   * const isValid = LoggerBase.isValidLogLevel(logLevel); // Returns true\r\n   *\r\n   * @output\r\n   * // No output in the console. Returns a boolean indicating whether the log level is valid.\r\n   *\r\n   * @description\r\n   * The `isValidLogLevel` function checks whether a given log level is valid.\r\n   * It compares the provided log level with the valid log levels defined in the `LOG_LEVELS` object.\r\n   * If the log level is found in the valid log levels, the function returns `true`; otherwise, it returns `false`.\r\n   * This function is useful for ensuring that only valid log levels are used in the application.\r\n   */\n  isValidLogLevel(level) {\n    return Object.values(LOG_LEVELS).includes(level);\n  }\n\n  /**\r\n   * Add a log entry with the specified message and log level.\r\n   *\r\n   * @param {string} message - The log message to be added.\r\n   * @param {string} [level=LOG_LEVELS.INFO] - The log level associated with the message.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * const logMessage = 'This is an info message.';\r\n   * const logLevel = 'INFO';\r\n   * LoggerBase.addLog(logMessage, logLevel);\r\n   *\r\n   * @output\r\n   * // No output in the console. Adds the log entry to the logs array.\r\n   *\r\n   * @description\r\n   * The `addLog` function adds a log entry to the logger instance.\r\n   * It takes two parameters: `message`, which is the log message, and `level`, which is the log level associated with the message.\r\n   * If no log level is provided, it defaults to 'INFO'.\r\n   * The function validates the log level and log message using the `validator` instance.\r\n   * It constructs the final log message by combining the log level, timestamp, and message.\r\n   * The log entry is then added to the `logs` array, but only if its log level is equal to or higher than the logger's current log level.\r\n   */\n  addLog(message, level = LOG_LEVELS.INFO) {\n    validator._validateLogLevel({\n      level\n    });\n    validator._validateLogMessage({\n      message\n    });\n    const timestamp = new Date().toISOString();\n    const levelIndex = Object.keys(LOG_LEVELS).indexOf(level.toString());\n    const levelConstructorIndex = Object.keys(LOG_LEVELS).indexOf(this.level.toString());\n    if (levelIndex < levelConstructorIndex) {\n      return;\n    }\n    let finalMessage = `${level} - ${timestamp} - ${message}`;\n    this.logs.push(finalMessage);\n  }\n\n  /**\r\n   * Get the array of log entries.\r\n   *\r\n   * @returns {Array<string>} - An array containing log entries.\r\n   *\r\n   * @example\r\n   * const logs = LoggerBase.getLogs();\r\n   * console.log(logs);\r\n   *\r\n   * @output\r\n   * // Output will be an array of log entries.\r\n   *\r\n   * @description\r\n   * The `getLogs` function returns the array of log entries stored in the logger instance.\r\n   * You can use this function to retrieve and inspect the log entries without modifying the logger state.\r\n   */\n  getLogs() {\n    return this.logs;\n  }\n\n  /**\r\n   * Clear all log entries.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * LoggerBase.clearLogs();\r\n   *\r\n   * @output\r\n   * // The logs array is cleared.\r\n   *\r\n   * @description\r\n   * The `clearLogs` function empties the array of log entries in the logger instance.\r\n   * After calling this function, the logger will have no log entries.\r\n   */\n  clearLogs() {\n    this.logs = [];\n  }\n\n  /**\r\n   * Print all log entries to the console.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * LoggerBase.printLogs();\r\n   *\r\n   * @output\r\n   * // Log entries are printed to the console.\r\n   *\r\n   * @description\r\n   * The `printLogs` function iterates through all log entries in the logger instance and prints each entry to the console.\r\n   * Each log entry is printed on a new line.\r\n   */\n  printLogs() {\n    this.logs.forEach(log => {\n      console.log(`${log}`);\n    });\n  }\n\n  /**\r\n   * Logs all the available functions (static and non-static) in the LoggerBase class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  LoggerBase.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(LoggerBase).filter(name => typeof LoggerBase[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    const nonStaticFunctionNames = Object.getOwnPropertyNames(LoggerBase.prototype).filter(name => typeof LoggerBase.prototype[name] === 'function' && name !== 'constructor');\n    console.log(\"*************************************************\");\n    console.log(`Available static functions in LoggerBase class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n    console.log(\"*************************************************\");\n    console.log(\"\");\n    console.log(`\\nAvailable non-static functions in LoggerBase class:`);\n    nonStaticFunctionNames.forEach(name => console.log(`- ${name}`));\n  }\n}\n\n// Export the LoggerBase and LOG_LEVELS modules.\n\n\n\n//# sourceURL=webpack://js.package/./src/logger/base/loggerBase.js?");

/***/ }),

/***/ "./src/logger/consoleLogger/consoleLogger.js":
/*!***************************************************!*\
  !*** ./src/logger/consoleLogger/consoleLogger.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsoleLogger: () => (/* binding */ ConsoleLogger)\n/* harmony export */ });\n/* harmony import */ var _base_loggerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/loggerBase */ \"./src/logger/base/loggerBase.js\");\n\n\n/**\r\n * ConsoleLogger extends the functionality of the base, providing a versatile solution\r\n * for messages, data,, errors, and to the browser console. inherits from the Logger\r\n * class, building upon its core features while adding specific methods tailored for console logging.\r\n *\r\n * @class ConsoleLogger\r\n * @extends LoggerBase\r\n */\n\nclass ConsoleLogger extends _base_loggerBase__WEBPACK_IMPORTED_MODULE_0__.LoggerBase {\n  /**\r\n   * Constructor for the ConsoleLogger class. It initializes the logger instance and a counts object\r\n   * to keep track of the number of times specific labels have been logged.\r\n   *\r\n   * @constructor\r\n   */\n  constructor() {\n    super();\n    this.counts = {};\n  }\n\n  /**\r\n   * Log a message to the console\r\n   *\r\n   * @param {string} message - The message to log to the console.\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.log('Hello, world!');\r\n   *\r\n   * @output\r\n   * Hello, world!\r\n   *\r\n   * @description\r\n   * The `log` method logs a message to the console.\r\n   * It takes one parameter: `message`, which is the message to log to the console.\r\n   * It uses the `console.log` method to log the message to the console.\r\n   */\n  static log(message) {\n    console.log(message);\n  }\n\n  /**\r\n   * Logs tabular data by printing array of objects. \r\n   * Converts objects into table format for readability.\r\n   *\r\n   * @param {Array<Object>} data - The data to display in the table.\r\n   * \r\n   * @returns {void}\r\n   * \r\n   * @example\r\n   * ConsoleLogger.logTable([\r\n   *  { name: 'John', age: 30 },\r\n   *  { name: 'Jane', age: 25 }\r\n   * ]);\r\n   * // Output:\r\n   * // \r\n   * //  name   age    (idx) \r\n   * // \r\n   * //  John   30     0     \r\n   * // \r\n   * //  Jane   25     1     \r\n   * // \r\n   * \r\n   * @description\r\n   * The `logTable` method logs a table to the console.\r\n   * It takes one parameter: `data`, which is an array of objects to display in the table.\r\n   * It uses the `console.table` method to log the table to the console.\r\n   * Each object in the array should have the same keys, which will be used as the column headers in the table.\r\n  */\n  static logTable(data) {\n    console.table(data);\n  }\n\n  /**\r\n   * Start a new console group with a label\r\n   *\r\n   * @param {string} label - The label for the console group.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.logGroup('My Group');\r\n   * ConsoleLogger.log('Message 1');\r\n   * ConsoleLogger.log('Message 2');\r\n   * ConsoleLogger.logEndGroup();\r\n   *\r\n   * @output\r\n   * -My Group:\r\n   *   Message 1\r\n   *   Message 2\r\n   * End Group My Group\r\n   *\r\n   * @description\r\n   * The `logGroup` method starts a new console group with a label.\r\n   * It takes one parameter: `label`, which is the label for the console group.\r\n   * It uses the `console.group` method to start the console group with the specified label.\r\n   * All subsequent log messages will be indented and grouped under the label until the `logEndGroup` method is called.\r\n   */\n  static logGroup(label) {\n    console.group(label);\n  }\n\n  /**\r\n   * Log a warning message to the\r\n   *\r\n   * @param {string} msg - The warning message to log to the console.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.logWarning('Warning: Operation may fail if not executed in a secure environment.');\r\n   *\r\n   * @output\r\n   * Warning: Operation may fail if not executed in a secure environment.\r\n   *\r\n   * @description\r\n   * The `logWarning` method logs a warning message to the console.\r\n   * It takes one parameter: `msg`, which is the warning message to log to the console.\r\n   * It uses the `console.warn` method to log the message to the console.\r\n   */\n  static logWarning(msg) {\n    console.warn(msg);\n  }\n\n  /**\r\n   * Log an error message to the\r\n   *\r\n   * @param {Error|string} err - The error message or Error object to log to the console.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * try {\r\n   *   // some code that may throw an error\r\n   * } catch (err) {\r\n   *   ConsoleLogger.logError(err);\r\n   * }\r\n   *\r\n   * @output\r\n   * Error: An error occurred\r\n   *     at Object.<anonymous> (/path/to/file.js:10:13)\r\n   *     at Module._compile (internal/modules/cjs/loader.js:1063:30)\r\n   *     at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)\r\n   *     at Module.load (internal/modules/cjs/loader.js:928:32)\r\n   *     at Function.Module._load (internal/modules/cjs/loader.js:769:14)\r\n   *     at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\r\n   *     at internal/main/run_main_module.js:17:47\r\n   *\r\n   * @description\r\n   * The `logError` method logs an error message to the console.\r\n   * It takes one parameter: `err`, which can be either a string or an Error object.\r\n   * If `err` is an Error object, the method will log the error message, stack trace, and any additional properties of the Error object.\r\n   * If `err` is a string, the method will log the string as an error message.\r\n   * It uses the `console.error` method to log the message to the console.\r\n   */\n  static logError(err) {\n    console.error(err);\n  }\n\n  /**\r\n  * Start a new performance timing with a label\r\n  *\r\n  * @param {string} label - The label for the performance timing.\r\n  *\r\n  * @returns {void}\r\n  *\r\n  * @example\r\n  * ConsoleLogger.timeStamp('My Timing');\r\n  * // some code that takes time to execute\r\n  * ConsoleLogger.timeEnd('My Timing');\r\n  *\r\n  * @output\r\n  * My Timing: 123.456ms\r\n  *\r\n  * @description\r\n  * The `timeStamp` method starts a new performance timing with a label.\r\n  * It takes one parameter: `label`, which is the label for the performance timing.\r\n  * It uses the `console.time` method to start the performance timing with the specified label.\r\n  * You can then use the `timeEnd` method to stop the timing and log the elapsed time.\r\n  */\n  static timeStamp(label) {\n    console.time(label);\n  }\n\n  /**\r\n   * Stop a performance timing with a label and log the elapsed time\r\n   *\r\n   * @param {string} label - The label for the performance timing.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.timeStamp('My Timing');\r\n   * // some code that takes time to execute\r\n   * ConsoleLogger.timeEnd('My Timing');\r\n   *\r\n   * @output\r\n   * My Timing: 123.456ms\r\n   *\r\n   * @description\r\n   * The `timeEnd` method stops a performance timing with a label and logs the elapsed time.\r\n   * It takes one parameter: `label`, which is the label for the performance timing.\r\n   * It uses the `console.timeEnd` method to stop the performance timing with the specified label and log the elapsed time.\r\n   * You must call `timeStamp` with the same label before calling `timeEnd`.\r\n   */\n  static timeEnd(label) {\n    console.timeEnd(label);\n  }\n\n  /**\r\n   * Log an error stack trace to the console\r\n   *\r\n   * @param {Error} error - The error object to log the stack trace for.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * try {\r\n   *   // some code that may throw an error\r\n   * } catch (error) {\r\n   *   ConsoleLogger.trace(error);\r\n   * }\r\n   *\r\n   * @output\r\n   * Error: An error occurred\r\n   *     at Object.<anonymous> (/path/to/file.js:10:13)\r\n   *     at Module._compile (internal/modules/cjs/loader.js:1063:30)\r\n   *     at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)\r\n   *     at Module.load (internal/modules/cjs/loader.js:928:32)\r\n   *     at Function.Module._load (internal/modules/cjs/loader.js:769:14)\r\n   *     at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\r\n   *     at internal/main/run_main_module.js:17:47\r\n   *\r\n   * @description\r\n   * The `trace` method logs an error stack trace to the console.\r\n   * It takes one parameter: `error`, which is the error object to log the stack trace for.\r\n   * It uses the `console.trace` method to log the stack trace of the error object.\r\n   */\n  static trace(error) {\n    console.trace(error);\n  }\n\n  /**\r\n   * Clear the console\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.clear();\r\n   *\r\n   * @description\r\n   * The `clear` method clears the console.\r\n   * It does not take any parameters.\r\n   * It uses the `console.clear` method to clear the console.\r\n   */\n  static clear() {\n    console.clear();\n  }\n\n  /**\r\n   * Start a new console group with a label, collapsed by default\r\n   *\r\n   * @param {string} label - The label for the console group.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.groupCollapsed('My Group');\r\n   * ConsoleLogger.log('Message 1');\r\n   * ConsoleLogger.log('Message 2');\r\n   * ConsoleLogger.groupEnd();\r\n   *\r\n   * @output\r\n   * My Group (collapsed)\r\n   *   Message 1\r\n   *   Message 2\r\n   * End Group My Group\r\n   *\r\n   * @description\r\n   * The `groupCollapsed` method starts a new console group with a label, collapsed by default.\r\n   * It takes one parameter: `label`, which is the label for the console group.\r\n   * It uses the `console.groupCollapsed` method to start the console group with the specified label, collapsed by default.\r\n   * You can then use the `log` method to log messages to the console group, and the `groupEnd` method to end the console group.\r\n   */\n  static groupCollapsed(label) {\n    console.groupCollapsed(label);\n  }\n\n  /**\r\n   * End a console group\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.groupCollapsed('My Group');\r\n   * ConsoleLogger.log('Message 1');\r\n   * ConsoleLogger.log('Message 2');\r\n   * ConsoleLogger.groupEnd();\r\n   *\r\n   * @output\r\n   * My Group (collapsed)\r\n   *   Message 1\r\n   *   Message 2\r\n   * End Group My Group\r\n   *\r\n   * @description\r\n   * The `groupEnd` method ends a console group.\r\n   * It does not take any parameters.\r\n   * It uses the `console.groupEnd` method to end the console group.\r\n   */\n  static groupEnd() {\n    console.groupEnd();\n  }\n\n  /**\r\n   * Log a styled message to the console\r\n   *\r\n   * @param {string} message - The message to log to the console.\r\n   * @param {string} style - The CSS style to apply to the message.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.logStyled('Hello, world!', 'color: red; font-weight: bold;');\r\n   *\r\n   * @output\r\n   * Hello, world!\r\n   *\r\n   * @description\r\n   * The `logStyled` method logs a styled message to the console.\r\n   * It takes two parameters: `message`, which is the message to log to the console, and `style`, which is the CSS style to apply to the message.\r\n   * It uses the `console.log` method to log the styled message to the console.\r\n   */\n  static logStyled(message, style) {\n    console.log(`%c${message}`, style);\n  }\n\n  /**\r\n   * Count the number of times a label has been called and log the result\r\n   *\r\n   * @param {string} label - The label to count.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * logger.count('My Label');\r\n   * logger.count('My Label');\r\n   * logger.count('My Label');\r\n   *\r\n   * @output\r\n   * My Label: 3\r\n   *\r\n   * @description\r\n   * The `count` method counts the number of times a label has been called and logs the result.\r\n   * It takes one parameter: `label`, which is the label to count.\r\n   * It uses an internal `counts` object to keep track of the number of times each label has been called.\r\n   * It then logs the label and the current count to the console.\r\n   */\n  count(label) {\n    if (!this.counts[label]) {\n      this.counts[label] = 0;\n    }\n    this.counts[label]++;\n    this.log(`${label}: ${this.counts[label]}`);\n  }\n\n  /**\r\n   * Assert that a condition is true and log an error if it is not\r\n   *\r\n   * @param {boolean} condition - The condition to assert.\r\n   * @param {string} message - The error message to log if the condition is not true.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.assert(array.length > 0, 'Array is empty');\r\n   *\r\n   * @output\r\n   * Error: Array is empty\r\n   *     at Object.<anonymous> (/path/to/file.js:10:13)\r\n   *     at Module._compile (internal/modules/cjs/loader.js:1063:30)\r\n   *     at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10)\r\n   *     at Module.load (internal/modules/cjs/loader.js:928:32)\r\n   *     at Function.Module._load (internal/modules/cjs/loader.js:769:14)\r\n   *     at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)\r\n   *     at internal/main/run_main_module.js:17:47\r\n   *\r\n   * @description\r\n   * The `assert` method asserts that a condition is true and logs an error if it is not.\r\n   * It takes two parameters: `condition`, which is the condition to assert, and `message`, which is the error message to log if the condition is not true.\r\n   * It uses the `console.error` method to log the error message if the condition is not true.\r\n   */\n  static assert(condition, message) {\n    if (!condition) {\n      this.logError(new Error(message));\n    }\n  }\n\n  /**\r\n   * Log an object in a tree format to the console\r\n   *\r\n   * @param {Object} obj - The object to log to the console.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.dir({ a: 1, b: { c: 3, d: [4, 5] } });\r\n   *\r\n   * @output\r\n   * { a: 1, b: { c: 3, d: [ 4, 5 ] } }\r\n   *\r\n   * @description\r\n   * The `dir` method logs an object in a tree format to the console.\r\n   * It takes one parameter: `obj`, which is the object to log to the console.\r\n   * It uses the `console.dir` method to log the object in a tree format to the console.\r\n   */\n  static dir(obj) {\n    console.dir(obj);\n  }\n\n  /**\r\n   * Logs all the available functions (static and non-static) in the ConsoleLogger class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  ConsoleLogger.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(ConsoleLogger).filter(name => typeof ConsoleLogger[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    const nonStaticFunctionNames = Object.getOwnPropertyNames(ConsoleLogger.prototype).filter(name => typeof ConsoleLogger.prototype[name] === 'function' && name !== 'constructor');\n    console.log(\"*************************************************\");\n    console.log(`Available static functions in ConsoleLogger class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n    console.log(\"*************************************************\");\n    console.log(\"\");\n    console.log(`\\nAvailable non-static functions in ConsoleLogger class:`);\n    nonStaticFunctionNames.forEach(name => console.log(`- ${name}()`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/logger/consoleLogger/consoleLogger.js?");

/***/ }),

/***/ "./src/logger/customConsoleLogger/customConsoleLogger.js":
/*!***************************************************************!*\
  !*** ./src/logger/customConsoleLogger/customConsoleLogger.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomConsoleLogger: () => (/* binding */ CustomConsoleLogger)\n/* harmony export */ });\n/**\r\n * Console color logger class for printing log messages to the console with different colors based on log levels.\r\n *\r\n * @class\r\n */\nclass CustomConsoleLogger {\n  /**\r\n   * Log a message with color to the console.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   * @param {string} color - The color code for the log message.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @description\r\n   * The `log` function prints a log message to the console with the specified color.\r\n   * It can be used to visually distinguish log levels based on different colors.\r\n   * The color parameter should be a valid CSS color code.\r\n   */\n  static log(message, color) {\n    console.log(`%c${message}`, `color: ${color}`);\n  }\n\n  /**\r\n   * Log a debug message with a specific color.\r\n   *\r\n   * @param {string} message - The debug message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.debug('This is a debug message');\r\n   *\r\n   * @description\r\n   * The `debug` function logs a debug message with a specific color to the console.\r\n   * It provides a visual distinction for debug-level logs.\r\n   */\n  static debug(message) {\n    ConsoleColorLogger.log(message, 'blue');\n  }\n\n  /**\r\n   * Log an info message with a specific color.\r\n   *\r\n   * @param {string} message - The info message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.info('This is an info message');\r\n   *\r\n   * @description\r\n   * The `info` function logs an info message with a specific color to the console.\r\n   * It provides a visual distinction for info-level logs.\r\n   */\n  static info(message) {\n    ConsoleColorLogger.log(message, 'green');\n  }\n\n  /**\r\n   * Log an error message with a specific color.\r\n   *\r\n   * @param {string} message - The error message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.error('This is an error message');\r\n   *\r\n   * @description\r\n   * The `error` function logs an error message with a specific color to the console.\r\n   * It provides a visual distinction for error-level logs.\r\n   */\n  static error(message) {\n    ConsoleColorLogger.log(message, 'red');\n  }\n\n  /**\r\n   * Log a warning message with a yellow color.\r\n   *\r\n   * @param {string} message - The warning message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.warning('Warning: Potential issue detected');\r\n   *\r\n   * @description\r\n   * The `warning` function logs a warning message with a yellow color to the console.\r\n   * It provides a visual distinction for warning-level logs.\r\n   */\n  static warning(message) {\n    ConsoleColorLogger.log(message, 'yellow');\n  }\n\n  /**\r\n   * Log a success message to the console with green color and bold font weight\r\n   *\r\n   * @param {string} msg - The success message to log to the console.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleLogger.logSuccess('Operation completed successfully!');\r\n   *\r\n   * @output\r\n   * Operation completed successfully!\r\n   *\r\n   * @description\r\n   * The `logSuccess` method logs a success message to the console with green color and bold font weight.\r\n   * It takes one parameter: `msg`, which is the success message to log to the console.\r\n   * It uses the `console.log` method to log the message to the console, with a CSS style applied to the message to change the color to green and the font weight to bold.\r\n   */\n  static logSuccess(msg) {\n    console.log(\"%c\" + msg, \"color: green; font-weight: bold\");\n  }\n\n  /**\r\n   * Log a message with a background color.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   * @param {string} backgroundColor - The background color code for the log message.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.background('This message has a background', '#FFFF00');\r\n   *\r\n   * @description\r\n   * The `background` function logs a message with a specified background color to the console.\r\n   * It allows adding emphasis to the log message with a background color.\r\n   */\n  static background(message, backgroundColor) {\n    console.log(`%c${message}`, `background: ${backgroundColor}; color: white; padding: 4px; border-radius: 4px`);\n  }\n\n  /**\r\n   * Log a message with an underline.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.underline('This message has an underline');\r\n   *\r\n   * @description\r\n   * The `underline` function logs a message with an underline to the console.\r\n   * It can be used to visually emphasize specific log messages.\r\n   */\n  static underline(message) {\n    console.log(`%c${message}`, 'text-decoration: underline');\n  }\n\n  /**\r\n   * Log a message with a strike-through.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.strikeThrough('This message has a strike-through');\r\n   *\r\n   * @description\r\n   * The `strikeThrough` function logs a message with a strike-through to the console.\r\n   * It can be used to visually indicate that the log message is deprecated or no longer relevant.\r\n   */\n  static strikeThrough(message) {\n    console.log(`%c${message}`, 'text-decoration: line-through');\n  }\n\n  /**\r\n   * Log a message with a bold font.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.bold('This is a bold message');\r\n   *\r\n   * @description\r\n   * The `bold` function logs a message with a bold font to the console.\r\n   * It enhances the visual appearance of the log message.\r\n   */\n  static bold(message) {\n    console.log(`%c${message}`, 'font-weight: bold');\n  }\n\n  /**\r\n   * Log a message with an italic font.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.italic('This is an italic message');\r\n   *\r\n   * @description\r\n   * The `italic` function logs a message with an italic font to the console.\r\n   * It provides a distinct style for the log message.\r\n   */\n  static italic(message) {\n    console.log(`%c${message}`, 'font-style: italic');\n  }\n\n  /**\r\n   * Log a message with a specific font size.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   * @param {string} fontSize - The font size for the log message.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.fontSize('This message has a custom font size', '20px');\r\n   *\r\n   * @description\r\n   * The `fontSize` function logs a message with a specified font size to the console.\r\n   * It allows adjusting the text size for specific log messages.\r\n   */\n  static fontSize(message, fontSize) {\n    console.log(`%c${message}`, `font-size: ${fontSize}`);\n  }\n\n  /**\r\n   * Log a message with a blinking effect.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.blink('This message blinks');\r\n   *\r\n   * @description\r\n   * The `blink` function logs a message with a blinking effect to the console.\r\n   * It adds a visual dynamic to the log message.\r\n   */\n  static blink(message) {\n    console.log(`%c${message}`, 'text-decoration: blink');\n  }\n\n  /**\r\n   * Log a message with a shadow.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   * @param {string} shadowColor - The color of the shadow.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.shadow('This message has a shadow', 'rgba(0, 0, 0, 0.5)');\r\n   *\r\n   * @description\r\n   * The `shadow` function logs a message with a shadow effect to the console.\r\n   * It provides depth and contrast to the log message.\r\n   */\n  static shadow(message, shadowColor) {\n    console.log(`%c${message}`, `text-shadow: 2px 2px 2px ${shadowColor}`);\n  }\n\n  /**\r\n   * Log a message with a border.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   * @param {string} borderColor - The border color for the log message.\r\n   * @param {string} borderWidth - The border width for the log message.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.border('This message has a border', 'black', '2px');\r\n   *\r\n   * @description\r\n   * The `border` function logs a message with a border to the console.\r\n   * It adds a border around the log message with the specified color and width.\r\n   */\n  static border(message, borderColor, borderWidth) {\n    console.log(`%c${message}`, `border: ${borderWidth} solid ${borderColor}`);\n  }\n\n  /**\r\n   * Log an emphasized message.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.emphasize('This message is emphasized');\r\n   *\r\n   * @description\r\n   * The `emphasize` function logs an emphasized message to the console.\r\n   * It adds emphasis and a distinctive style to the log message.\r\n   */\n  static emphasize(message) {\n    console.log(`%c${message}`, 'font-weight: bold; font-style: italic');\n  }\n\n  /**\r\n    * Log a message with a typewriter effect.\r\n    *\r\n    * @param {string} message - The log message to be printed.\r\n    *\r\n    * @returns {void}\r\n    *\r\n    * @example\r\n    * ConsoleColorLogger.typewriter('This message has a typewriter effect');\r\n    *\r\n    * @description\r\n    * The `typewriter` function logs a message with a typewriter effect to the console.\r\n    * It simulates the appearance of characters being typed one by one.\r\n    */\n  static typewriter(message) {\n    let delay = 0;\n    for (const char of message) {\n      setTimeout(() => {\n        console.log(char);\n      }, delay);\n      delay += 100;\n    }\n  }\n\n  /**\r\n   * Log a message with a rotating emoji effect.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.rotateEmoji('This message has a rotating emoji effect');\r\n   *\r\n   * @description\r\n   * The `rotateEmoji` function logs a message with a rotating emoji effect to the console.\r\n   * It uses a set of rotating emojis to add a playful touch to the log message.\r\n   */\n  static rotateEmoji(message) {\n    const emojis = ['', '', '', '', ''];\n    let index = 0;\n    for (const char of message) {\n      const emoji = emojis[index % emojis.length];\n      console.log(`%c${emoji} ${char}`, 'font-size: 20px; color: blue;');\n      index++;\n    }\n  }\n\n  /**\r\n   * Log a message with a flashing background effect.\r\n   *\r\n   * @param {string} message - The log message to be printed.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ConsoleColorLogger.flashBackground('This message has a flashing background effect');\r\n   *\r\n   * @description\r\n   * The `flashBackground` function logs a message with a flashing background effect to the console.\r\n   * It creates a visually striking effect by alternating the background color.\r\n   */\n  static flashBackground(message) {\n    let isFlash = false;\n    for (const char of message) {\n      isFlash = !isFlash;\n      const backgroundColor = isFlash ? 'yellow' : 'transparent';\n      console.log(`%c${char}`, `background-color: ${backgroundColor}; color: black;`);\n    }\n  }\n\n  /**\r\n  * Log a message with rainbow colors to the console.\r\n  *\r\n  * @param {string} message - The log message to be printed.\r\n  *\r\n  * @returns {void}\r\n  *\r\n  * @example\r\n  * ConsoleColorLogger.logRainbow('This is a colorful message!');\r\n  *\r\n  * @description\r\n  * The `logRainbow` function logs a message to the console with rainbow colors.\r\n  * It creates a visually appealing effect by cycling through different colors for each character in the message.\r\n  */\n  static logRainbow(message) {\n    const rainbowColors = ['#ff0000', '#ff9900', '#ffff00', '#33cc33', '#3399ff', '#cc33ff'];\n    let colorIndex = 0;\n    for (const char of message) {\n      const color = rainbowColors[colorIndex % rainbowColors.length];\n      console.log(`%c${char}`, `color: ${color}`);\n      colorIndex++;\n    }\n  }\n\n  /**\r\n   * Logs all the available functions (static and non-static) in the CustomConsoleLogger class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  CustomConsoleLogger.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(CustomConsoleLogger).filter(name => typeof CustomConsoleLogger[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    const nonStaticFunctionNames = Object.getOwnPropertyNames(CustomConsoleLogger.prototype).filter(name => typeof CustomConsoleLogger.prototype[name] === 'function' && name !== 'constructor');\n    console.log(\"*************************************************\");\n    console.log(`Available static functions in CustomConsoleLogger class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n    console.log(\"*************************************************\");\n    console.log(\"\");\n    console.log(`\\nAvailable non-static functions in CustomConsoleLogger class:`);\n    nonStaticFunctionNames.forEach(name => console.log(`- ${name}()`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/logger/customConsoleLogger/customConsoleLogger.js?");

/***/ }),

/***/ "./src/logger/eventLogger/eventLogger.js":
/*!***********************************************!*\
  !*** ./src/logger/eventLogger/eventLogger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventLogger: () => (/* binding */ EventLogger)\n/* harmony export */ });\n/* harmony import */ var _base_loggerBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/loggerBase.js */ \"./src/logger/base/loggerBase.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _validator_validation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../validator/validation.js */ \"./src/logger/validator/validation.js\");\n // Importing the base logger class\n // Importing EventEmitter class from Node.js 'events' module\n // Importing the logger validation module\n\n/**\r\n * Validator instance for validating file names and log levels.\r\n * @type {VALIDATE_LOGGER}\r\n */\nconst validator = new _validator_validation_js__WEBPACK_IMPORTED_MODULE_2__.LoggerValidation();\n\n/**\r\n * EventLogger class extends LoggerBase class and provides event-based logging functionality.\r\n *\r\n * This class is used to log messages with a specified level and emit custom events with a specified payload.\r\n * It also allows adding listeners for custom events and removing them.\r\n *\r\n * The class uses the EventEmitter class from the Node.js 'events' module to handle event emissions and listeners.\r\n */\nclass EventLogger extends _base_loggerBase_js__WEBPACK_IMPORTED_MODULE_0__.LoggerBase {\n  constructor() {\n    super(); // Calling the constructor of the parent class LoggerBase\n    // Creating a new instance the EventEmitter class\n    this.emitter = new events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();\n  }\n\n  /**\r\n   * Log a message with a specified level\r\n   *\r\n   * @param {string} message - The message to log to the console.\r\n   * @param {('DEBUG'|'INFO'|'WARN'|'ERROR')} level - The level of the log message.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * EventLogger.log('Hello, world!', 'INFO');\r\n   *\r\n   * @output\r\n   * INFO: Hello, world!\r\n   *\r\n   * @description\r\n   * The `log` method logs a message with a specified level.\r\n   * It takes two parameters: `message`, which is the message to log to the console, and `level`, which is the level of the log message.\r\n   * It uses the `addLog` method of the parent class to add the log to the logs array.\r\n   * It then validates the log level using the `_validateLogLevel` method of the `validator` object.\r\n   * Finally, it emits a 'log' event with the log message and level.\r\n   */\n  log(message, level) {\n    super.addLog(message, level);\n    validator._validateLogLevel({\n      level\n    });\n    this.emitter.emit('log', {\n      level: level,\n      message: message\n    });\n  }\n\n  /**\r\n   * Emit a custom event with a payload\r\n   *\r\n   * @param {string} event - The name of the custom event.\r\n   * @param {Object} payload - The data to send with the custom event.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * EventLogger.emit('myCustomEvent', { data: 'Hello, world!' });\r\n   *\r\n   * @description\r\n   * The `emit` method emits a custom event with a payload.\r\n   * It takes two parameters: `event`, which is the name of the custom event, and `payload`, which is the data to send with the custom event.\r\n   * It uses the `_validateEmit` method of the `validator` object to validate the event and payload.\r\n   * It then emits the custom event with the payload using the `emit` method of the `emitter` object.\r\n   */\n  emit(event, payload) {\n    validator._validateEmit({\n      event,\n      payload\n    });\n    this.emitter.emit(event, payload);\n  }\n\n  /**\r\n   * Register a listener for a custom event.\r\n   *\r\n   * @param {string} event - The name of the custom event.\r\n   * @param {Function} listener - The function to be called when the custom event is emitted.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * // Register a listener for the custom event 'myCustomEvent'\r\n   * EventLogger.on('myCustomEvent', (payload) => {\r\n   *   console.log('Custom event received:', payload);\r\n   * });\r\n   *\r\n   * @description\r\n   * The `on` method registers a listener function for a custom event. When the specified custom event is emitted using the `emit` method, the registered listener function is called.\r\n   * It takes two parameters: `event`, the name of the custom event, and `listener`, the function to be executed when the event is emitted.\r\n   * The `validator._validateEmittion` method is used internally to validate the event and listener parameters.\r\n   * The registration is done using the `on` method of the `emitter` object.\r\n   */\n  on(event, listener) {\n    validator._validateEmittion({\n      event,\n      listener\n    });\n    this.emitter.on(event, listener);\n  }\n\n  /**\r\n   * Add a one-time listener for a custom event\r\n   *\r\n   * @param {string} event - The name of the custom event.\r\n   * @param {Function} listener - The function to execute when the custom event is emitted.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * EventLogger.once('myCustomEvent', (data) => {\r\n   *   console.log(data.message);\r\n   * });\r\n   *\r\n   * @description\r\n   * The `once` method adds a one-time listener for a custom event.\r\n   * It takes two parameters: `event`, which is the name of the custom event, and `listener`, which is the function to execute when the custom event is emitted.\r\n   * It uses the `_validateEmittion` method of the `validator` object to validate the event and listener.\r\n   * It then adds a one-time listener for the custom event using the `once` method of the `emitter` object.\r\n   * The listener will be executed only once, the next time the custom event is emitted.\r\n   */\n  once(event, listener) {\n    validator._validateEmittion({\n      event,\n      listener\n    });\n    this.emitter.once(event, listener);\n  }\n\n  /**\r\n   * Remove a listener for a custom event\r\n   *\r\n   * @param {string} event - The name of the custom event.\r\n   * @param {Function} listener - The function to remove as a listener for the custom event.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * const listener = (data) => {\r\n   *   console.log(data);\r\n   * };\r\n   *\r\n   * EventLogger.on('myCustomEvent', listener);\r\n   * EventLogger.off('myCustomEvent', listener);\r\n   *\r\n   * @description\r\n   * The `off` method removes a listener for a custom event.\r\n   * It takes two parameters: `event`, which is the name of the custom event, and `listener`, which is the function to remove as a listener for the custom event.\r\n   * It uses the `_validateEmittion` method of the `validator` object to validate the event and listener.\r\n   * It then removes the listener for the custom event using the `off` method of the `emitter` object.\r\n   */\n  off(event, listener) {\n    validator._validateEmittion({\n      event,\n      listener\n    });\n    this.emitter.off(event, listener);\n  }\n\n  /**\r\n   * Remove all listeners for all custom events\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * EventLogger.removeAllListeners();\r\n   *\r\n   * @description\r\n   * The `removeAllListeners` method removes all listeners for all custom events.\r\n   * It does not take any parameters.\r\n   * It uses the `removeAllListeners` method of the `emitter` object to remove all listeners for all custom events.\r\n   */\n  removeAllListeners() {\n    this.emitter.removeAllListeners();\n  }\n\n  /**\r\n   * Logs all the available functions (static and non-static) in the EventLogger class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  EventLogger.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(EventLogger).filter(name => typeof EventLogger[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    const nonStaticFunctionNames = Object.getOwnPropertyNames(EventLogger.prototype).filter(name => typeof EventLogger.prototype[name] === 'function' && name !== 'constructor');\n    console.log(\"*************************************************\");\n    console.log(`Available static functions in EventLogger class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n    console.log(\"*************************************************\");\n    console.log(\"\");\n    console.log(`\\nAvailable non-static functions in EventLogger class:`);\n    nonStaticFunctionNames.forEach(name => console.log(`- ${name}()`));\n  }\n}\n\n// Exporting the EventLogger class\n\n\n//# sourceURL=webpack://js.package/./src/logger/eventLogger/eventLogger.js?");

/***/ }),

/***/ "./src/logger/fileLogger/fileLogger.js":
/*!*********************************************!*\
  !*** ./src/logger/fileLogger/fileLogger.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FileLogger: () => (/* binding */ FileLogger)\n/* harmony export */ });\n/* harmony import */ var _base_loggerBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/loggerBase */ \"./src/logger/base/loggerBase.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! file-saver */ \"./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _validator_validation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../validator/validation.js */ \"./src/logger/validator/validation.js\");\n\n\n\n\n/**\r\n * Validator instance for validating file names and log levels.\r\n * @type {VALIDATE_LOGGER}\r\n */\nconst validator = new _validator_validation_js__WEBPACK_IMPORTED_MODULE_2__.LoggerValidation();\n\n/**\r\n * File system based logger class. Logs messages to a file and provides methods to download log files.\r\n * \r\n * Can set log level threshold to control which log messages are saved. \r\n * Logs timestamp and log level with each message.\r\n *\r\n * Provides methods to download complete logs or logs filtered by log level.\r\n *\r\n * @class FileLogger\r\n * @extends LoggerBase\r\n */\nclass FileLogger extends _base_loggerBase__WEBPACK_IMPORTED_MODULE_0__.LoggerBase {\n  /**\r\n   * Create new FileLogger instance.\r\n   *\r\n   * Validates and saves fileName provided.\r\n   *\r\n   * @param {string} fileName - Name of file to save logs to.\r\n   * @throws {Error} If the provided fileName is invalid.\r\n   *\r\n   * The fileName parameter is required and should be a non-empty string.\r\n   * The fileName will be used as the name of the log file.\r\n   * The fileName will be validated using the `_validateFileName` method of the `validator` instance.\r\n   * If the fileName is invalid, an error will be thrown.\r\n   */\n  constructor(fileName) {\n    // Call super constructor\n    super();\n\n    // Validate filename\n    validator._validateFileName({\n      fileName\n    });\n\n    // Save filename\n    this.fileName = fileName;\n  }\n\n  /**\r\n   * @param {string} fileName - The new file name to save logs to.\r\n   * \r\n   * @throws {Error} If the provided `fileName` is invalid.\r\n   * \r\n   * @return {void}\r\n   * \r\n   * @output This method sets the filename to the value of the `fileName` parameter.\r\n   * \r\n   * @example\r\n   * const logger = new FileLogger('my-log.txt');\r\n   * logger.setFileName('new-log-file.txt');\r\n   * \r\n   * @description The `setFileName` method sets the filename to the value of the `fileName` parameter.\r\n   *\r\n   * The `fileName` parameter is required and should be a non-empty string.\r\n   * The `fileName` will be validated using the `_validateFileName` method of the `validator` instance.\r\n   * If the `fileName` is invalid, an error will be thrown.\r\n   *\r\n   * The `setFileName` method is useful when you want to change the name of the log file that logs are saved to.\r\n   * This can be useful if you want to save logs to a different file or if you want to start a new log file.\r\n   *\r\n   */\n  setFileName(fileName) {\n    validator._validateFileName({\n      fileName\n    });\n    this.fileName = fileName;\n  }\n\n  /**\r\n   * Download the current logs as a text file and optionally clear logs after download.\r\n   *\r\n   * @param {boolean} [clearLogsAfterDownload=true] - Indicates whether to clear logs after download.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * FileLogger.downloadLogs(); // Downloads logs and clears logs afterward\r\n   * FileLogger.downloadLogs(false); // Downloads logs without clearing logs afterward\r\n   *\r\n   * @output\r\n   * // No output in the console. Initiates a download of a text file containing logs.\r\n   *\r\n   * @description\r\n   * The `downloadLogs` function allows the user to download the current logs as a text file.\r\n   * The function takes an optional parameter `clearLogsAfterDownload` (default is `true`), which, if set to `true`, clears the logs after initiating the download.\r\n   * If there are no logs to download, a warning message is logged to the console.\r\n   * The logs are joined into a single string with newline separators, and a Blob is created with the specified MIME type ('text/plain').\r\n   * The Blob is then saved as a text file using the `saveAs` function.\r\n   * If `clearLogsAfterDownload` is `true`, the `clearLogs` function is called to remove the logs after the download.\r\n   */\n  downloadLogs(clearLogsAfterDownload = true) {\n    if (this.logs.length === 0) {\n      console.warn('No logs to download.');\n      return;\n    }\n    const logContent = this.logs.join('\\n');\n    const blob = new Blob([logContent], {\n      type: 'text/plain'\n    });\n    (0,file_saver__WEBPACK_IMPORTED_MODULE_1__.saveAs)(blob, this.fileName);\n    if (clearLogsAfterDownload) {\n      this.clearLogs();\n    }\n  }\n\n  /**\r\n   * Download logs for a specific log level as a text file.\r\n   *\r\n   * @param {('INFO'|'DEBUG'|'WARN')} level - The log level for which logs should be downloaded.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * FileLogger.downloadLogsByLevel('DEBUG'); // Downloads logs for the 'DEBUG' level\r\n   * FileLogger.downloadLogsByLevel('INFO'); // Downloads logs for the 'INFO' level\r\n   * FileLogger.downloadLogsByLevel('WARN'); // Downloads logs for the 'WARN' level\r\n   *\r\n   * @output\r\n   * // No output in the console. Initiates a download of a text file containing filtered logs.\r\n   *\r\n   * @description\r\n   * The `downloadLogsByLevel` function allows the user to download logs for a specific log level as a text file.\r\n   * It takes a `level` parameter representing the desired log level and validates it using the `validateLogLevel` method.\r\n   * Logs with the specified log level are filtered from the existing logs array.\r\n   * If no logs are found for the specified level, a warning message is logged to the console.\r\n   * The filtered logs are then joined into a single string with newline separators, and a Blob is created with the specified MIME type ('text/plain').\r\n   * The Blob is saved as a text file using the `saveAs` function, with the filename including both the original filename and the log level.\r\n   */\n  downloadLogsByLevel(level) {\n    validator._validateLogLevel({\n      level\n    });\n    let filteredLogs = this.logs.filter(log => {\n      return this.getLogLevel(log) === level;\n    });\n    if (filteredLogs.length === 0) {\n      console.warn(`No logs found for level: ${level}`);\n      return;\n    }\n    let logContent = filteredLogs.join('\\n');\n    const blob = new Blob([logContent], {\n      type: 'text/plain'\n    });\n    (0,file_saver__WEBPACK_IMPORTED_MODULE_1__.saveAs)(blob, `${this.fileName}-${level}.txt`);\n  }\n\n  /**\r\n   * Logs all the available functions (static and non-static) in the FileLogger class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  FileLogger.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(FileLogger).filter(name => typeof FileLogger[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    const nonStaticFunctionNames = Object.getOwnPropertyNames(FileLogger.prototype).filter(name => typeof FileLogger.prototype[name] === 'function' && name !== 'constructor');\n    console.log(\"*************************************************\");\n    console.log(`Available static functions in FileLogger class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n    console.log(\"*************************************************\");\n    console.log(\"\");\n    console.log(`\\nAvailable non-static functions in FileLogger class:`);\n    nonStaticFunctionNames.forEach(name => console.log(`- ${name}()`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/logger/fileLogger/fileLogger.js?");

/***/ }),

/***/ "./src/logger/performanceLogger/performanceLogger.js":
/*!***********************************************************!*\
  !*** ./src/logger/performanceLogger/performanceLogger.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceLogger: () => (/* binding */ PerformanceLogger)\n/* harmony export */ });\n/* harmony import */ var _base_loggerBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/loggerBase.js */ \"./src/logger/base/loggerBase.js\");\n/* harmony import */ var _validator_validation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../validator/validation.js */ \"./src/logger/validator/validation.js\");\n\n\nconst validator = new _validator_validation_js__WEBPACK_IMPORTED_MODULE_1__.LoggerValidation();\n\n/**\r\n * Performance logger class for logging performance-related metrics.\r\n * Extends the functionality of the base logger.\r\n *\r\n * @class\r\n * @extends LoggerBase\r\n */\nclass PerformanceLogger extends _base_loggerBase_js__WEBPACK_IMPORTED_MODULE_0__.LoggerBase {\n  /**\r\n   * Create a PerformanceLogger instance.\r\n   *\r\n   * @param {('DEBUG'|'INFO'|'WARN')} [level=INFO] - Initial log level.\r\n   *\r\n   * @returns {PerformanceLogger} A new instance of the PerformanceLogger class.\r\n   *\r\n   *\r\n   * @description\r\n   * The constructor initializes a new instance of the `PerformanceLogger` class, which extends the `LoggerBase` class.\r\n   * It takes an optional `level` parameter, which specifies the initial log level.\r\n   * If no level is provided, the default log level is `INFO`.\r\n   */\n  constructor(level = 'INFO') {\n    super(level);\n  }\n\n  /**\r\n       * Measure the time taken by a specific operation.\r\n       *\r\n       * @param {string} label - The name or description of the operation.\r\n       * @param {Function} func - The operation to be measured.\r\n       *\r\n       * @returns {void}\r\n       *\r\n       * @example\r\n       * PerformanceLogger.measureTime('Expensive operation', () => {\r\n       *   // Do something expensive here\r\n       * });\r\n       *\r\n       * @output\r\n       * Expensive operation: 500 milliseconds\r\n       *\r\n       * @description\r\n       * The `measureTime` function measures the time taken by a specific operation.\r\n       * It takes two parameters: `operationName`, which is a string describing the operation, and `callback`, which is a function that performs the operation.\r\n       * The function starts a timer using the `performance.now()` method, executes the `callback` function, and then stops the timer.\r\n       * The elapsed time is then calculated and logged using the `push` method of the `logs` array.\r\n       */\n  measureTime(label, func) {\n    const startTime = performance.now();\n    func();\n    const endTime = performance.now();\n    const elapsedTime = endTime - startTime;\n    const log = `${label}: ${elapsedTime} milliseconds`;\n    this.logs.push(log);\n  }\n\n  /**\r\n  * Log the current memory usage.\r\n  *\r\n  * @returns {void}\r\n  *\r\n  * @example\r\n  * PerformanceLogger.logMemoryUsage();\r\n  *\r\n  * @output\r\n  * Memory Usage: {usedJSHeapSize: 123456, totalJSHeapSize: 123456, jsHeapSizeLimit: 123456}\r\n  *\r\n  * @description\r\n  * The `logMemoryUsage` function logs the current memory usage of the JavaScript heap.\r\n  * It uses the `performance.memory` property to get the current memory usage, and then logs a message to the console indicating the current memory usage.\r\n  * The `performance.memory` property returns an object with the following properties:\r\n  * - `usedJSHeapSize`: The current size of the JavaScript heap in bytes.\r\n  * - `totalJSHeapSize`: The maximum size of the JavaScript heap in bytes.\r\n  * - `jsHeapSizeLimit`: The maximum size of the JavaScript heap in bytes that can be used by the JavaScript runtime.\r\n  */\n  static logMemoryUsage() {\n    const memoryUsage = performance.memory;\n    const log = `Memory Usage: ${JSON.stringify(memoryUsage)}`;\n    return log;\n  }\n\n  /**\r\n   * Log the current frames per second (FPS) in the browser.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * PerformanceLogger.logFPS();\r\n   *\r\n   * @output Frames Per Second:60.00\r\n   *\r\n   * @description\r\n   * The `logFPS` function logs the current frames per second (FPS) in browser.\r\n   * It uses the `performance.now()` method to get the current time in milliseconds, and then logs a message to the console indicating the current FPS.\r\n   * Note that this method does not actually calculate the FPS, it simply logs the current time in milliseconds and labels it as FPS.\r\n   */\n  static logFPS() {\n    const fps = performance.now();\n    const log = `Frames Per Second: ${fps.toFixed(2)}`;\n    return log;\n  }\n\n  /**\r\n   * Log the time taken for a function to execute multiple times.\r\n   *\r\n   * @param {string} functionName - The name or description of the function\r\n   * @param {Function} callback - The function to be measured.\r\n   * @param {number} iterations - The number of iterations to execute the function.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * PerformanceLogger.measureIterationsTime('My Function', () => {\r\n   *   console.log('Hello, world!');\r\n   * }, 1000);\r\n   *\r\n   * @output\r\n   * My Function (1000 iterations): 0.001 milliseconds per iteration\r\n   *\r\n   * @description\r\n   * The `measureIterationsTime` function measures the time taken for a function to execute multiple times.\r\n   * It takes three parameters: `functionName`, which is a string describing the function, `callback`, which is the function to be measured, and `iterations`, which is the number of times to execute the function.\r\n   * The function starts a timer using the `performance.now()` method, executes the `callback` function for the specified number of `iterations`, and then stops the timer.\r\n   * The total time taken is calculated, as well as the average time per iteration, and both are logged using the `push` method of the `logs` array.\r\n   */\n  measureIterationsTime(Label, func, iterations) {\n    const start = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      func();\n    }\n    const end = performance.now();\n    const totalTime = end - start;\n    const averageTime = totalTime / iterations;\n    const log = `${Label} (${iterations} iterations): ${averageTime * 1000} milliseconds per iteration`;\n    this.logs.push(log);\n  }\n\n  /**\r\n  * Log the time taken for a forEach operation on an array.\r\n  *\r\n  * @param {string} arrayName - The name or description of the array.\r\n  * @param {Array} array - The array to iterate over.\r\n  * @param {Function} callback - The function to be executed for each element.\r\n  *\r\n  * @returns {void}\r\n  *\r\n  * @example\r\n  * PerformanceLogger.measureForEachTime('My Array', [1, 2, 3], (element) => {\r\n  *   console.log(element);\r\n  * });\r\n  *\r\n  * @output\r\n  * forEach on My Array: 3 milliseconds\r\n  *\r\n  * @description\r\n  * The `measureForEachTime` function measures the time taken for a `forEach` operation on an array.\r\n  * It takes three parameters: `label`, which is a string describing the array, `array`, which is the array to iterate over, and `function`, which is a function that is executed for each element in the array.\r\n  * The function starts a timer using the `performance.now()` method, performs the `forEach` operation, and then stops the timer.\r\n  * The elapsed time is then calculated and logged using the `push` method of the `logs` array.\r\n  */\n  measureForEachTime(Label, array, func) {\n    const startTime = performance.now();\n    array.forEach(func);\n    const endTime = performance.now();\n    const elapsedTime = endTime - startTime;\n    const log = `forEach on ${Label}: ${elapsedTime} milliseconds`;\n    this.logs.push(log);\n  }\n\n  /**\r\n   * Log the time taken for the page to load.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * PerformanceLogger.logPageLoadTime();\r\n   *\r\n   * @output\r\n   * Page Load Time: 1234 milliseconds\r\n   *\r\n   * \r\n   * @description\r\n   * The `logPageLoadTime` function logs the time taken for page to load.     * It uses the `performance.timing` object to get the time taken for the page load, and then logs a message to the console indicating the page load time in milliseconds.\r\n   * The `performance.timing` object contains various timing-related information about the page load, including the time taken for the navigation to start, the time taken for the DOM to be parsed, and the time taken for the page to be fully loaded.\r\n   * The `loadEventEnd` property represents the time when the load event is fired, after the page has finished loading.\r\n   * The `navigationStart` property represents the time when the navigation to the page started.\r\n   * The difference between these two properties gives the total time taken for the page to load.\r\n   */\n  logPageLoadTime() {\n    const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;\n    const log = `Page Load Time: ${loadTime} milliseconds`;\n    this.logs.push(log);\n  }\n\n  /**\r\n   * Log the time taken for a specific resource to load.\r\n   *\r\n   * @param {string} resourceName - The name of the resource log the load time for.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * PerformanceLogger.logResourceLoadTime('style.css');\r\n   *\r\n   * @output\r\n   * style.css Load Time: 123 milliseconds\r\n   *\r\n   * @description\r\n   * The `logResourceLoadTime` function logs the time taken for a specific resource to load.\r\n   * It takes one parameter: `resourceName`, which is the name of the resource to log the load time for.\r\n   * It uses the `performance.getEntriesByName` method to get an array of performance entries for the specified resource, and then logs a message to the console indicating the load time in milliseconds.\r\n   * If the resource is not found, it logs an error message to the console.\r\n   * The `performance.getEntriesByName` method returns an array of performance entries that match the specified name.\r\n   * Each performance entry contains various timing-related information about the resource, including the time taken for the resource to start loading, the time taken for the resource to be received, and the time taken for the resource to be parsed.\r\n   * The `duration` property represents the total time taken for the resource to load.\r\n   */\n  logResourceLoadTime(resourceName) {\n    const entries = performance.getEntriesByName(resourceName);\n    if (entries.length > 0) {\n      const loadTime = entries[0].duration;\n      const log = `${resourceName} Load Time: ${loadTime} milliseconds`;\n      this.logs.push(log);\n    } else {\n      console.error(`Resource \"${resourceName}\" not found.`);\n    }\n  }\n\n  /**\r\n   * Logs all the available functions (static and non-static) in the PerformanceLogger class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  PerformanceLogger.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available functions (static and non-static) in the AuditLogger class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(PerformanceLogger).filter(name => typeof PerformanceLogger[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    const nonStaticFunctionNames = Object.getOwnPropertyNames(PerformanceLogger.prototype).filter(name => typeof PerformanceLogger.prototype[name] === 'function' && name !== 'constructor');\n    console.log(\"*************************************************\");\n    console.log(`Available static functions in PerformanceLogger class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n    console.log(\"*************************************************\");\n    console.log(\"\");\n    console.log(`\\nAvailable non-static functions in PerformanceLogger class:`);\n    nonStaticFunctionNames.forEach(name => console.log(`- ${name}()`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/logger/performanceLogger/performanceLogger.js?");

/***/ }),

/***/ "./src/logger/validator/validation.js":
/*!********************************************!*\
  !*** ./src/logger/validator/validation.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoggerValidation: () => (/* binding */ LoggerValidation)\n/* harmony export */ });\n/* harmony import */ var joi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! joi */ \"./node_modules/joi/dist/joi-browser.min.js\");\n/* harmony import */ var joi__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(joi__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\r\n * Validation utility for logger classes.\r\n */\nclass LoggerValidation {\n  _validateFileName = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      fileName: joi__WEBPACK_IMPORTED_MODULE_0___default().string().required()\n    });\n    const {\n      error\n    } = schema.validate(params);\n    if (error) {\n      throw new Error(`Invalid parameters: ${error.details[0].message}`);\n    }\n  };\n\n  /**\r\n  * Validates log file name.\r\n  * \r\n  * @param {object} params - Object containing file name\r\n  * @param {string} params.fileName - File name to validate\r\n  * @throws {Error} If file name is invalid\r\n  * @private\r\n  */\n  _validateLogLevel = params => {\n    const validReturnTypes = ['WARN', 'INFO', 'DEBUG'];\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      level: joi__WEBPACK_IMPORTED_MODULE_0___default().string().valid(...validReturnTypes).default(\"INFO\")\n    });\n    const {\n      error\n    } = schema.validate(params);\n    if (error) {\n      throw new Error(`Invalid parameters: ${error.details[0].message}`);\n    }\n  };\n\n  /**\r\n   * Validates log level.\r\n   * \r\n   * @param {object} params - Object containing log level \r\n   * @param {string} params.level - Log level to validate\r\n   * @throws {Error} If log level is invalid\r\n   * @private  \r\n   */\n  _validateLogMessage = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      message: joi__WEBPACK_IMPORTED_MODULE_0___default().string().required()\n    });\n    const {\n      error\n    } = schema.validate(params);\n    if (error) {\n      throw new Error(`Invalid parameters: ${error.details[0].message}`);\n    }\n  };\n\n  /**\r\n   * Validates event and payload for emitting custom events.\r\n   * \r\n   * @param {object} params - Object containing event and payload\r\n   * @param {string} params.event - Event name to validate\r\n   * @param {*} params.payload - Payload to validate\r\n   * @throws {Error} If event or payload is invalid\r\n   * @private  \r\n   */\n  _validateEmit(params) {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      event: joi__WEBPACK_IMPORTED_MODULE_0___default().string().required(),\n      payload: joi__WEBPACK_IMPORTED_MODULE_0___default().any()\n    });\n    const {\n      error\n    } = schema.validate(params);\n    if (error) {\n      throw new Error(`Invalid parameters for emit: ${error.details[0].message}`);\n    }\n  }\n\n  /**\r\n  * Validates event and listener for event listeners.\r\n  *\r\n  * @param {object} params - Object containing event and listener\r\n  * @param {string} params.event - Event name to validate\r\n  * @param {Function} params.listener - Listener to validate\r\n  * @throws {Error} If event or listener is invalid\r\n  * @private\r\n  */\n  _validateEmittion(params) {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      event: joi__WEBPACK_IMPORTED_MODULE_0___default().string().required(),\n      listener: joi__WEBPACK_IMPORTED_MODULE_0___default().func()\n    });\n    const {\n      error\n    } = schema.validate(params);\n    if (error) {\n      throw new Error(`Invalid parameters for on: ${error.details[0].message}`);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/logger/validator/validation.js?");

/***/ }),

/***/ "./src/storage-Manager/storageManager,.js":
/*!************************************************!*\
  !*** ./src/storage-Manager/storageManager,.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageManager: () => (/* binding */ StorageManager)\n/* harmony export */ });\n/* harmony import */ var _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../validation/validation.js */ \"./src/validation/validation.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-js */ \"./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lz-string */ \"./node_modules/lz-string/libs/lz-string.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n/**\r\n * A utility class for managing browser storage.\r\n *\r\n * @class StorageManager\r\n */\nclass StorageManager {\n  /**\r\n   * Sets a value in either sessionStorage or localStorage based on the provided parameters.\r\n   *\r\n   * @param {string} key - The key under which to store the value.\r\n   * @param {*} value - The value to be stored (can be any JSON-serializable data).\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the value in sessionStorage; otherwise, stores it in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns without storing the value.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // StorageManager.setValue('username', 'john_doe');\r\n   *\r\n   * @description\r\n   * This method sets a value in either sessionStorage or localStorage based on the provided parameters.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static setValue(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.setItem(key, JSON.stringify(value));\n    return this;\n  }\n\n  /**\r\n   * Gets a value from either sessionStorage or localStorage based on the provided parameters.\r\n   *\r\n   * @param {string} key - The key under which the value is stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, retrieves the value from sessionStorage; otherwise, retrieves it from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {*} - The retrieved value, or null if the value is not found or an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // const storedUsername = StorageManager.getValue('username');\r\n   *\r\n   * @description\r\n   * This method gets a value from either sessionStorage or localStorage based on the provided parameters.\r\n   * Returns the retrieved value, or null if the value is not found or an error occurs.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static getValue(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    return storedValue ? JSON.parse(storedValue) : null;\n  }\n\n  /**\r\n   * Removes a stored value by key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the value to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void|null} - Returns null if the key is not found, or void if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.removeValue('myKey', true);\r\n   *\r\n   * @description\r\n   * This method removes a stored value by key from either sessionStorage or localStorage.\r\n   * Returns null if the key is not found, or void if successful.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static removeValue(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.removeItem(key);\n    return this;\n  }\n\n  /**\r\n   * Clears all stored values from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, clears sessionStorage; otherwise, clears localStorage.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.clearStorage(true);\r\n   *\r\n   * @description\r\n   * This method clears all stored values from either sessionStorage or localStorage.\r\n   */\n  static clearStorage(useSessionStorage = false) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.clear();\n  }\n\n  /**\r\n   * Stores an object with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key under which the object will be stored.\r\n   * @param {Object} value - The object to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void|null} - Returns null if the key or value is invalid, or void if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.setObject('myObject', { name: 'John', age: 30 }, true);\r\n   *\r\n   * @description\r\n   * This method stores an object with the specified key in either sessionStorage or localStorage.\r\n   * Returns null if the key or value is invalid, or void if successful.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static setObject(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: value,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const serializedValue = JSON.stringify(value);\n    storage.setItem(key, serializedValue);\n    return this;\n  }\n\n  /**\r\n   * Retrieves an object value with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the object to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or invalid JSON format;\r\n   * otherwise, returns null.\r\n   *\r\n   * @return {Object|null} - Returns null if the key or stored value is invalid, or the retrieved object if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string,\r\n   * or if the stored value is not an object (excluding arrays) or has invalid JSON format.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const myObject = StorageManager.getObject('myObject', true);\r\n   *\r\n   * @description\r\n   * This method retrieves an object value with the specified key from either sessionStorage or localStorage.\r\n   * Returns null if the key or stored value is invalid, or the retrieved object if successful.\r\n   * Throws an error if the 'key' parameter is not a string,\r\n   * or if the stored value is not an object (excluding arrays) or has invalid JSON format.\r\n   */\n  static getObject(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      const parsedValue = JSON.parse(storedValue);\n      if (parsedValue !== null && typeof parsedValue === 'object' && !Array.isArray(parsedValue)) {\n        return parsedValue;\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be a non-array object.');\n        return null;\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an object.');\n      return null;\n    }\n  }\n\n  /**\r\n   * Updates an object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key under which the object is stored.\r\n   * @param {Object} newValue - The new value to be added or updated within the stored object.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void|null} - Returns null if the key is invalid, or void if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.addToObject('myObject', { \"lastName\": \"Doe\" }, true);\r\n   *\r\n   * @description\r\n   * This method updates an object stored with the specified key in either sessionStorage or localStorage.\r\n   * Returns null if the key is invalid, or void if successful.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not an object.\r\n   */\n  static addToObject(key, newValue, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isObject({\n      param: newValue,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key)) || {};\n    if (typeof storedValue !== 'object') {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an object');\n      return;\n    }\n    const updatedValue = {\n      ...storedValue,\n      ...newValue\n    };\n    storage.setItem(key, JSON.stringify(updatedValue));\n    return this;\n  }\n\n  /**\r\n   * Retrieves a value from an object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the stored object.\r\n   * @param {string} propertyName - The property name of the value to retrieve from the stored object.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {any|null} - Returns null if the key or property name is not found, or the retrieved value otherwise.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' or 'propertyName' parameters are not strings.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const lastName = StorageManager.getFromObject('myObject', 'lastName', true);\r\n   *\r\n   * @description\r\n   * This method retrieves a value from an object stored with the specified key in either sessionStorage or localStorage.\r\n   * Returns null if the key or property name is not found, or the retrieved value otherwise.\r\n   * Throws an error if the 'key' or 'propertyName' parameters are not strings.\r\n   */\n  static getFromObject(key, propertyName, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: propertyName,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" and \"propertyName\" must be strings.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key));\n    return storedValue && storedValue.hasOwnProperty(propertyName) ? storedValue[propertyName] : null;\n  }\n\n  /**\r\n   * Updates a specific element within an object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key under which the object is stored.\r\n   * @param {string} propertyName - The property name of the element to be updated.\r\n   * @param {any} newValue - The new value to replace the existing value of the specified element.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void|null} - Returns null if the key, propertyName, or stored value is invalid, or void if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' or 'propertyName' parameters are not strings,\r\n   * or if the stored value is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.updateInObject('myObject', 'lastName', 'Doe', true);\r\n   *\r\n   * @description\r\n   * This method updates a specific element within an object stored with the specified key in either sessionStorage or localStorage.\r\n   * Returns null if the key, propertyName, or stored value is invalid, or void if successful.\r\n   * Throws an error if the 'key' or 'propertyName' parameters are not strings,\r\n   * or if the stored value is not an object.\r\n   */\n  static updateInObject(key, propertyName, newValue, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: propertyName,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" and \"propertyName\" must be strings.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key)) || {};\n    if (typeof storedValue !== 'object') {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an object');\n      return;\n    }\n    storedValue[propertyName] = newValue;\n    storage.setItem(key, JSON.stringify(storedValue));\n    return this;\n  }\n\n  /**\r\n   * Removes a specific element from an object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key under which the object is stored.\r\n   * @param {string} propertyName - The property name of the element to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void|null} - Returns null if the key, propertyName, or stored value is invalid, or void if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' or 'propertyName' parameters are not strings,\r\n   * or if the stored value is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.removeFromObject('myObject', 'lastName', true);\r\n   *\r\n   * @description\r\n   * This method removes a specific element from an object stored with the specified key in either sessionStorage or localStorage.\r\n   * Returns null if the key, propertyName, or stored value is invalid, or void if successful.\r\n   * Throws an error if the 'key' or 'propertyName' parameters are not strings,\r\n   * or if the stored value is not an object.\r\n   */\n  static removeFromObject(key, propertyName, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: propertyName,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" and \"propertyName\" must be strings.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key)) || {};\n    if (typeof storedValue !== 'object') {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an object');\n      return;\n    }\n    delete storedValue[propertyName];\n    storage.setItem(key, JSON.stringify(storedValue));\n  }\n\n  /**\r\n   * Removes the entire object stored with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the object to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void|null} - Returns null if the key or stored value is invalid, or void if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not an object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.deleteObject('myObject', true);\r\n   *\r\n   * @description\r\n   * This method removes the entire object stored with the specified key from either sessionStorage or localStorage.\r\n   * Returns null if the key or stored value is invalid, or void if successful.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not an object.\r\n   */\n  static deleteObject(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.removeItem(key);\n  }\n\n  /**\r\n   * Removes all session or storage items containing objects.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes items from sessionStorage; otherwise, removes items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing items.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.removeAllObjectItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all session or storage items containing objects.\r\n   * Throws an error if an error occurs while removing items.\r\n   */\n  static removeAllObjectItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      const storedValue = storage.getItem(key);\n      try {\n        const parsedValue = JSON.parse(storedValue);\n        if (parsedValue !== null && typeof parsedValue === 'object' && !Array.isArray(parsedValue)) {\n          storage.removeItem(key);\n        }\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing item with key '${key}': ${error.message}`);\n      }\n    });\n  }\n\n  /**\r\n   * Sets an array value with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key under which the array is stored.\r\n   * @param {Array} value - The array to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void|null} - Returns null if the key or value is invalid, or void if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the value is not an array.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.setArray('myArray', [1, 2, 3], true);\r\n   *\r\n   * @description\r\n   * This method sets an array value with the specified key in either sessionStorage or localStorage.\r\n   * Returns null if the key or value is invalid, or void if successful.\r\n   * Throws an error if the 'key' parameter is not a string or if the value is not an array.\r\n   */\n  static setArray(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isArray({\n      param: value,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string, and \"value\" must be an array.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.setItem(key, JSON.stringify(value));\n    return this;\n  }\n\n  /**\r\n   * Retrieves an array value with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the array to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not an array;\r\n   *                                       otherwise, returns null.\r\n   *\r\n   * @return {Array|null} - Returns null if the key or stored value is invalid, or the retrieved array if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // const myArray = StorageManager.getArray('myArray', true);\r\n   *\r\n   * @description\r\n   * This method retrieves an array value with the specified key from either sessionStorage or localStorage.\r\n   * Returns null if the key or stored value is invalid, or the retrieved array if successful.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n   */\n  static getArray(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key));\n    if (!Array.isArray(storedValue)) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an array.');\n      return null;\n    }\n    return storedValue;\n  }\n\n  /**\r\n    * Adds an element to an array stored with the specified key in either sessionStorage or localStorage.\r\n    *\r\n    * @param {string} key - The key of the array to which the element will be added.\r\n    * @param {any} element - The element to be added to the array.\r\n    * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n    * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n    *\r\n    * @return {void}\r\n    *\r\n    * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n    *\r\n    * @example\r\n    *  Example usage:\r\n    *  StorageManager.addToArray('myArray', 'newElement', true);\r\n    *\r\n    * @description\r\n    * This method adds an element to an array stored with the specified key in either sessionStorage or localStorage.\r\n    * Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n    */\n  static addToArray(key, element, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (!Array.isArray(JSON.parse(storedValue))) {\n      throw new Error(`Invalid stored value for key '${key}': Expected an array.`);\n    }\n    const arrayValue = JSON.parse(storedValue) || [];\n    arrayValue.push(element);\n    storage.setItem(key, JSON.stringify(arrayValue));\n    return this;\n  }\n\n  /**\r\n   * Updates an element in an array stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the array in which the element will be updated.\r\n   * @param {any} oldElement - The element to be updated.\r\n   * @param {any} newElement - The new value to replace the old element.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.updateInArray('myArray', 'oldValue', 'newValue', true);\r\n   *\r\n   * @description\r\n   * This method updates an element in an array stored with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n   */\n  static updateInArray(key, oldElement, newElement, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (!Array.isArray(JSON.parse(storedValue))) {\n      throw new Error(`Invalid stored value for key '${key}': Expected an array.`);\n    }\n    const arrayValue = JSON.parse(storedValue) || [];\n    const index = arrayValue.indexOf(oldElement);\n    if (index !== -1) {\n      arrayValue[index] = newElement;\n      storage.setItem(key, JSON.stringify(arrayValue));\n    }\n    return this;\n  }\n\n  /**\r\n   * Removes an element from an array stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the array from which the element will be removed.\r\n   * @param {any} element - The element to be removed from the array.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.removeElementFromArray('myArray', 'valueToRemove', true);\r\n   *\r\n   * @description\r\n   * This method removes an element from an array stored with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not an array.\r\n   */\n  static removeFromArray(key, element, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (!Array.isArray(JSON.parse(storedValue))) {\n      throw new Error(`Invalid stored value for key '${key}': Expected an array.`);\n    }\n    const arrayValue = JSON.parse(storedValue) || [];\n    const index = arrayValue.indexOf(element);\n    if (index !== -1) {\n      arrayValue.splice(index, 1);\n      storage.setItem(key, JSON.stringify(arrayValue));\n    }\n    return this;\n  }\n\n  /**\r\n   * Retrieves an element at the specified index from an array stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the array from which to retrieve the element.\r\n   * @param {number} index - The index of the element to retrieve.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {*} - Returns the element at the specified index if successful, or null if an error occurs.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string,\r\n   * if the stored value is not an array, or if the index is out of bounds.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const element = StorageManager.getFromArray('myArray', 0, true);\r\n   *\r\n   * @description\r\n   * This method retrieves an element at the specified index from an array stored with the specified key in either sessionStorage or localStorage.\r\n   * Returns the element at the specified index if successful, or null if an error occurs.\r\n   * Throws an error if the 'key' parameter is not a string, if the stored value is not an array, or if the index is out of bounds.\r\n   */\n  static getFromArray(key, index, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: index,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key));\n    if (!Array.isArray(storedValue)) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an array.');\n      return null;\n    }\n    if (index < 0 || index >= storedValue.length) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Index out of bounds.');\n      return null;\n    }\n    return storedValue[index];\n  }\n\n  /**\r\n   * Adds an element at the specified index in an array stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the array to which the element will be added.\r\n   * @param {*} element - The element to add to the array.\r\n   * @param {number} index - The index at which to add the element.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string,\r\n   * if the stored value is not an array, or if the index is out of bounds.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.addToArrayByIndex('myArray', 'newElement', 1, true);\r\n   *\r\n   * @description\r\n   * This method adds an element at the specified index in an array stored with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string, if the stored value is not an array, or if the index is out of bounds.\r\n   */\n  static addToArrayByIndex(key, element, index, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: index,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (!Array.isArray(JSON.parse(storedValue))) {\n      throw new Error(`Invalid stored value for key '${key}': Expected an array.`);\n    }\n    const arrayValue = JSON.parse(storedValue) || [];\n    if (index < 0 || index > arrayValue.length) {\n      throw new Error(`Index out of bounds for key '${key}'.`);\n    }\n    arrayValue.splice(index, 0, element);\n    storage.setItem(key, JSON.stringify(arrayValue));\n    return this;\n  }\n\n  /**\r\n   * Removes an entire array stored with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the array to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.removeArray('myArray', true);\r\n   *\r\n   * @description\r\n   * This method removes an entire array stored with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static removeArray(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.removeItem(key);\n  }\n\n  /**\r\n   * Removes all session or storage items containing arrays.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes items from sessionStorage; otherwise, removes items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing items.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.removeAllArrayItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all session or storage items containing arrays.\r\n   * Throws an error if an error occurs while removing items.\r\n   */\n  static removeAllArrayItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      const storedValue = storage.getItem(key);\n      try {\n        const parsedValue = JSON.parse(storedValue);\n        if (Array.isArray(parsedValue)) {\n          storage.removeItem(key);\n        }\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing item with key '${key}': ${error.message}`);\n      }\n    });\n  }\n\n  /**\r\n   * Sets a numeric value in either sessionStorage or localStorage, but only if the key does not exist.\r\n   *\r\n   * @param {string} key - The key to identify the stored value.\r\n   * @param {number} value - The value to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the value in sessionStorage; otherwise, stores the value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.setNumber('myCounter', 10, true);\r\n   */\n  static setNumber(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n\n    // Check if the key already exists\n    if (storage.getItem(key) === null) {\n      storage.setItem(key, JSON.stringify(value));\n      return this;\n    }\n  }\n\n  /**\r\n   * Retrieves a numeric value with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the numeric value to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {number|null} - Returns null if the key or stored value is invalid, or the retrieved numeric value if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a number.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const myNumber = StorageManager.getNumber('myNumber', true);\r\n   *\r\n   * @description\r\n   * This method retrieves a numeric value with the specified key from either sessionStorage or localStorage.\r\n   * Returns the numeric value if successful, or null if an error occurs.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a number.\r\n   */\n  static getNumber(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key));\n    if (typeof storedValue !== 'number') {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be a number.');\n      return null;\n    }\n    return storedValue;\n  }\n\n  /**\r\n   * Updates a numeric value with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key for updating the numeric value.\r\n   * @param {number} newValue - The new numeric value to be set.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a number.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.updateNumber('myNumber', 42);\r\n   *\r\n   * @description\r\n   * This method updates a numeric value with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a number.\r\n   */\n  static updateNumber(key, newValue, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: storedValue,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be a number.');\n      return;\n    }\n    storage.setItem(key, JSON.stringify(Number(newValue)));\n    return this;\n  }\n\n  /**\r\n   * Removes all session or storage items with numeric values.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes items from sessionStorage; otherwise, removes items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing items.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.removeNumericValues(true);\r\n   *\r\n   * @description\r\n   * This method removes all session or storage items with numeric values.\r\n   * Throws an error if an error occurs while removing items.\r\n   */\n  static removeNumericValues(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      const storedValue = storage.getItem(key);\n      if (!isNaN(storedValue)) {\n        try {\n          storage.removeItem(key);\n        } catch (error) {\n          _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing item with key '${key}': ${error.message}`);\n        }\n      }\n    });\n  }\n\n  /**\r\n   * Sets a boolean value for the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key for the boolean value.\r\n   * @param {boolean} value - The boolean value to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.setBoolean('myBoolean', true, true);\r\n   *\r\n   * @description\r\n   * This method sets a boolean value for the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static setBoolean(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isBoolean({\n      param: value,\n      throwOnError\n    })) {\n      {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n        return;\n      }\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.setItem(key, JSON.stringify(!!value));\n    return this;\n  }\n\n  /**\r\n   * Retrieves a boolean value with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the boolean value to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - Returns null if the key or stored value is invalid, or the retrieved boolean value if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a boolean.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const myBoolean = StorageManager.getBoolean('myBoolean', true);\r\n   *\r\n   * @description\r\n   * This method retrieves a boolean value with the specified key from either sessionStorage or localStorage.\r\n   * Returns null if the key or stored value is invalid, or the retrieved boolean value if successful.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a boolean.\r\n   */\n  static getBoolean(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = JSON.parse(storage.getItem(key));\n    if (typeof storedValue !== 'boolean' && storedValue !== null) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be a boolean.');\n      return null;\n    }\n    return storedValue;\n  }\n\n  /**\r\n   * Updates a boolean value for the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key for the boolean value.\r\n   * @param {boolean} value - The new boolean value to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a boolean.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.updateBoolean('myBoolean', false, true);\r\n   *\r\n   * @description\r\n   * This method updates a boolean value for the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a boolean.\r\n   */\n  static updateBoolean(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (typeof JSON.parse(storedValue) !== 'boolean' && storedValue !== null) {\n      throw new Error(`Invalid stored value for key '${key}': Expected a boolean.`);\n    }\n    storage.setItem(key, JSON.stringify(value));\n    return this;\n  }\n\n  /**\r\n   * Removes all session or storage items with boolean values.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes items from sessionStorage; otherwise, removes items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing items.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.removeAllBooleanItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all session or storage items with boolean values.\r\n   * Throws an error if an error occurs while removing items.\r\n   */\n  static removeAllBooleanItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      const storedValue = storage.getItem(key);\n      try {\n        if (typeof JSON.parse(storedValue) === 'boolean') {\n          storage.removeItem(key);\n        }\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing item with key '${key}': ${error.message}`);\n      }\n    });\n  }\n\n  /**\r\n   * Removes a boolean value stored in either sessionStorage or localStorage with the specified key.\r\n   *\r\n   * @param {string} key - The key of the boolean value to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the item from sessionStorage; otherwise, removes it from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing the boolean value.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // StorageManager.removeBoolean('myBool', true);\r\n   *\r\n   * @description\r\n   * This method removes a boolean value stored in either sessionStorage or localStorage with the specified key.\r\n   * Throws an error if an error occurs while removing the boolean value.\r\n   */\n  static removeBoolean(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      storage.removeItem(key);\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing boolean item with key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n  * Stores a string value with the specified key in either sessionStorage or localStorage.\r\n  *\r\n  * @param {string} key - The key under which to store the string value.\r\n  * @param {string} value - The string value to be stored.\r\n  * @param {boolean} [useSessionStorage=false] - If true, stores the item in sessionStorage; otherwise, stores it in localStorage.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n  *\r\n  * @return {void}\r\n  *\r\n  * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n  *\r\n  * @example\r\n  * // Example usage:\r\n  * // StorageManager.setString('myString', 'Hello, World!', true);\r\n  *\r\n  * @description\r\n  * This method stores a string value with the specified key in either sessionStorage or localStorage.\r\n  * Throws an error if the 'key' parameter is not a string.\r\n  */\n  static setString(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: value,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.setItem(key, value);\n    return this;\n  }\n\n  /**\r\n   * Retrieves a string value stored in either sessionStorage or localStorage with the specified key.\r\n   *\r\n   * @param {string} key - The key of the string value to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, retrieves the item from sessionStorage; otherwise, retrieves it from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {string|null} - Returns null if the key or stored value is invalid, or the retrieved string if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // const myString = StorageManager.getString('myString', true);\r\n   */\n  static getString(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    return storedValue;\n  }\n\n  /**\r\n   * Updates a string value stored in either sessionStorage or localStorage with the specified key.\r\n   *\r\n   * @param {string} key - The key of the string value to be updated.\r\n   * @param {string} value - The new string value to be set.\r\n   * @param {boolean} [useSessionStorage=false] - If true, updates the item in sessionStorage; otherwise, updates it in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // StorageManager.updateString('myString', 'New Value', true);\r\n   */\n  static updateString(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (storedValue !== null) {\n      storage.setItem(key, value);\n    }\n    return this;\n  }\n\n  /**\r\n   * Removes a string value stored in either sessionStorage or localStorage with the specified key.\r\n   *\r\n   * @param {string} key - The key of the string value to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the item from sessionStorage; otherwise, removes it from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // StorageManager.removeString('myString', true);\r\n   */\n  static removeString(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (storedValue !== null) {\n      storage.removeItem(key);\n    }\n  }\n\n  /**\r\n   * Removes all session or storage items with string values.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes items from sessionStorage; otherwise, removes items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing items.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // StorageManager.removeAllStringItems(true);\r\n   */\n  static removeAllStringItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      const storedValue = storage.getItem(key);\n      try {\n        JSON.parse(storedValue);\n      } catch (error) {\n        storage.removeItem(key);\n      }\n    });\n  }\n\n  /**\r\n   * Sets an expiration time for a value in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored value.\r\n   * @param {*} value - The value to be stored.\r\n   * @param {number} secondsToExpiration - The number of seconds until the value expires.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the value in sessionStorage; otherwise, stores the value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.setExpiration(\"exampleKey\", { data: \"example\" }, 10, true);\r\n   */\n  static setExpiration(key, value, secondsToExpiration, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: secondsToExpiration,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const expirationTime = secondsToExpiration ? Date.now() + secondsToExpiration * 1000 : null;\n    const storedValue = {\n      value,\n      expirationTime\n    };\n    try {\n      storage.setItem(key, JSON.stringify(storedValue));\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing value for key '${key}': ${error.message}`);\n    }\n    if (expirationTime) {\n      setTimeout(() => {\n        storage.removeItem(key);\n        console.log(`Value for key '${key}' has expired and been removed.`);\n      }, secondsToExpiration * 1000);\n    }\n    return this;\n  }\n\n  /**\r\n  * Retrieves a value with an expiration time from either sessionStorage or localStorage.\r\n  *\r\n  * @param {string} key - The key to identify the stored value.\r\n  * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n  *\r\n  * @return {Object|null} - Returns null if the key or stored value is invalid, or the retrieved value with expiration details if successful.\r\n  *\r\n  * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n  *\r\n  * @example\r\n  * Example usage:\r\n  * const storedData = StorageManager.getExpiration(\"exampleKey\", true);\r\n  * console.log(storedData);\r\n  *\r\n  * @description\r\n  * This method retrieves a value with an expiration time from either sessionStorage or localStorage.\r\n  * Returns null if the key or stored value is invalid, or the retrieved value with expiration details if successful.\r\n  * Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n  */\n  static getExpiration(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      const parsedValue = JSON.parse(storedValue);\n      if (!parsedValue || typeof parsedValue !== 'object') {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an object.');\n        return null;\n      }\n      const {\n        value,\n        expirationTime\n      } = parsedValue;\n      const now = Date.now();\n      const remainingTime = Math.max(0, expirationTime - now);\n      const countdown = new Date(remainingTime).toISOString().substr(11, 8);\n      return {\n        value,\n        expirationTime,\n        remainingTime,\n        countdown\n      };\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Invalid JSON format in stored value for key '${key}': ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\r\n   * Checks if a value stored in either sessionStorage or localStorage with the specified key has expired.\r\n   *\r\n   * @param {string} key - The key of the value to check for expiration.\r\n   * @param {boolean} [useSessionStorage=false] - If true, checks for expiration in sessionStorage; otherwise, checks for expiration in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean} - Returns true if the value has expired, false if it is still valid, or null if the key or stored value is invalid.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // const isExpired = StorageManager.checkExpiration('myKey', true);\r\n   */\n  static checkExpiration(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (storedValue !== null) {\n      const item = JSON.parse(storedValue);\n      const currentTime = Date.now();\n      if (item.expirationTime && currentTime > item.expirationTime) {\n        return true; // Value has expired\n      }\n      return false; // Value is still valid\n    }\n    return null; // Key or stored value is invalid\n  }\n\n  /**\r\n    * Clears all expired values from either sessionStorage or localStorage based on the specified key.\r\n    *\r\n    * @param {string} key - The key to identify the stored value.\r\n    * @param {boolean} [useSessionStorage=false] - If true, clears items from sessionStorage; otherwise, clears items from localStorage.\r\n    * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n    *\r\n    * @return {void}\r\n    *\r\n    * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n    *\r\n    * @example\r\n    * Example usage:\r\n    * StorageManager.clearExpiredValues(\"exampleKey\", true);\r\n    *\r\n    * @description\r\n    * This method clears all expired values from either sessionStorage or localStorage based on the specified key.\r\n    * Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n    */\n  static clearExpiredValues(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      const parsedValue = JSON.parse(storedValue);\n      if (!parsedValue || typeof parsedValue !== 'object') {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Stored value must be an object.');\n        return;\n      }\n      const {\n        expirationTime\n      } = parsedValue;\n      const now = Date.now();\n      if (expirationTime && expirationTime <= now) {\n        storage.removeItem(key);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Invalid JSON format in stored value for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Removes all items from sessionStorage or localStorage that have an associated expiration time.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes items from sessionStorage; otherwise, removes items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing items.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // StorageManager.removeAllTimingItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all items from sessionStorage or localStorage that have an associated expiration time.\r\n   * Throws an error if an error occurs while removing items.\r\n   */\n  static removeAllTimingItems(useSessionStorage = false) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      try {\n        const storedValue = JSON.parse(storage.getItem(key));\n        if (storedValue && typeof storedValue === 'object' && 'expirationTime' in storedValue) {\n          storage.removeItem(key);\n        }\n      } catch (error) {}\n    });\n  }\n\n  /**\r\n   * Increments the numeric value associated with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the value to be incremented.\r\n   * @param {number} incrementAmount - The amount by which to increment the value.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a number.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.incrementValue('myCounter', 5, true);\r\n   */\n  static incrementValue(key, incrementAmount, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isNumber({\n      param: storedValue,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Invalid stored value for key '${key}': Expected a number.`);\n      return;\n    }\n    const newValue = parseFloat(storedValue) + incrementAmount;\n    storage.setItem(key, newValue.toString());\n    return this;\n  }\n\n  /**\r\n   * Decrements the numeric value associated with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored numeric value.\r\n   * @param {number} [amount=1] - The amount to decrement the numeric value. Default is 1.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the value in sessionStorage; otherwise, stores the value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid numeric value.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.decrementValue('myCounter', 2, true);\r\n   */\n  static decrementValue(key, amount = 1, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      const numericValue = parseInt(storedValue, 10);\n      if (!isNaN(numericValue)) {\n        storage.setItem(key, (numericValue - amount).toString());\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Invalid numeric value for key '${key}'.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error decrementing value for key '${key}': ${error.message}`);\n    }\n    return this;\n  }\n\n  /**\r\n   * Retrieves all keys from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, retrieves keys from sessionStorage; otherwise, retrieves keys from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   *\r\n   * @return {Array} - An array containing all keys.\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while retrieving keys.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const allKeys = js.StorageManager.getAllKeys(true);\r\n   * console.log(allKeys); // Output: ['key1', 'key2', ...]\r\n   *\r\n   * @description\r\n   * This method retrieves all keys from either sessionStorage or localStorage.\r\n   * Throws an error if an error occurs while retrieving keys.\r\n   */\n  static getAllKeys(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      const keys = Object.keys(storage);\n      return keys;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error retrieving keys: ${error.message}`);\n      return [];\n    }\n  }\n\n  /**\r\n   * Retrieves all values from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, retrieves values from sessionStorage; otherwise, retrieves values from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   *\r\n   * @return {Array} - An array containing all values.\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while retrieving values.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const allValues = js.StorageManager.getAllValues(true);\r\n   * console.log(allValues); // Output: ['value1', 'value2', ...]\r\n   *\r\n   * @description\r\n   * This method retrieves all values from either sessionStorage or localStorage.\r\n   * Throws an error if an error occurs while retrieving values.\r\n   */\n  static getAllValues(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      const values = Object.values(storage);\n      return values;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error retrieving values: ${error.message}`);\n      return [];\n    }\n  }\n\n  /**\r\n   * Retrieves all key-value entries from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, retrieves entries from sessionStorage; otherwise, retrieves entries from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns an empty array.\r\n   *\r\n   * @return {Array} - An array containing all key-value entries as objects.\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while retrieving entries.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const allEntries = js.StorageManager.getAllEntries(true);\r\n   * console.log(allEntries); // Output: [{ key: 'key1', value: 'value1' }, { key: 'key2', value: 'value2' }, ...]\r\n   *\r\n   * @description\r\n   * This method retrieves all key-value entries from either sessionStorage or localStorage.\r\n   * Throws an error if an error occurs while retrieving entries.\r\n   */\n  static getAllEntries(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      const entries = Object.entries(storage).map(([key, value]) => ({\n        key,\n        value\n      }));\n      return entries;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error retrieving entries: ${error.message}`);\n      return [];\n    }\n  }\n\n  /**\r\n   * Retrieves information about the storage, including the total number of stored items and their total size in bytes.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, retrieves information from sessionStorage; otherwise, retrieves information from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {Object|null} - An object containing storage information or null if an error occurs.\r\n   *                       The object structure: { totalItems: number, totalSizeBytes: number }\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while retrieving storage information.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const storageInfo = js.StorageManager.getStorageInfo(true);\r\n   * console.log(storageInfo); // Output: { totalItems: 3, totalSizeBytes: 256 }\r\n   *\r\n   * @description\r\n   * This method retrieves information about the storage, including the total number of stored items and their total size in bytes.\r\n   * Throws an error if an error occurs while retrieving storage information.\r\n   */\n  static getStorageInfo(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      const totalItems = storage.length;\n      let totalSizeBytes = 0;\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i);\n        const value = storage.getItem(key);\n        totalSizeBytes += key.length + value.length;\n      }\n      return {\n        totalItems,\n        totalSizeBytes\n      };\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error retrieving storage information: ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\r\n   * Replaces the value of a stored key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the value to be replaced.\r\n   * @param {*} newValue - The new value to replace the existing one.\r\n   * @param {boolean} [useSessionStorage=false] - If true, replaces the value in sessionStorage; otherwise, replaces the value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.replaceValue('myKey', { data: 'newData' }, true);\r\n   *\r\n   * @description\r\n   * This method replaces the value of a stored key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not valid JSON.\r\n   */\n  static replaceValue(key, newValue, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      if (storedValue !== null) {\n        storage.setItem(key, JSON.stringify(newValue));\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `No stored value found for key '${key}'.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error replacing value for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Swaps the values between two stored keys in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key1 - The first key whose value will be swapped.\r\n   * @param {string} key2 - The second key whose value will be swapped.\r\n   * @param {boolean} [useSessionStorage=false] - If true, swaps the values in sessionStorage; otherwise, swaps the values in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if either 'key1' or 'key2' parameters are not strings or if the stored values are not valid JSON.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.swapValues('firstKey', 'secondKey', true);\r\n   *\r\n   * @description\r\n   * This method swaps the values between two stored keys in either sessionStorage or localStorage.\r\n   * Throws an error if either 'key1' or 'key2' parameters are not strings or if the stored values are not valid JSON.\r\n   */\n  static swapValues(key1, key2, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key1,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key2,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key1\" and \"key2\" must be strings.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const value1 = storage.getItem(key1);\n    const value2 = storage.getItem(key2);\n    try {\n      if (value1 !== null && value2 !== null) {\n        storage.setItem(key1, value2);\n        storage.setItem(key2, value1);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `No stored value found for one or both of the keys: '${key1}', '${key2}'.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error swapping values for keys '${key1}' and '${key2}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Sets a Map object with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored Map object.\r\n   * @param {Map} value - The Map object to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the Map object in sessionStorage; otherwise, stores the Map object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const myMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n   * js.StorageManager.setMap('myMap', myMap, true);\r\n   *\r\n   * @description\r\n   * This method sets a Map object with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Map object.\r\n   */\n  static setMap(key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, JSON.stringify([...value]));\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing Map for key '${key}': ${error.message}`);\n    }\n    return this;\n  }\n\n  /**\r\n   * Retrieves a Map object with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the Map object to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {Map|null} - Returns null if the key or stored value is invalid, or the retrieved Map object if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   * / Example usage:\r\n   * / const retrievedMap = js.StorageManager.getMap('myMap', true);\r\n   *\r\n   * @description\r\n   * This method retrieves a Map object with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the key or stored value is invalid or if the stored value is not a valid Map object.\r\n   */\n  static getMap(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      return storedValue ? new Map(JSON.parse(storedValue)) : null;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid JSON format in stored Map.');\n      return null;\n    }\n  }\n\n  /**\r\n   * Removes a Map object with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the Map object to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the Map object from sessionStorage; otherwise, removes the Map object from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.removeMap('myMap', true);\r\n   *\r\n   * @description\r\n   * This method removes a Map object with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the key parameter is not a string or if the stored value is not a valid Map object.\r\n   */\n  static removeMap(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.removeItem(key);\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing Map with key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Updates the key of an element in a Map object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} mapKey - The key of the Map object.\r\n   * @param {*} oldKey - The current key of the element to be updated.\r\n   * @param {*} newKey - The new key for the element.\r\n   * @param {boolean} [useSessionStorage=false] - If true, updates the Map object in sessionStorage; otherwise, updates the Map object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the parameters are invalid or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  StorageManager.updateKeyInMap('myMap', 'oldKey', 'newKey', true);\r\n   *\r\n   * @description\r\n   * This method updates the key of an element in a Map object stored with the specified key.\r\n   * If the provided 'oldKey' is found in the Map, it is replaced with the 'newKey'.\r\n   * If 'oldKey' is not found, an error is thrown.\r\n   */\n  static updateKeyInMap(mapKey, oldKey, newKey, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: mapKey,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: oldKey,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: newKey,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const map = this.getMap(mapKey, useSessionStorage, throwOnError);\n    if (map) {\n      if (map.has(oldKey)) {\n        const value = map.get(oldKey);\n        map.delete(oldKey);\n        map.set(newKey, value);\n        this.setMap(mapKey, map, useSessionStorage, throwOnError);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Element with key '${oldKey}' not found in Map.`);\n      }\n    }\n    return this;\n  }\n\n  /**\r\n   * Updates the key of an element in a Map object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} mapKey - The key of the Map object.\r\n   * @param {*} oldKey - The current key of the element to be updated.\r\n   * @param {*} newKey - The new key for the element.\r\n   * @param {boolean} [useSessionStorage=false] - If true, updates the Map object in sessionStorage; otherwise, updates the Map object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the parameters are invalid or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const myMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n   *  js.StorageManager.setMap('myMap', myMap, true);\r\n   *  js.StorageManager.updateKeyInMap('myMap', 'key1', 'name', true);\r\n   *\r\n   * @description\r\n   * This method updates the key of an element in a Map object stored with the specified key.\r\n   * If the provided 'oldKey' is found in the Map, it is replaced with the 'newKey'.\r\n   * If 'oldKey' is not found, an error is thrown.\r\n   */\n  static updateValueInMap(mapKey, key, newValue, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: mapKey,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const map = this.getMap(mapKey, useSessionStorage, throwOnError);\n    if (map) {\n      if (map.has(key)) {\n        map.set(key, newValue);\n        this.setMap(mapKey, map, useSessionStorage, throwOnError);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Element with key '${key}' not found in Map.`);\n      }\n    }\n    return this;\n  }\n\n  /**\r\n   * Removes an element from a Map object stored with the specified key by its key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} mapKey - The key of the Map object.\r\n   * @param {*} key - The key of the element to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the element from the Map object in sessionStorage; otherwise, removes the element from the Map object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the parameters are invalid or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.setMap('myMap', new Map([['key1', 'value1'], ['key2', 'value2']]), true);\r\n   * js.StorageManager.removeElementByKeyInMap('myMap', 'key1', true);\r\n   *\r\n   * @description\r\n   * This method removes an element from a Map object stored with the specified key by its key.\r\n   * Throws an error if the Map object or element with the specified key is not found.\r\n   */\n  static removeElementByKeyInMap(mapKey, key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: mapKey,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const map = this.getMap(mapKey, useSessionStorage, throwOnError);\n    if (map) {\n      if (map.has(key)) {\n        map.delete(key);\n        this.setMap(mapKey, map, useSessionStorage, throwOnError);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Element with key '${key}' not found in Map.`);\n      }\n    }\n    return this;\n  }\n\n  /**\r\n   * Removes an element from a Map object stored with the specified key by its key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} mapKey - The key of the Map object.\r\n   * @param {*} key - The key of the element to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the element from the Map object in sessionStorage; otherwise, removes the element from the Map object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the parameters are invalid or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const myMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n   *  js.StorageManager.setMap('myMap', myMap, true);\r\n   *  js.StorageManager.removeElementByKeyInMap('myMap', 'key1', true);\r\n   *\r\n   * @description\r\n   * This method removes an element from a Map object stored with the specified key by its key.\r\n   * If the provided 'key' is found in the Map, the element is removed.\r\n   * If 'key' is not found, an error is thrown.\r\n   */\n  static removeElementByValueInMap(mapKey, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: mapKey,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const map = this.getMap(mapKey, useSessionStorage, throwOnError);\n    if (map) {\n      const key = [...map].find(([k, v]) => v === value)?.[0];\n      if (key !== undefined) {\n        map.delete(key);\n        this.setMap(mapKey, map, useSessionStorage, throwOnError);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Element with value '${value}' not found in Map.`);\n      }\n    }\n    return this;\n  }\n\n  /**\r\n   * Adds an element into a Map object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} mapKey - The key of the Map object.\r\n   * @param {*} key - The key of the element to be added.\r\n   * @param {*} value - The value of the element to be added.\r\n   * @param {boolean} [useSessionStorage=false] - If true, adds the element into the Map object in sessionStorage; otherwise, adds the element into the Map object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the parameters are invalid or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const myMap = new Map([['key1', 'value1'], ['key2', 'value2']]);\r\n   *  js.StorageManager.setMap('myMap', myMap, true);\r\n   *  js.StorageManager.addIntoMap('myMap', 'key3', 'value3', true);\r\n   *\r\n   * @description\r\n   * This method adds an element into a Map object stored with the specified key.\r\n   * If the provided 'key' does not exist in the Map, the element is added.\r\n   * If 'key' already exists, an error is thrown.\r\n   */\n  static addIntoMap(mapKey, key, value, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: mapKey,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const map = this.getMap(mapKey, useSessionStorage, throwOnError);\n    if (map) {\n      if (!map.has(key)) {\n        map.set(key, value);\n        this.setMap(mapKey, map, useSessionStorage, throwOnError);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Element with key '${key}' already exists in Map.`);\n      }\n    }\n    return this;\n  }\n\n  /**\r\n   * Empties a Map object stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} mapKey - The key of the Map object.\r\n   * @param {boolean} [useSessionStorage=false] - If true, empties the Map object in sessionStorage; otherwise, empties the Map object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the parameters are invalid or if the stored value is not a valid Map object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.setMap('myMap', new Map([['key1', 'value1'], ['key2', 'value2']]), true);\r\n   *  js.StorageManager.emptyMap('myMap', true);\r\n   *\r\n   * @description\r\n   * This method empties a Map object stored with the specified key.\r\n   * If the Map object does not exist, an error is thrown.\r\n   */\n  static emptyMap(mapKey, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: mapKey,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const map = this.getMap(mapKey, useSessionStorage, throwOnError);\n    if (map) {\n      map.clear();\n      this.setMap(mapKey, map, useSessionStorage, throwOnError);\n    }\n  }\n\n  /**\r\n   * Removes all Map objects with their respective keys from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes Map objects from sessionStorage; otherwise, removes Map objects from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing Map objects.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.removeAllMapItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all Map objects with their respective keys from either sessionStorage or localStorage.\r\n   * Throws an error if an error occurs while removing Map objects.\r\n   */\n  static removeAllMapItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      try {\n        const storedValue = JSON.parse(storage.getItem(key));\n        if (storedValue instanceof Map) {\n          storage.removeItem(key);\n        }\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing Map with key '${key}': ${error.message}`);\n      }\n    });\n  }\n\n  /**\r\n   * Stores a Date object with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored Date object.\r\n   * @param {Date} date - The Date object to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the Date object in sessionStorage; otherwise, stores the Date object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Date object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const currentDate = new Date();\r\n   *  js.StorageManager.setDate('myDate', currentDate, true);\r\n   *\r\n   * @description\r\n   * This method stores a Date object with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Date object.\r\n   */\n  static setDate(key, date, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, date.toISOString());\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing Date for key '${key}': ${error.message}`);\n    }\n    return this;\n  }\n\n  /**\r\n    * Retrieves a Date object with the specified key from either sessionStorage or localStorage.\r\n    *\r\n    * @param {string} key - The key of the Date object to be retrieved.\r\n    * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n    * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n    *\r\n    * @return {Date|null} - Returns null if the key or stored value is invalid, or the retrieved Date object if successful.\r\n    *\r\n    * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Date object.\r\n    *\r\n    * @example\r\n    *  Example usage:\r\n    *  const retrievedDate = js.StorageManager.getDate('myDate', true);\r\n    *\r\n    * @description\r\n    * This method retrieves a Date object with the specified key from either sessionStorage or localStorage.\r\n    * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Date object.\r\n    */\n  static getDate(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      return storedValue ? new Date(storedValue) : null;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid Date format in stored value.');\n      return null;\n    }\n  }\n\n  /**\r\n   * Removes a Date object with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the Date object to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the Date object from sessionStorage; otherwise, removes the Date object from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Date object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.removeDate('myDate', true);\r\n   *\r\n   * @description\r\n   * This method removes a Date object with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid Date object.\r\n   */\n  static removeDate(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.removeItem(key);\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing Date with key '${key}': ${error.message}`);\n    }\n    return this;\n  }\n\n  /**\r\n   * Removes all Date objects with their respective keys from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes Date objects from sessionStorage; otherwise, removes Date objects from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if an error occurs while removing Date objects.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.removeAllDateItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all Date objects with their respective keys from either sessionStorage or localStorage.\r\n   * Throws an error if an error occurs while removing Date objects.\r\n   */\n  static removeAllDateItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    Object.keys(storage).forEach(key => {\n      try {\n        const storedValue = JSON.parse(storage.getItem(key));\n        if (storedValue instanceof Date) {\n          storage.removeItem(key);\n        }\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing Date with key '${key}': ${error.message}`);\n      }\n    });\n  }\n\n  /**\r\n   * Stores a function with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored function.\r\n   * @param {Function} func - The function to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the function in sessionStorage; otherwise, stores the function in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string, or if the stored value is not a valid function, or if 'func' is not a function.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const myFunction = () => console.log(\"Hello, World!\");\r\n   *  js.StorageManager.setFunction('myFunction', myFunction, true);\r\n   *\r\n   * @description\r\n   * This method stores a function with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string, or if the stored value is not a valid function, or if 'func' is not a function.\r\n   */\n  static setFunction(key, func, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    }) || !_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isFunction({\n      param: func,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string and \"func\" must be a function.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, func.toString());\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing function for key '${key}': ${error.message}`);\n    }\n    return this;\n  }\n\n  /**\r\n   * Retrieves a function with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the function to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {Function|null} - Returns null if the key or stored value is invalid, or the retrieved function if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string, or if the stored value is not a valid function.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const retrievedFunction = js.StorageManager.getFunction('myFunction', true);\r\n   */\n  static getFunction(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      return storedValue ? new Function(`return ${storedValue}`)() : null;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid function format in stored value.');\n      return null;\n    }\n  }\n\n  /**\r\n   * Removes a function with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the function to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the function from sessionStorage; otherwise, removes the function from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string, or if the stored value is not a valid function.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.removeFunction('myFunction', true);\r\n   */\n  static removeFunction(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.removeItem(key);\n  }\n\n  /**\r\n   * Stores a RegExp object with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored RegExp object.\r\n   * @param {RegExp} regExp - The RegExp object to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the RegExp object in sessionStorage; otherwise, stores the RegExp object in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the value is not a RegExp object; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the value is not a RegExp object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const myRegExp = new RegExp('pattern');\r\n   *  js.StorageManager.setRegExp('myKey', myRegExp, true);\r\n   *\r\n   * @description\r\n   * This method stores a RegExp object with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the value is not a RegExp object.\r\n   */\n  static setRegExp(key, regExp, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    if (!(regExp instanceof RegExp)) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameter: \"regExp\" must be a RegExp object.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, regExp.toString());\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing RegExp for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Retrieves a RegExp object with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the RegExp object to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid RegExp object; otherwise, returns null.\r\n   *\r\n   * @return {RegExp|null} - Returns null if the key or stored value is invalid or if the stored value is not a valid RegExp object, or the retrieved RegExp object if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid RegExp object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const retrievedRegExp = js.StorageManager.getRegExp('myRegExp', true);\r\n   *\r\n   * @description\r\n   * This method retrieves a RegExp object with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid RegExp object.\r\n   */\n  static getRegExp(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      const regex = new RegExp(storedValue);\n      if (Object.prototype.toString.call(regex) === '[object RegExp]') {\n        return regex;\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid RegExp format in stored value.');\n        return null;\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid RegExp format in stored value.');\n      return null;\n    }\n  }\n\n  /**\r\n   * Removes a RegExp object with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the RegExp object to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the RegExp object from sessionStorage; otherwise, removes the RegExp object from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid RegExp object; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string, or if the stored value is not a valid RegExp object.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   * js.StorageManager.removeRegExp('myRegExp', true);\r\n   * \r\n   * @description\r\n   * This method removes a RegExp object with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid RegExp object.\r\n   * If successful, it removes the stored RegExp object; otherwise, it throws an error.\r\n   *\r\n   */\n  static removeRegExp(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      // Check if the stored value is a string and represents a valid RegExp pattern\n      if (typeof storedValue === 'string' && /^\\/.*\\/[gim]*$/.test(storedValue)) {\n        storage.removeItem(key);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid RegExp object.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing RegExp for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Removes all stored RegExp objects from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes RegExp objects from sessionStorage; otherwise, removes RegExp objects from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for any encountered issues; otherwise, continues with the removal process.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if there is an issue removing RegExp objects.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.removeAllRegExpItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all stored RegExp objects from either sessionStorage or localStorage.\r\n   * If successful, it removes RegExp objects based on a basic pattern format check.\r\n   * Throws an error if there is an issue removing RegExp objects.\r\n   */\n  static removeAllRegExpItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      // Iterate through all keys in storage\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i);\n        const storedValue = storage.getItem(key);\n\n        // Check if the stored value is a string and represents a valid RegExp pattern\n        if (typeof storedValue === 'string' && /^\\/.*\\/[gim]*$/.test(storedValue)) {\n          storage.removeItem(key);\n        }\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing RegExp objects: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Stores an 'undefined' value with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored 'undefined' value.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the 'undefined' value in sessionStorage; otherwise, stores the 'undefined' value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.setUndefined('myUndefinedKey', true);\r\n   *\r\n   * @description\r\n   * This method stores an 'undefined' value with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static setUndefined(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, undefined);\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing 'undefined' value for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Checks if the value associated with the specified key is 'undefined' in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the value to be checked.\r\n   * @param {boolean} [useSessionStorage=false] - If true, checks for the value in sessionStorage; otherwise, checks for the value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - Returns true if the value associated with the key is 'undefined'; otherwise, returns false. Returns null if the key or stored value is invalid.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * const isValueUndefined = js.StorageManager.isUndefined('myUndefinedKey', true);\r\n   */\n  static isUndefined(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    return storedValue === undefined;\n  }\n\n  /**\r\n   * Removes a value associated with the specified key if it is 'undefined' from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the value to be removed if it is 'undefined'.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the value from sessionStorage; otherwise, removes the value from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.removeUndefined('myUndefinedKey', true);\r\n   *\r\n   * @description\r\n   * This method removes a value associated with the specified key from either sessionStorage or localStorage if it is 'undefined'.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static removeUndefined(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (storedValue === undefined) {\n      try {\n        storage.removeItem(key);\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing 'undefined' value for key '${key}': ${error.message}`);\n      }\n    }\n  }\n\n  /**\r\n   * Removes all values with keys associated with 'undefined' values from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the values from sessionStorage; otherwise, removes the values from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for any encountered error during the removal process; otherwise, continues with the removal process.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if any encountered error during the removal process and 'throwOnError' is set to true.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.removeAllUndefined(true);\r\n   *\r\n   * @description\r\n   * This method removes all values with keys associated with 'undefined' values from either sessionStorage or localStorage.\r\n   * Throws an error if any encountered error during the removal process and 'throwOnError' is set to true.\r\n   */\n  static removeAllUndefined(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i);\n        const storedValue = storage.getItem(key);\n        if (storedValue === undefined) {\n          storage.removeItem(key);\n          i--; // Adjust the index to account for removal\n        }\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing values associated with 'undefined' keys: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Stores a 'null' value with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored 'null' value.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the 'null' value in sessionStorage; otherwise, stores the 'null' value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.setNull('myKey', true);\r\n   *\r\n   * @description\r\n   * This method stores a 'null' value with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string.\r\n   */\n  static setNull(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, 'null');\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing 'null' for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Checks if a 'null' value is stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the stored value.\r\n   * @param {boolean} [useSessionStorage=false] - If true, checks for the 'null' value in sessionStorage; otherwise, checks for the 'null' value in localStorage.\r\n   *\r\n   * @return {boolean} - Returns true if a 'null' value is stored with the specified key; otherwise, returns false.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const isNullValue = js.StorageManager.isNull('myKey', true);\r\n   */\n  static isNull(key, useSessionStorage = false) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    return storedValue === 'null';\n  }\n\n  /**\r\n   * Removes a 'null' value with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the 'null' value to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the 'null' value from sessionStorage; otherwise, removes the 'null' value from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a 'null' value.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.removeNull('myKey', true);\r\n   */\n  static removeNull(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    if (storedValue === 'null') {\n      storage.removeItem(key);\n    } else {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a 'null' value.`);\n    }\n  }\n\n  /**\r\n   * Removes all 'null' values stored in either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes all 'null' values from sessionStorage; otherwise, removes all 'null' values from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for any unexpected issues; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if any unexpected issues occur during the removal process.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.removeAllNullItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all 'null' values stored in either sessionStorage or localStorage.\r\n   * Throws an error if any unexpected issues occur during the removal process.\r\n   */\n  static removeAllNullItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i);\n        const storedValue = storage.getItem(key);\n        if (storedValue === 'null') {\n          storage.removeItem(key);\n          // Adjust index to account for removal\n          i--;\n        }\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing 'null' values: ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Stores a BigInt with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored BigInt.\r\n   * @param {BigInt} bigInt - The BigInt to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the BigInt in sessionStorage; otherwise, stores the BigInt in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid BigInt; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid BigInt.\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * const myBigInt = BigInt('12345678901234567890');\r\n   * js.StorageManager.setBigInt('myKey', myBigInt, true);\r\n   *\r\n   * @description\r\n   * This method stores a BigInt with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid BigInt.\r\n   */\n  static setBigInt(key, bigInt, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    if (typeof bigInt !== 'bigint') {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid BigInt value.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, bigInt.toString());\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing BigInt for key '${key}': ${error.message}`);\n    }\n    return this;\n  }\n\n  /**\r\n   * Retrieves a BigInt with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the BigInt to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid BigInt; otherwise, returns null.\r\n   *\r\n   * @return {BigInt|null} - Returns null if the key or stored value is invalid or if the stored value is not a valid BigInt, or the retrieved BigInt if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid BigInt.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const retrievedBigInt = js.StorageManager.getBigInt('myKey', true);\r\n   *\r\n   * @description\r\n   * This method retrieves a BigInt with the specified key from either sessionStorage or localStorage.\r\n   * If successful, it returns the retrieved BigInt; otherwise, it returns null.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid BigInt.\r\n   */\n  static getBigInt(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      const retrievedBigInt = storedValue ? BigInt(storedValue) : null;\n      if (retrievedBigInt !== null && typeof retrievedBigInt === 'bigint') {\n        return retrievedBigInt;\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid BigInt.`);\n        return null;\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error retrieving BigInt for key '${key}': ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\r\n   * Removes a BigInt with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the BigInt to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the BigInt from sessionStorage; otherwise, removes the BigInt from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid BigInt.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  js.StorageManager.removeBigInt('myKey', true);\r\n   * \r\n   * @description\r\n   * This method removes a BigInt with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid BigInt\r\n   */\n  static removeBigInt(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      const retrievedBigInt = storedValue ? BigInt(storedValue) : null;\n      if (retrievedBigInt !== null && typeof retrievedBigInt === 'bigint') {\n        storage.removeItem(key);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid BigInt.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing BigInt for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Removes all stored BigInt items from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes BigInt items from sessionStorage; otherwise, removes BigInt items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid items; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if any stored value is not a valid BigInt.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.removeAllBigIntItems(true);\r\n   * \r\n   * @description\r\n   * This method removes all stored BigInt items from either sessionStorage or localStorage.\r\n   * Throws an error if any stored value is not a valid BigInt.\r\n   */\n  static removeAllBigIntItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    for (let i = 0; i < storage.length; i++) {\n      const key = storage.key(i);\n      const storedValue = storage.getItem(key);\n      try {\n        const retrievedBigInt = storedValue ? BigInt(storedValue) : null;\n        if (retrievedBigInt !== null && typeof retrievedBigInt === 'bigint') {\n          storage.removeItem(key);\n        } else {\n          _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid BigInt.`);\n        }\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing BigInt for key '${key}': ${error.message}`);\n      }\n    }\n  }\n\n  /**\r\n   * Stores binary data with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored binary data.\r\n   * @param {Uint8Array} binaryData - The binary data to be stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the binary data in sessionStorage; otherwise, stores the binary data in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not valid binary data; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not valid binary data.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const myBinaryData = new Uint8Array([1, 2, 3, 4, 5]);\r\n   * js.StorageManager.setBinary('myKey', myBinaryData, true);\r\n   *\r\n   * @description\r\n   * This method stores binary data with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not valid binary data.\r\n   */\n  static setBinary(key, binaryData, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    if (!(binaryData instanceof Uint8Array)) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid binary data: It must be a Uint8Array.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      storage.setItem(key, JSON.stringify(Array.from(binaryData)));\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error storing binary data for key '${key}': ${error.message}`);\n    }\n    return this;\n  }\n\n  /**\r\n   * Retrieves binary data with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the binary data to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not valid binary data; otherwise, returns null.\r\n   *\r\n   * @return {Uint8Array|null} - Returns null if the key or stored value is invalid or if the stored value is not valid binary data, or the retrieved binary data if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string, if the stored value is not valid binary data, or if the stored value is not a Uint8Array.\r\n   *\r\n   * @example\r\n   *  Example usage:\r\n   *  const retrievedBinaryData = js.StorageManager.getBinary('myKey', true);\r\n   *\r\n   * @description\r\n   * This method retrieves binary data with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string, if the stored value is not valid binary data, or if the stored value is not a Uint8Array.\r\n   */\n  static getBinary(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      if (typeof storedValue === 'string') {\n        const parsedArray = JSON.parse(storedValue);\n        const binaryData = new Uint8Array(parsedArray);\n        if (binaryData instanceof Uint8Array) {\n          return binaryData;\n        } else {\n          _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid binary data.`);\n          return null;\n        }\n      }\n      return null;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid binary data format in stored value.');\n      return null;\n    }\n  }\n\n  /**\r\n  * Removes binary data with the specified key from either sessionStorage or localStorage.\r\n  *\r\n  * @param {string} key - The key of the binary data to be removed.\r\n  * @param {boolean} [useSessionStorage=false] - If true, removes the binary data from sessionStorage; otherwise, removes the binary data from localStorage.\r\n  * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not valid binary data; otherwise, returns null.\r\n  *\r\n  * @return {void}\r\n  *\r\n  * @throws {Error} - Throws an error if the 'key' parameter is not a string, if the stored value is not valid binary data, or if the stored value is not a Uint8Array.\r\n  *\r\n  * @example\r\n  *  Example usage:\r\n  *  js.StorageManager.removeBinary('myKey', true);\r\n  *\r\n  * @description\r\n  * This method removes binary data with the specified key from either sessionStorage or localStorage.\r\n  * Throws an error if the 'key' parameter is not a string, if the stored value is not valid binary data, or if the stored value is not a Uint8Array.\r\n  */\n  static removeBinary(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      if (typeof storedValue === 'string') {\n        const parsedArray = JSON.parse(storedValue);\n        const binaryData = new Uint8Array(parsedArray);\n        if (binaryData instanceof Uint8Array) {\n          storage.removeItem(key);\n        } else {\n          _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid binary data.`);\n        }\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not valid binary data.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing binary data for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Removes all binary data items from either sessionStorage or localStorage.\r\n   *\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes all binary data items from sessionStorage; otherwise, removes all binary data items from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for any invalid values; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if any stored value is not valid binary data or if any stored value is not a Uint8Array.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * js.StorageManager.removeAllBinaryItems(true);\r\n   *\r\n   * @description\r\n   * This method removes all binary data items from either sessionStorage or localStorage.\r\n   * Throws an error if any stored value is not valid binary data or if any stored value is not a Uint8Array.\r\n   */\n  static removeAllBinaryItems(useSessionStorage = false, throwOnError = true) {\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    for (let i = 0; i < storage.length; i++) {\n      const key = storage.key(i);\n      const storedValue = storage.getItem(key);\n      try {\n        if (typeof storedValue === 'string') {\n          const parsedArray = JSON.parse(storedValue);\n          const binaryData = new Uint8Array(parsedArray);\n          if (!(binaryData instanceof Uint8Array)) {\n            _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid binary data.`);\n          }\n        } else {\n          _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not valid binary data.`);\n        }\n      } catch (error) {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing binary data for key '${key}': ${error.message}`);\n      }\n    }\n    storage.clear();\n  }\n\n  /**\r\n   * Stores an encrypted string with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored encrypted string.\r\n   * @param {string} data - The string to be encrypted and stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the encrypted string in sessionStorage; otherwise, stores it in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if encryption fails; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if encryption fails.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const sensitiveData = 'This is a secret';\r\n   * StorageManager.setEncrypted('myKey', sensitiveData, true);\r\n   *\r\n   * @description\r\n   * This method stores an encrypted string with the specified key in either sessionStorage or localStorage.\r\n   * It uses the AES encryption algorithm from the crypto-js library. Throws an error if the 'key' parameter is not a string or if encryption fails.\r\n   */\n  static setEncrypted(key, data, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const encryptedData = crypto_js__WEBPACK_IMPORTED_MODULE_1___default().AES.encrypt(data, 'your-secret-key').toString();\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.setItem(key, encryptedData);\n    return this;\n  }\n\n  /**\r\n   * Retrieves the decrypted string with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the encrypted string to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if decryption fails; otherwise, returns null.\r\n   *\r\n   * @return {string|null} - Returns null if the key or stored value is invalid or if decryption fails, or the decrypted string if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if decryption fails.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const decryptedData = StorageManager.getDecrypted('myKey', true);\r\n   *\r\n   * @description\r\n   * This method retrieves the decrypted string with the specified key from either sessionStorage or localStorage.\r\n   * It uses the AES decryption algorithm from the crypto-js library. Returns null if the key or stored value is invalid or if decryption fails.\r\n   * Throws an error if the 'key' parameter is not a string or if decryption fails.\r\n   */\n  static getDecrypted(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const encryptedValue = storage.getItem(key);\n    try {\n      const decryptedData = encryptedValue ? crypto_js__WEBPACK_IMPORTED_MODULE_1___default().AES.decrypt(encryptedValue, 'your-secret-key').toString((crypto_js__WEBPACK_IMPORTED_MODULE_1___default().enc).Utf8) : null;\n      return decryptedData;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Error during decryption. Invalid encrypted value or key.');\n      return null;\n    }\n  }\n\n  /**\r\n   * Removes an encrypted string with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the encrypted string to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the encrypted string from sessionStorage; otherwise, removes it from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid encrypted string; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid encrypted string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.removeEncrypted('myKey', true);\r\n   *\r\n   * @description\r\n   * This method removes an encrypted string with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid encrypted string.\r\n   */\n  static removeEncrypted(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const encryptedValue = storage.getItem(key);\n    try {\n      crypto_js__WEBPACK_IMPORTED_MODULE_1___default().AES.decrypt(encryptedValue, 'your-secret-key').toString((crypto_js__WEBPACK_IMPORTED_MODULE_1___default().enc).Utf8);\n      storage.removeItem(key);\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing encrypted string for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Stores a hashed string with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored hashed string.\r\n   * @param {string} data - The string to be hashed and stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the hashed string in sessionStorage; otherwise, stores it in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if hashing fails; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if hashing fails.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const sensitiveData = 'This is a secret';\r\n   * StorageManager.setHashed('myKey', sensitiveData, true);\r\n   *\r\n   * @description\r\n   * This method stores a hashed string with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if hashing fails.\r\n   */\n  static setHashed(key, data, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n\n    // Hash the data\n    const hashedData = crypto_js__WEBPACK_IMPORTED_MODULE_1___default().SHA256(data).toString((crypto_js__WEBPACK_IMPORTED_MODULE_1___default().enc).Hex);\n\n    // Store the hashed data\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.setItem(key, hashedData);\n    return this;\n  }\n\n  /**\r\n   * Retrieves a hashed string with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the hashed string to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid hashed string; otherwise, returns null.\r\n   *\r\n   * @return {string|null} - Returns null if the key or stored value is invalid or if the stored value is not a valid hashed string, or the retrieved hashed string if successful.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid hashed string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const retrievedHashedData = StorageManager.getHashed('myKey', true);\r\n   *\r\n   * @description\r\n   * This method retrieves a hashed string with the specified key from either sessionStorage or localStorage.\r\n   * If successful, it returns the retrieved hashed string; otherwise, it returns null.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid hashed string.\r\n   */\n  static getHashed(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const storedValue = storage.getItem(key);\n    try {\n      if (storedValue && /^[a-f0-9]{64}$/i.test(storedValue)) {\n        return storedValue ? storedValue : null;\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid hashed string.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid hashed string format in stored value.');\n      return null;\n    }\n  }\n\n  /**\r\n   * Removes a hashed string with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the hashed string to be removed.\r\n   * @param {boolean} [useSessionStorage=false] - If true, removes the hashed string from sessionStorage; otherwise, removes it from localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid hashed string; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid hashed string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * StorageManager.removeHashed('myKey', true);\r\n   *\r\n   * @description\r\n   * This method removes a hashed string with the specified key from either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid hashed string.\r\n   */\n  static removeHashed(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    try {\n      const storedValue = storage.getItem(key);\n\n      // Check if the stored value is a valid hashed string\n      if (storedValue && /^[a-f0-9]{64}$/i.test(storedValue)) {\n        storage.removeItem(key);\n      } else {\n        _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Value stored for key '${key}' is not a valid hashed string.`);\n      }\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error removing hashed string for key '${key}': ${error.message}`);\n    }\n  }\n\n  /**\r\n   * Compares a string with a hashed value stored with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the hashed string to be compared.\r\n   * @param {string} data - The string to be compared with the stored hashed value.\r\n   * @param {boolean} [useSessionStorage=false] - If true, compares the string with the hashed value in sessionStorage; otherwise, compares it with the hashed value in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid hashed string; otherwise, returns null.\r\n   *\r\n   * @return {boolean|null} - Returns true if the string matches the stored hashed value, false if they do not match, or null if there is an error or the stored value is not a valid hashed string.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid hashed string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const isMatch = StorageManager.compareHashed('myKey', 'myString', true);\r\n   *\r\n   * @description\r\n   * This method compares a string with a hashed value stored with the specified key in either sessionStorage or localStorage.\r\n   * Returns true if the string matches the stored hashed value, false if they do not match, or null if there is an error or the stored value is not a valid hashed string.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid hashed string.\r\n   */\n  static compareHashed(key, data, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n\n    // Retrieve the hashed value from storage\n    const storedHashedValue = this.getHashed(key, useSessionStorage, throwOnError);\n    try {\n      // Compare the input string with the stored hashed value\n      if (storedHashedValue) {\n        const inputHashedValue = crypto_js__WEBPACK_IMPORTED_MODULE_1___default().SHA256(data).toString((crypto_js__WEBPACK_IMPORTED_MODULE_1___default().enc).Hex);\n        return inputHashedValue === storedHashedValue;\n      }\n      return null;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error comparing hashed string for key '${key}': ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\r\n   * Stores a compressed string with the specified key in either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key to identify the stored compressed string.\r\n   * @param {string} data - The string to be compressed and stored.\r\n   * @param {boolean} [useSessionStorage=false] - If true, stores the compressed string in sessionStorage; otherwise, stores it in localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if compression fails; otherwise, returns null.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if compression fails.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const dataToCompress = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';\r\n   * StorageManager.setCompressed('myKey', dataToCompress, true);\r\n   *\r\n   * @description\r\n   * This method stores a compressed string with the specified key in either sessionStorage or localStorage.\r\n   * Throws an error if the 'key' parameter is not a string or if compression fails.\r\n   */\n  static setCompressed(key, data, useSessionStorage = false, throwOnError = true) {\n    // Check key validity\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return;\n    }\n\n    // Compress the data\n    const compressedData = lz_string__WEBPACK_IMPORTED_MODULE_2___default().compress(data);\n\n    // Store the compressed data\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    storage.setItem(key, compressedData);\n  }\n\n  /**\r\n   * Retrieves a decompressed string with the specified key from either sessionStorage or localStorage.\r\n   *\r\n   * @param {string} key - The key of the compressed string to be retrieved.\r\n   * @param {boolean} [useSessionStorage=false] - If true, uses sessionStorage; otherwise, uses localStorage.\r\n   * @param {boolean} [throwOnError=true] - If true, throws an error for invalid parameters or if the stored value is not a valid compressed string; otherwise, returns null.\r\n   *\r\n   * @return {string|null} - Returns the decompressed string if successful, or null if there is an error or the stored value is not a valid compressed string.\r\n   *\r\n   * @throws {Error} - Throws an error if the 'key' parameter is not a string or if the stored value is not a valid compressed string.\r\n   *\r\n   * @example\r\n   * Example usage:\r\n   * const decompressedData = StorageManager.getCompressed('myKey', true);\r\n   * console.log(decompressedData);\r\n   *\r\n   * @description\r\n   * This method retrieves a decompressed string with the specified key from either sessionStorage or localStorage.\r\n   * If successful, it returns the decompressed string; otherwise, it returns null.\r\n   * Throws an error if the 'key' parameter is not a string or if the stored value is not a valid compressed string.\r\n   */\n  static getCompressed(key, useSessionStorage = false, throwOnError = true) {\n    if (!_validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.isString({\n      param: key,\n      throwOnError\n    })) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, 'Invalid parameters: \"key\" must be a string.');\n      return null;\n    }\n\n    // Retrieve the compressed data from storage\n    const storage = useSessionStorage ? sessionStorage : localStorage;\n    const compressedData = storage.getItem(key);\n    try {\n      // Decompress the data\n      return compressedData ? lz_string__WEBPACK_IMPORTED_MODULE_2___default().decompress(compressedData) : null;\n    } catch (error) {\n      _validation_validation_js__WEBPACK_IMPORTED_MODULE_0__.DomValidator.throwOrReturnOnError(throwOnError, `Error decompressing string for key '${key}': ${error.message}`);\n      return null;\n    }\n  }\n\n  /**\r\n   * Logs all the available static functions in the StorageManager class to the console.\r\n   *\r\n   * @return {void}\r\n   *\r\n   * @example\r\n   * // Example usage:\r\n   * // StorageManager.logAvailableFunctions();\r\n   *\r\n   * @description\r\n   * This method logs all the available static functions in the StorageManager class to the console.\r\n   */\n  static logAvailableFunctions() {\n    const functionNames = Object.getOwnPropertyNames(StorageManager).filter(name => typeof StorageManager[name] === 'function' && name !== 'length' && name !== 'name' && name !== 'prototype');\n    console.log(`Available static functions in StorageManager class:`);\n    functionNames.forEach(name => console.log(`- ${name}`));\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./src/storage-Manager/storageManager,.js?");

/***/ }),

/***/ "./src/validation/validation.js":
/*!**************************************!*\
  !*** ./src/validation/validation.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DomValidator: () => (/* binding */ DomValidator)\n/* harmony export */ });\n/* harmony import */ var joi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! joi */ \"./node_modules/joi/dist/joi-browser.min.js\");\n/* harmony import */ var joi__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(joi__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * -----------------------------------------------\r\n * Parameter Validator Class\r\n * --------------------------------------------\r\n * Handles input validation forHandler methods\r\n */\n\n\nclass DomValidator {\n  /**\r\n   * Validates parameters against a given Joi schema.\r\n   * @param {Object} schema - The Joi schema to validate against.\r\n   * @param {Object} params - The parameters to validate.\r\n   * @param {boolean} throwOnError - Whether to throw an error if validation fails. Default is true.\r\n   * @returns {boolean} True if validation passes.\r\n   * @throws {Error} If validation fails and throwOnError is true.\r\n   */\n\n  static validateParams = (schema, params, throwOnError = true) => {\n    const {\n      error\n    } = schema.validate(params);\n    if (error) {\n      if (throwOnError) {\n        throw new Error(`Invalid parameters: ${error.details[0].message}`);\n      } else {\n        return false;\n      }\n    }\n    return true;\n  };\n  static isString = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().string().required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  };\n  static isObject = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().object().required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  };\n  static isNumber = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().number().required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  };\n  static isBoolean = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  };\n  static existInArray = (params, array, def) => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().string().valid(...array).default(def),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  };\n  static isArray = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().array().required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  };\n  static isFunction = params => {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().func().required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  };\n  static isStringOrNull(params) {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().string().allow(null).required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  }\n  static isObjectOrNull(params) {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().object().allow(null).required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  }\n  static isArrayOfObjects(params) {\n    const schema = joi__WEBPACK_IMPORTED_MODULE_0___default().object({\n      param: joi__WEBPACK_IMPORTED_MODULE_0___default().array().items(joi__WEBPACK_IMPORTED_MODULE_0___default().object()).required(),\n      throwOnError: joi__WEBPACK_IMPORTED_MODULE_0___default().boolean().required()\n    });\n    return this.validateParams(schema, params, params.throwOnError);\n  }\n  static throwOrReturnOnError = (throwOnError, message) => {\n    if (throwOnError) {\n      throw new Error(message);\n    } else {\n      return null;\n    }\n  };\n}\n\n\n//# sourceURL=webpack://js.package/./src/validation/validation.js?");

/***/ }),

/***/ "./node_modules/crypto-js/aes.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/aes.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Lookup tables\n\t    var SBOX = [];\n\t    var INV_SBOX = [];\n\t    var SUB_MIX_0 = [];\n\t    var SUB_MIX_1 = [];\n\t    var SUB_MIX_2 = [];\n\t    var SUB_MIX_3 = [];\n\t    var INV_SUB_MIX_0 = [];\n\t    var INV_SUB_MIX_1 = [];\n\t    var INV_SUB_MIX_2 = [];\n\t    var INV_SUB_MIX_3 = [];\n\n\t    // Compute lookup tables\n\t    (function () {\n\t        // Compute double table\n\t        var d = [];\n\t        for (var i = 0; i < 256; i++) {\n\t            if (i < 128) {\n\t                d[i] = i << 1;\n\t            } else {\n\t                d[i] = (i << 1) ^ 0x11b;\n\t            }\n\t        }\n\n\t        // Walk GF(2^8)\n\t        var x = 0;\n\t        var xi = 0;\n\t        for (var i = 0; i < 256; i++) {\n\t            // Compute sbox\n\t            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n\t            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n\t            SBOX[x] = sx;\n\t            INV_SBOX[sx] = x;\n\n\t            // Compute multiplication\n\t            var x2 = d[x];\n\t            var x4 = d[x2];\n\t            var x8 = d[x4];\n\n\t            // Compute sub bytes, mix columns tables\n\t            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n\t            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n\t            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n\t            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n\t            SUB_MIX_3[x] = t;\n\n\t            // Compute inv sub bytes, inv mix columns tables\n\t            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n\t            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n\t            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n\t            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n\t            INV_SUB_MIX_3[sx] = t;\n\n\t            // Compute next counter\n\t            if (!x) {\n\t                x = xi = 1;\n\t            } else {\n\t                x = x2 ^ d[d[d[x8 ^ x2]]];\n\t                xi ^= d[d[xi]];\n\t            }\n\t        }\n\t    }());\n\n\t    // Precomputed Rcon lookup\n\t    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n\t    /**\n\t     * AES block cipher algorithm.\n\t     */\n\t    var AES = C_algo.AES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            var t;\n\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._nRounds && this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            // Compute number of rounds\n\t            var nRounds = this._nRounds = keySize + 6;\n\n\t            // Compute number of key schedule rows\n\t            var ksRows = (nRounds + 1) * 4;\n\n\t            // Compute key schedule\n\t            var keySchedule = this._keySchedule = [];\n\t            for (var ksRow = 0; ksRow < ksRows; ksRow++) {\n\t                if (ksRow < keySize) {\n\t                    keySchedule[ksRow] = keyWords[ksRow];\n\t                } else {\n\t                    t = keySchedule[ksRow - 1];\n\n\t                    if (!(ksRow % keySize)) {\n\t                        // Rot word\n\t                        t = (t << 8) | (t >>> 24);\n\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n\t                        // Mix Rcon\n\t                        t ^= RCON[(ksRow / keySize) | 0] << 24;\n\t                    } else if (keySize > 6 && ksRow % keySize == 4) {\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\t                    }\n\n\t                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n\t                }\n\t            }\n\n\t            // Compute inv key schedule\n\t            var invKeySchedule = this._invKeySchedule = [];\n\t            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n\t                var ksRow = ksRows - invKsRow;\n\n\t                if (invKsRow % 4) {\n\t                    var t = keySchedule[ksRow];\n\t                } else {\n\t                    var t = keySchedule[ksRow - 4];\n\t                }\n\n\t                if (invKsRow < 4 || ksRow <= 4) {\n\t                    invKeySchedule[invKsRow] = t;\n\t                } else {\n\t                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n\t                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n\t                }\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            // Swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\n\t            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n\t            // Inv swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\t        },\n\n\t        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n\t            // Shortcut\n\t            var nRounds = this._nRounds;\n\n\t            // Get input, add round key\n\t            var s0 = M[offset]     ^ keySchedule[0];\n\t            var s1 = M[offset + 1] ^ keySchedule[1];\n\t            var s2 = M[offset + 2] ^ keySchedule[2];\n\t            var s3 = M[offset + 3] ^ keySchedule[3];\n\n\t            // Key schedule row counter\n\t            var ksRow = 4;\n\n\t            // Rounds\n\t            for (var round = 1; round < nRounds; round++) {\n\t                // Shift rows, sub bytes, mix columns, add round key\n\t                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\n\t                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\n\t                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\n\t                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\n\n\t                // Update state\n\t                s0 = t0;\n\t                s1 = t1;\n\t                s2 = t2;\n\t                s3 = t3;\n\t            }\n\n\t            // Shift rows, sub bytes, add round key\n\t            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n\n\t            // Set output\n\t            M[offset]     = t0;\n\t            M[offset + 1] = t1;\n\t            M[offset + 2] = t2;\n\t            M[offset + 3] = t3;\n\t        },\n\n\t        keySize: 256/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.AES = BlockCipher._createHelper(AES);\n\t}());\n\n\n\treturn CryptoJS.AES;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/aes.js?");

/***/ }),

/***/ "./node_modules/crypto-js/blowfish.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/blowfish.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    const N = 16;\n\n\t    //Origin pbox and sbox, derived from PI\n\t    const ORIG_P = [\n\t        0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,\n\t        0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,\n\t        0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,\n\t        0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,\n\t        0x9216D5D9, 0x8979FB1B\n\t    ];\n\n\t    const ORIG_S = [\n\t        [   0xD1310BA6, 0x98DFB5AC, 0x2FFD72DB, 0xD01ADFB7,\n\t            0xB8E1AFED, 0x6A267E96, 0xBA7C9045, 0xF12C7F99,\n\t            0x24A19947, 0xB3916CF7, 0x0801F2E2, 0x858EFC16,\n\t            0x636920D8, 0x71574E69, 0xA458FEA3, 0xF4933D7E,\n\t            0x0D95748F, 0x728EB658, 0x718BCD58, 0x82154AEE,\n\t            0x7B54A41D, 0xC25A59B5, 0x9C30D539, 0x2AF26013,\n\t            0xC5D1B023, 0x286085F0, 0xCA417918, 0xB8DB38EF,\n\t            0x8E79DCB0, 0x603A180E, 0x6C9E0E8B, 0xB01E8A3E,\n\t            0xD71577C1, 0xBD314B27, 0x78AF2FDA, 0x55605C60,\n\t            0xE65525F3, 0xAA55AB94, 0x57489862, 0x63E81440,\n\t            0x55CA396A, 0x2AAB10B6, 0xB4CC5C34, 0x1141E8CE,\n\t            0xA15486AF, 0x7C72E993, 0xB3EE1411, 0x636FBC2A,\n\t            0x2BA9C55D, 0x741831F6, 0xCE5C3E16, 0x9B87931E,\n\t            0xAFD6BA33, 0x6C24CF5C, 0x7A325381, 0x28958677,\n\t            0x3B8F4898, 0x6B4BB9AF, 0xC4BFE81B, 0x66282193,\n\t            0x61D809CC, 0xFB21A991, 0x487CAC60, 0x5DEC8032,\n\t            0xEF845D5D, 0xE98575B1, 0xDC262302, 0xEB651B88,\n\t            0x23893E81, 0xD396ACC5, 0x0F6D6FF3, 0x83F44239,\n\t            0x2E0B4482, 0xA4842004, 0x69C8F04A, 0x9E1F9B5E,\n\t            0x21C66842, 0xF6E96C9A, 0x670C9C61, 0xABD388F0,\n\t            0x6A51A0D2, 0xD8542F68, 0x960FA728, 0xAB5133A3,\n\t            0x6EEF0B6C, 0x137A3BE4, 0xBA3BF050, 0x7EFB2A98,\n\t            0xA1F1651D, 0x39AF0176, 0x66CA593E, 0x82430E88,\n\t            0x8CEE8619, 0x456F9FB4, 0x7D84A5C3, 0x3B8B5EBE,\n\t            0xE06F75D8, 0x85C12073, 0x401A449F, 0x56C16AA6,\n\t            0x4ED3AA62, 0x363F7706, 0x1BFEDF72, 0x429B023D,\n\t            0x37D0D724, 0xD00A1248, 0xDB0FEAD3, 0x49F1C09B,\n\t            0x075372C9, 0x80991B7B, 0x25D479D8, 0xF6E8DEF7,\n\t            0xE3FE501A, 0xB6794C3B, 0x976CE0BD, 0x04C006BA,\n\t            0xC1A94FB6, 0x409F60C4, 0x5E5C9EC2, 0x196A2463,\n\t            0x68FB6FAF, 0x3E6C53B5, 0x1339B2EB, 0x3B52EC6F,\n\t            0x6DFC511F, 0x9B30952C, 0xCC814544, 0xAF5EBD09,\n\t            0xBEE3D004, 0xDE334AFD, 0x660F2807, 0x192E4BB3,\n\t            0xC0CBA857, 0x45C8740F, 0xD20B5F39, 0xB9D3FBDB,\n\t            0x5579C0BD, 0x1A60320A, 0xD6A100C6, 0x402C7279,\n\t            0x679F25FE, 0xFB1FA3CC, 0x8EA5E9F8, 0xDB3222F8,\n\t            0x3C7516DF, 0xFD616B15, 0x2F501EC8, 0xAD0552AB,\n\t            0x323DB5FA, 0xFD238760, 0x53317B48, 0x3E00DF82,\n\t            0x9E5C57BB, 0xCA6F8CA0, 0x1A87562E, 0xDF1769DB,\n\t            0xD542A8F6, 0x287EFFC3, 0xAC6732C6, 0x8C4F5573,\n\t            0x695B27B0, 0xBBCA58C8, 0xE1FFA35D, 0xB8F011A0,\n\t            0x10FA3D98, 0xFD2183B8, 0x4AFCB56C, 0x2DD1D35B,\n\t            0x9A53E479, 0xB6F84565, 0xD28E49BC, 0x4BFB9790,\n\t            0xE1DDF2DA, 0xA4CB7E33, 0x62FB1341, 0xCEE4C6E8,\n\t            0xEF20CADA, 0x36774C01, 0xD07E9EFE, 0x2BF11FB4,\n\t            0x95DBDA4D, 0xAE909198, 0xEAAD8E71, 0x6B93D5A0,\n\t            0xD08ED1D0, 0xAFC725E0, 0x8E3C5B2F, 0x8E7594B7,\n\t            0x8FF6E2FB, 0xF2122B64, 0x8888B812, 0x900DF01C,\n\t            0x4FAD5EA0, 0x688FC31C, 0xD1CFF191, 0xB3A8C1AD,\n\t            0x2F2F2218, 0xBE0E1777, 0xEA752DFE, 0x8B021FA1,\n\t            0xE5A0CC0F, 0xB56F74E8, 0x18ACF3D6, 0xCE89E299,\n\t            0xB4A84FE0, 0xFD13E0B7, 0x7CC43B81, 0xD2ADA8D9,\n\t            0x165FA266, 0x80957705, 0x93CC7314, 0x211A1477,\n\t            0xE6AD2065, 0x77B5FA86, 0xC75442F5, 0xFB9D35CF,\n\t            0xEBCDAF0C, 0x7B3E89A0, 0xD6411BD3, 0xAE1E7E49,\n\t            0x00250E2D, 0x2071B35E, 0x226800BB, 0x57B8E0AF,\n\t            0x2464369B, 0xF009B91E, 0x5563911D, 0x59DFA6AA,\n\t            0x78C14389, 0xD95A537F, 0x207D5BA2, 0x02E5B9C5,\n\t            0x83260376, 0x6295CFA9, 0x11C81968, 0x4E734A41,\n\t            0xB3472DCA, 0x7B14A94A, 0x1B510052, 0x9A532915,\n\t            0xD60F573F, 0xBC9BC6E4, 0x2B60A476, 0x81E67400,\n\t            0x08BA6FB5, 0x571BE91F, 0xF296EC6B, 0x2A0DD915,\n\t            0xB6636521, 0xE7B9F9B6, 0xFF34052E, 0xC5855664,\n\t            0x53B02D5D, 0xA99F8FA1, 0x08BA4799, 0x6E85076A   ],\n\t        [   0x4B7A70E9, 0xB5B32944, 0xDB75092E, 0xC4192623,\n\t            0xAD6EA6B0, 0x49A7DF7D, 0x9CEE60B8, 0x8FEDB266,\n\t            0xECAA8C71, 0x699A17FF, 0x5664526C, 0xC2B19EE1,\n\t            0x193602A5, 0x75094C29, 0xA0591340, 0xE4183A3E,\n\t            0x3F54989A, 0x5B429D65, 0x6B8FE4D6, 0x99F73FD6,\n\t            0xA1D29C07, 0xEFE830F5, 0x4D2D38E6, 0xF0255DC1,\n\t            0x4CDD2086, 0x8470EB26, 0x6382E9C6, 0x021ECC5E,\n\t            0x09686B3F, 0x3EBAEFC9, 0x3C971814, 0x6B6A70A1,\n\t            0x687F3584, 0x52A0E286, 0xB79C5305, 0xAA500737,\n\t            0x3E07841C, 0x7FDEAE5C, 0x8E7D44EC, 0x5716F2B8,\n\t            0xB03ADA37, 0xF0500C0D, 0xF01C1F04, 0x0200B3FF,\n\t            0xAE0CF51A, 0x3CB574B2, 0x25837A58, 0xDC0921BD,\n\t            0xD19113F9, 0x7CA92FF6, 0x94324773, 0x22F54701,\n\t            0x3AE5E581, 0x37C2DADC, 0xC8B57634, 0x9AF3DDA7,\n\t            0xA9446146, 0x0FD0030E, 0xECC8C73E, 0xA4751E41,\n\t            0xE238CD99, 0x3BEA0E2F, 0x3280BBA1, 0x183EB331,\n\t            0x4E548B38, 0x4F6DB908, 0x6F420D03, 0xF60A04BF,\n\t            0x2CB81290, 0x24977C79, 0x5679B072, 0xBCAF89AF,\n\t            0xDE9A771F, 0xD9930810, 0xB38BAE12, 0xDCCF3F2E,\n\t            0x5512721F, 0x2E6B7124, 0x501ADDE6, 0x9F84CD87,\n\t            0x7A584718, 0x7408DA17, 0xBC9F9ABC, 0xE94B7D8C,\n\t            0xEC7AEC3A, 0xDB851DFA, 0x63094366, 0xC464C3D2,\n\t            0xEF1C1847, 0x3215D908, 0xDD433B37, 0x24C2BA16,\n\t            0x12A14D43, 0x2A65C451, 0x50940002, 0x133AE4DD,\n\t            0x71DFF89E, 0x10314E55, 0x81AC77D6, 0x5F11199B,\n\t            0x043556F1, 0xD7A3C76B, 0x3C11183B, 0x5924A509,\n\t            0xF28FE6ED, 0x97F1FBFA, 0x9EBABF2C, 0x1E153C6E,\n\t            0x86E34570, 0xEAE96FB1, 0x860E5E0A, 0x5A3E2AB3,\n\t            0x771FE71C, 0x4E3D06FA, 0x2965DCB9, 0x99E71D0F,\n\t            0x803E89D6, 0x5266C825, 0x2E4CC978, 0x9C10B36A,\n\t            0xC6150EBA, 0x94E2EA78, 0xA5FC3C53, 0x1E0A2DF4,\n\t            0xF2F74EA7, 0x361D2B3D, 0x1939260F, 0x19C27960,\n\t            0x5223A708, 0xF71312B6, 0xEBADFE6E, 0xEAC31F66,\n\t            0xE3BC4595, 0xA67BC883, 0xB17F37D1, 0x018CFF28,\n\t            0xC332DDEF, 0xBE6C5AA5, 0x65582185, 0x68AB9802,\n\t            0xEECEA50F, 0xDB2F953B, 0x2AEF7DAD, 0x5B6E2F84,\n\t            0x1521B628, 0x29076170, 0xECDD4775, 0x619F1510,\n\t            0x13CCA830, 0xEB61BD96, 0x0334FE1E, 0xAA0363CF,\n\t            0xB5735C90, 0x4C70A239, 0xD59E9E0B, 0xCBAADE14,\n\t            0xEECC86BC, 0x60622CA7, 0x9CAB5CAB, 0xB2F3846E,\n\t            0x648B1EAF, 0x19BDF0CA, 0xA02369B9, 0x655ABB50,\n\t            0x40685A32, 0x3C2AB4B3, 0x319EE9D5, 0xC021B8F7,\n\t            0x9B540B19, 0x875FA099, 0x95F7997E, 0x623D7DA8,\n\t            0xF837889A, 0x97E32D77, 0x11ED935F, 0x16681281,\n\t            0x0E358829, 0xC7E61FD6, 0x96DEDFA1, 0x7858BA99,\n\t            0x57F584A5, 0x1B227263, 0x9B83C3FF, 0x1AC24696,\n\t            0xCDB30AEB, 0x532E3054, 0x8FD948E4, 0x6DBC3128,\n\t            0x58EBF2EF, 0x34C6FFEA, 0xFE28ED61, 0xEE7C3C73,\n\t            0x5D4A14D9, 0xE864B7E3, 0x42105D14, 0x203E13E0,\n\t            0x45EEE2B6, 0xA3AAABEA, 0xDB6C4F15, 0xFACB4FD0,\n\t            0xC742F442, 0xEF6ABBB5, 0x654F3B1D, 0x41CD2105,\n\t            0xD81E799E, 0x86854DC7, 0xE44B476A, 0x3D816250,\n\t            0xCF62A1F2, 0x5B8D2646, 0xFC8883A0, 0xC1C7B6A3,\n\t            0x7F1524C3, 0x69CB7492, 0x47848A0B, 0x5692B285,\n\t            0x095BBF00, 0xAD19489D, 0x1462B174, 0x23820E00,\n\t            0x58428D2A, 0x0C55F5EA, 0x1DADF43E, 0x233F7061,\n\t            0x3372F092, 0x8D937E41, 0xD65FECF1, 0x6C223BDB,\n\t            0x7CDE3759, 0xCBEE7460, 0x4085F2A7, 0xCE77326E,\n\t            0xA6078084, 0x19F8509E, 0xE8EFD855, 0x61D99735,\n\t            0xA969A7AA, 0xC50C06C2, 0x5A04ABFC, 0x800BCADC,\n\t            0x9E447A2E, 0xC3453484, 0xFDD56705, 0x0E1E9EC9,\n\t            0xDB73DBD3, 0x105588CD, 0x675FDA79, 0xE3674340,\n\t            0xC5C43465, 0x713E38D8, 0x3D28F89E, 0xF16DFF20,\n\t            0x153E21E7, 0x8FB03D4A, 0xE6E39F2B, 0xDB83ADF7   ],\n\t        [   0xE93D5A68, 0x948140F7, 0xF64C261C, 0x94692934,\n\t            0x411520F7, 0x7602D4F7, 0xBCF46B2E, 0xD4A20068,\n\t            0xD4082471, 0x3320F46A, 0x43B7D4B7, 0x500061AF,\n\t            0x1E39F62E, 0x97244546, 0x14214F74, 0xBF8B8840,\n\t            0x4D95FC1D, 0x96B591AF, 0x70F4DDD3, 0x66A02F45,\n\t            0xBFBC09EC, 0x03BD9785, 0x7FAC6DD0, 0x31CB8504,\n\t            0x96EB27B3, 0x55FD3941, 0xDA2547E6, 0xABCA0A9A,\n\t            0x28507825, 0x530429F4, 0x0A2C86DA, 0xE9B66DFB,\n\t            0x68DC1462, 0xD7486900, 0x680EC0A4, 0x27A18DEE,\n\t            0x4F3FFEA2, 0xE887AD8C, 0xB58CE006, 0x7AF4D6B6,\n\t            0xAACE1E7C, 0xD3375FEC, 0xCE78A399, 0x406B2A42,\n\t            0x20FE9E35, 0xD9F385B9, 0xEE39D7AB, 0x3B124E8B,\n\t            0x1DC9FAF7, 0x4B6D1856, 0x26A36631, 0xEAE397B2,\n\t            0x3A6EFA74, 0xDD5B4332, 0x6841E7F7, 0xCA7820FB,\n\t            0xFB0AF54E, 0xD8FEB397, 0x454056AC, 0xBA489527,\n\t            0x55533A3A, 0x20838D87, 0xFE6BA9B7, 0xD096954B,\n\t            0x55A867BC, 0xA1159A58, 0xCCA92963, 0x99E1DB33,\n\t            0xA62A4A56, 0x3F3125F9, 0x5EF47E1C, 0x9029317C,\n\t            0xFDF8E802, 0x04272F70, 0x80BB155C, 0x05282CE3,\n\t            0x95C11548, 0xE4C66D22, 0x48C1133F, 0xC70F86DC,\n\t            0x07F9C9EE, 0x41041F0F, 0x404779A4, 0x5D886E17,\n\t            0x325F51EB, 0xD59BC0D1, 0xF2BCC18F, 0x41113564,\n\t            0x257B7834, 0x602A9C60, 0xDFF8E8A3, 0x1F636C1B,\n\t            0x0E12B4C2, 0x02E1329E, 0xAF664FD1, 0xCAD18115,\n\t            0x6B2395E0, 0x333E92E1, 0x3B240B62, 0xEEBEB922,\n\t            0x85B2A20E, 0xE6BA0D99, 0xDE720C8C, 0x2DA2F728,\n\t            0xD0127845, 0x95B794FD, 0x647D0862, 0xE7CCF5F0,\n\t            0x5449A36F, 0x877D48FA, 0xC39DFD27, 0xF33E8D1E,\n\t            0x0A476341, 0x992EFF74, 0x3A6F6EAB, 0xF4F8FD37,\n\t            0xA812DC60, 0xA1EBDDF8, 0x991BE14C, 0xDB6E6B0D,\n\t            0xC67B5510, 0x6D672C37, 0x2765D43B, 0xDCD0E804,\n\t            0xF1290DC7, 0xCC00FFA3, 0xB5390F92, 0x690FED0B,\n\t            0x667B9FFB, 0xCEDB7D9C, 0xA091CF0B, 0xD9155EA3,\n\t            0xBB132F88, 0x515BAD24, 0x7B9479BF, 0x763BD6EB,\n\t            0x37392EB3, 0xCC115979, 0x8026E297, 0xF42E312D,\n\t            0x6842ADA7, 0xC66A2B3B, 0x12754CCC, 0x782EF11C,\n\t            0x6A124237, 0xB79251E7, 0x06A1BBE6, 0x4BFB6350,\n\t            0x1A6B1018, 0x11CAEDFA, 0x3D25BDD8, 0xE2E1C3C9,\n\t            0x44421659, 0x0A121386, 0xD90CEC6E, 0xD5ABEA2A,\n\t            0x64AF674E, 0xDA86A85F, 0xBEBFE988, 0x64E4C3FE,\n\t            0x9DBC8057, 0xF0F7C086, 0x60787BF8, 0x6003604D,\n\t            0xD1FD8346, 0xF6381FB0, 0x7745AE04, 0xD736FCCC,\n\t            0x83426B33, 0xF01EAB71, 0xB0804187, 0x3C005E5F,\n\t            0x77A057BE, 0xBDE8AE24, 0x55464299, 0xBF582E61,\n\t            0x4E58F48F, 0xF2DDFDA2, 0xF474EF38, 0x8789BDC2,\n\t            0x5366F9C3, 0xC8B38E74, 0xB475F255, 0x46FCD9B9,\n\t            0x7AEB2661, 0x8B1DDF84, 0x846A0E79, 0x915F95E2,\n\t            0x466E598E, 0x20B45770, 0x8CD55591, 0xC902DE4C,\n\t            0xB90BACE1, 0xBB8205D0, 0x11A86248, 0x7574A99E,\n\t            0xB77F19B6, 0xE0A9DC09, 0x662D09A1, 0xC4324633,\n\t            0xE85A1F02, 0x09F0BE8C, 0x4A99A025, 0x1D6EFE10,\n\t            0x1AB93D1D, 0x0BA5A4DF, 0xA186F20F, 0x2868F169,\n\t            0xDCB7DA83, 0x573906FE, 0xA1E2CE9B, 0x4FCD7F52,\n\t            0x50115E01, 0xA70683FA, 0xA002B5C4, 0x0DE6D027,\n\t            0x9AF88C27, 0x773F8641, 0xC3604C06, 0x61A806B5,\n\t            0xF0177A28, 0xC0F586E0, 0x006058AA, 0x30DC7D62,\n\t            0x11E69ED7, 0x2338EA63, 0x53C2DD94, 0xC2C21634,\n\t            0xBBCBEE56, 0x90BCB6DE, 0xEBFC7DA1, 0xCE591D76,\n\t            0x6F05E409, 0x4B7C0188, 0x39720A3D, 0x7C927C24,\n\t            0x86E3725F, 0x724D9DB9, 0x1AC15BB4, 0xD39EB8FC,\n\t            0xED545578, 0x08FCA5B5, 0xD83D7CD3, 0x4DAD0FC4,\n\t            0x1E50EF5E, 0xB161E6F8, 0xA28514D9, 0x6C51133C,\n\t            0x6FD5C7E7, 0x56E14EC4, 0x362ABFCE, 0xDDC6C837,\n\t            0xD79A3234, 0x92638212, 0x670EFA8E, 0x406000E0  ],\n\t        [   0x3A39CE37, 0xD3FAF5CF, 0xABC27737, 0x5AC52D1B,\n\t            0x5CB0679E, 0x4FA33742, 0xD3822740, 0x99BC9BBE,\n\t            0xD5118E9D, 0xBF0F7315, 0xD62D1C7E, 0xC700C47B,\n\t            0xB78C1B6B, 0x21A19045, 0xB26EB1BE, 0x6A366EB4,\n\t            0x5748AB2F, 0xBC946E79, 0xC6A376D2, 0x6549C2C8,\n\t            0x530FF8EE, 0x468DDE7D, 0xD5730A1D, 0x4CD04DC6,\n\t            0x2939BBDB, 0xA9BA4650, 0xAC9526E8, 0xBE5EE304,\n\t            0xA1FAD5F0, 0x6A2D519A, 0x63EF8CE2, 0x9A86EE22,\n\t            0xC089C2B8, 0x43242EF6, 0xA51E03AA, 0x9CF2D0A4,\n\t            0x83C061BA, 0x9BE96A4D, 0x8FE51550, 0xBA645BD6,\n\t            0x2826A2F9, 0xA73A3AE1, 0x4BA99586, 0xEF5562E9,\n\t            0xC72FEFD3, 0xF752F7DA, 0x3F046F69, 0x77FA0A59,\n\t            0x80E4A915, 0x87B08601, 0x9B09E6AD, 0x3B3EE593,\n\t            0xE990FD5A, 0x9E34D797, 0x2CF0B7D9, 0x022B8B51,\n\t            0x96D5AC3A, 0x017DA67D, 0xD1CF3ED6, 0x7C7D2D28,\n\t            0x1F9F25CF, 0xADF2B89B, 0x5AD6B472, 0x5A88F54C,\n\t            0xE029AC71, 0xE019A5E6, 0x47B0ACFD, 0xED93FA9B,\n\t            0xE8D3C48D, 0x283B57CC, 0xF8D56629, 0x79132E28,\n\t            0x785F0191, 0xED756055, 0xF7960E44, 0xE3D35E8C,\n\t            0x15056DD4, 0x88F46DBA, 0x03A16125, 0x0564F0BD,\n\t            0xC3EB9E15, 0x3C9057A2, 0x97271AEC, 0xA93A072A,\n\t            0x1B3F6D9B, 0x1E6321F5, 0xF59C66FB, 0x26DCF319,\n\t            0x7533D928, 0xB155FDF5, 0x03563482, 0x8ABA3CBB,\n\t            0x28517711, 0xC20AD9F8, 0xABCC5167, 0xCCAD925F,\n\t            0x4DE81751, 0x3830DC8E, 0x379D5862, 0x9320F991,\n\t            0xEA7A90C2, 0xFB3E7BCE, 0x5121CE64, 0x774FBE32,\n\t            0xA8B6E37E, 0xC3293D46, 0x48DE5369, 0x6413E680,\n\t            0xA2AE0810, 0xDD6DB224, 0x69852DFD, 0x09072166,\n\t            0xB39A460A, 0x6445C0DD, 0x586CDECF, 0x1C20C8AE,\n\t            0x5BBEF7DD, 0x1B588D40, 0xCCD2017F, 0x6BB4E3BB,\n\t            0xDDA26A7E, 0x3A59FF45, 0x3E350A44, 0xBCB4CDD5,\n\t            0x72EACEA8, 0xFA6484BB, 0x8D6612AE, 0xBF3C6F47,\n\t            0xD29BE463, 0x542F5D9E, 0xAEC2771B, 0xF64E6370,\n\t            0x740E0D8D, 0xE75B1357, 0xF8721671, 0xAF537D5D,\n\t            0x4040CB08, 0x4EB4E2CC, 0x34D2466A, 0x0115AF84,\n\t            0xE1B00428, 0x95983A1D, 0x06B89FB4, 0xCE6EA048,\n\t            0x6F3F3B82, 0x3520AB82, 0x011A1D4B, 0x277227F8,\n\t            0x611560B1, 0xE7933FDC, 0xBB3A792B, 0x344525BD,\n\t            0xA08839E1, 0x51CE794B, 0x2F32C9B7, 0xA01FBAC9,\n\t            0xE01CC87E, 0xBCC7D1F6, 0xCF0111C3, 0xA1E8AAC7,\n\t            0x1A908749, 0xD44FBD9A, 0xD0DADECB, 0xD50ADA38,\n\t            0x0339C32A, 0xC6913667, 0x8DF9317C, 0xE0B12B4F,\n\t            0xF79E59B7, 0x43F5BB3A, 0xF2D519FF, 0x27D9459C,\n\t            0xBF97222C, 0x15E6FC2A, 0x0F91FC71, 0x9B941525,\n\t            0xFAE59361, 0xCEB69CEB, 0xC2A86459, 0x12BAA8D1,\n\t            0xB6C1075E, 0xE3056A0C, 0x10D25065, 0xCB03A442,\n\t            0xE0EC6E0E, 0x1698DB3B, 0x4C98A0BE, 0x3278E964,\n\t            0x9F1F9532, 0xE0D392DF, 0xD3A0342B, 0x8971F21E,\n\t            0x1B0A7441, 0x4BA3348C, 0xC5BE7120, 0xC37632D8,\n\t            0xDF359F8D, 0x9B992F2E, 0xE60B6F47, 0x0FE3F11D,\n\t            0xE54CDA54, 0x1EDAD891, 0xCE6279CF, 0xCD3E7E6F,\n\t            0x1618B166, 0xFD2C1D05, 0x848FD2C5, 0xF6FB2299,\n\t            0xF523F357, 0xA6327623, 0x93A83531, 0x56CCCD02,\n\t            0xACF08162, 0x5A75EBB5, 0x6E163697, 0x88D273CC,\n\t            0xDE966292, 0x81B949D0, 0x4C50901B, 0x71C65614,\n\t            0xE6C6C7BD, 0x327A140A, 0x45E1D006, 0xC3F27B9A,\n\t            0xC9AA53FD, 0x62A80F00, 0xBB25BFE2, 0x35BDD2F6,\n\t            0x71126905, 0xB2040222, 0xB6CBCF7C, 0xCD769C2B,\n\t            0x53113EC0, 0x1640E3D3, 0x38ABBD60, 0x2547ADF0,\n\t            0xBA38209C, 0xF746CE76, 0x77AFA1C5, 0x20756060,\n\t            0x85CBFE4E, 0x8AE88DD8, 0x7AAAF9B0, 0x4CF9AA7E,\n\t            0x1948C25C, 0x02FB8A8C, 0x01C36AE4, 0xD6EBE1F9,\n\t            0x90D4F869, 0xA65CDEA0, 0x3F09252D, 0xC208E69F,\n\t            0xB74E6132, 0xCE77E25B, 0x578FDFE3, 0x3AC372E6  ]\n\t    ];\n\n\t    var BLOWFISH_CTX = {\n\t        pbox: [],\n\t        sbox: []\n\t    }\n\n\t    function F(ctx, x){\n\t        let a = (x >> 24) & 0xFF;\n\t        let b = (x >> 16) & 0xFF;\n\t        let c = (x >> 8) & 0xFF;\n\t        let d = x & 0xFF;\n\n\t        let y = ctx.sbox[0][a] + ctx.sbox[1][b];\n\t        y = y ^ ctx.sbox[2][c];\n\t        y = y + ctx.sbox[3][d];\n\n\t        return y;\n\t    }\n\n\t    function BlowFish_Encrypt(ctx, left, right){\n\t        let Xl = left;\n\t        let Xr = right;\n\t        let temp;\n\n\t        for(let i = 0; i < N; ++i){\n\t            Xl = Xl ^ ctx.pbox[i];\n\t            Xr = F(ctx, Xl) ^ Xr;\n\n\t            temp = Xl;\n\t            Xl = Xr;\n\t            Xr = temp;\n\t        }\n\n\t        temp = Xl;\n\t        Xl = Xr;\n\t        Xr = temp;\n\n\t        Xr = Xr ^ ctx.pbox[N];\n\t        Xl = Xl ^ ctx.pbox[N + 1];\n\n\t        return {left: Xl, right: Xr};\n\t    }\n\n\t    function BlowFish_Decrypt(ctx, left, right){\n\t        let Xl = left;\n\t        let Xr = right;\n\t        let temp;\n\n\t        for(let i = N + 1; i > 1; --i){\n\t            Xl = Xl ^ ctx.pbox[i];\n\t            Xr = F(ctx, Xl) ^ Xr;\n\n\t            temp = Xl;\n\t            Xl = Xr;\n\t            Xr = temp;\n\t        }\n\n\t        temp = Xl;\n\t        Xl = Xr;\n\t        Xr = temp;\n\n\t        Xr = Xr ^ ctx.pbox[1];\n\t        Xl = Xl ^ ctx.pbox[0];\n\n\t        return {left: Xl, right: Xr};\n\t    }\n\n\t    /**\n\t     * Initialization ctx's pbox and sbox.\n\t     *\n\t     * @param {Object} ctx The object has pbox and sbox.\n\t     * @param {Array} key An array of 32-bit words.\n\t     * @param {int} keysize The length of the key.\n\t     *\n\t     * @example\n\t     *\n\t     *     BlowFishInit(BLOWFISH_CTX, key, 128/32);\n\t     */\n\t    function BlowFishInit(ctx, key, keysize)\n\t    {\n\t        for(let Row = 0; Row < 4; Row++)\n\t        {\n\t            ctx.sbox[Row] = [];\n\t            for(let Col = 0; Col < 256; Col++)\n\t            {\n\t                ctx.sbox[Row][Col] = ORIG_S[Row][Col];\n\t            }\n\t        }\n\n\t        let keyIndex = 0;\n\t        for(let index = 0; index < N + 2; index++)\n\t        {\n\t            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];\n\t            keyIndex++;\n\t            if(keyIndex >= keysize)\n\t            {\n\t                keyIndex = 0;\n\t            }\n\t        }\n\n\t        let Data1 = 0;\n\t        let Data2 = 0;\n\t        let res = 0;\n\t        for(let i = 0; i < N + 2; i += 2)\n\t        {\n\t            res = BlowFish_Encrypt(ctx, Data1, Data2);\n\t            Data1 = res.left;\n\t            Data2 = res.right;\n\t            ctx.pbox[i] = Data1;\n\t            ctx.pbox[i + 1] = Data2;\n\t        }\n\n\t        for(let i = 0; i < 4; i++)\n\t        {\n\t            for(let j = 0; j < 256; j += 2)\n\t            {\n\t                res = BlowFish_Encrypt(ctx, Data1, Data2);\n\t                Data1 = res.left;\n\t                Data2 = res.right;\n\t                ctx.sbox[i][j] = Data1;\n\t                ctx.sbox[i][j + 1] = Data2;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    /**\n\t     * Blowfish block cipher algorithm.\n\t     */\n\t    var Blowfish = C_algo.Blowfish = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            //Initialization pbox and sbox\n\t            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);\n\t            M[offset] = res.left;\n\t            M[offset + 1] = res.right;\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);\n\t            M[offset] = res.left;\n\t            M[offset + 1] = res.right;\n\t        },\n\n\t        blockSize: 64/32,\n\n\t        keySize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.Blowfish.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.Blowfish.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.Blowfish = BlockCipher._createHelper(Blowfish);\n\t}());\n\n\n\treturn CryptoJS.Blowfish;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/blowfish.js?");

/***/ }),

/***/ "./node_modules/crypto-js/cipher-core.js":
/*!***********************************************!*\
  !*** ./node_modules/crypto-js/cipher-core.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            var block;\n\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            var modeCreator;\n\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var finalProcessedBlocks;\n\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            var wordArray;\n\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            var salt;\n\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt, hasher) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            if (!hasher) {\n\t                var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\t            } else {\n\t                var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: hasher }).compute(password, salt);\n\t            }\n\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/cipher-core.js?");

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse {}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native crypto in web worker (Browser)\n\t    if (typeof self !== 'undefined' && self.crypto) {\n\t        crypto = self.crypto;\n\t    }\n\n\t    // Native crypto from worker\n\t    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n\t        crypto = globalThis.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {\n\t        crypto = __webpack_require__.g.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && \"function\" === 'function') {\n\t        try {\n\t            crypto = __webpack_require__(/*! crypto */ \"?9157\");\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }());\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var j = 0; j < thatSigBytes; j += 4) {\n\t                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/core.js?");

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              var bitsCombined = bits1 | bits2;\n\t              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/enc-base64.js?");

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64url.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/enc-base64url.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64url encoding strategy.\n\t     */\n\t    var Base64url = C_enc.Base64url = {\n\t        /**\n\t         * Converts a word array to a Base64url string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {string} The Base64url string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray, urlSafe) {\n\t            if (urlSafe === undefined) {\n\t                urlSafe = true\n\t            }\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64url string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64url string.\n\t         *\n\t         * @param {boolean} urlSafe Whether to use url safe\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);\n\t         */\n\t        parse: function (base64Str, urlSafe) {\n\t            if (urlSafe === undefined) {\n\t                urlSafe = true\n\t            }\n\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = urlSafe ? this._safe_map : this._map;\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                reverseMap = this._reverseMap = [];\n\t                for (var j = 0; j < map.length; j++) {\n\t                    reverseMap[map.charCodeAt(j)] = j;\n\t                }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        },\n\n\t        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n\t        _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t        var words = [];\n\t        var nBytes = 0;\n\t        for (var i = 0; i < base64StrLength; i++) {\n\t            if (i % 4) {\n\t                var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t                var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t                var bitsCombined = bits1 | bits2;\n\t                words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t                nBytes++;\n\t            }\n\t        }\n\t        return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64url;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/enc-base64url.js?");

/***/ }),

/***/ "./node_modules/crypto-js/enc-utf16.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/enc-utf16.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * UTF-16 BE encoding strategy.\n\t     */\n\t    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 BE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 BE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 BE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 BE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-16 LE encoding strategy.\n\t     */\n\t    C_enc.Utf16LE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 LE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 LE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 LE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 LE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    function swapEndian(word) {\n\t        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Utf16;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/enc-utf16.js?");

/***/ }),

/***/ "./node_modules/crypto-js/evpkdf.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/evpkdf.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha1 */ \"./node_modules/crypto-js/sha1.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var MD5 = C_algo.MD5;\n\n\t    /**\n\t     * This key derivation function is meant to conform with EVP_BytesToKey.\n\t     * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n\t     */\n\t    var EvpKDF = C_algo.EvpKDF = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: MD5,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create();\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Derives a key from a password.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            var block;\n\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init hasher\n\t            var hasher = cfg.hasher.create();\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                if (block) {\n\t                    hasher.update(block);\n\t                }\n\t                block = hasher.update(password).finalize(salt);\n\t                hasher.reset();\n\n\t                // Iterations\n\t                for (var i = 1; i < iterations; i++) {\n\t                    block = hasher.finalize(block);\n\t                    hasher.reset();\n\t                }\n\n\t                derivedKey.concat(block);\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Derives a key from a password.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.EvpKDF(password, salt);\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.EvpKDF = function (password, salt, cfg) {\n\t        return EvpKDF.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.EvpKDF;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/evpkdf.js?");

/***/ }),

/***/ "./node_modules/crypto-js/format-hex.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/format-hex.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var CipherParams = C_lib.CipherParams;\n\t    var C_enc = C.enc;\n\t    var Hex = C_enc.Hex;\n\t    var C_format = C.format;\n\n\t    var HexFormatter = C_format.Hex = {\n\t        /**\n\t         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The hexadecimally encoded string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            return cipherParams.ciphertext.toString(Hex);\n\t        },\n\n\t        /**\n\t         * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n\t         *\n\t         * @param {string} input The hexadecimally encoded string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n\t         */\n\t        parse: function (input) {\n\t            var ciphertext = Hex.parse(input);\n\t            return CipherParams.create({ ciphertext: ciphertext });\n\t        }\n\t    };\n\t}());\n\n\n\treturn CryptoJS.format.Hex;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/format-hex.js?");

/***/ }),

/***/ "./node_modules/crypto-js/hmac.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/hmac.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * HMAC algorithm.\n\t     */\n\t    var HMAC = C_algo.HMAC = Base.extend({\n\t        /**\n\t         * Initializes a newly created HMAC.\n\t         *\n\t         * @param {Hasher} hasher The hash algorithm to use.\n\t         * @param {WordArray|string} key The secret key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n\t         */\n\t        init: function (hasher, key) {\n\t            // Init hasher\n\t            hasher = this._hasher = new hasher.init();\n\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof key == 'string') {\n\t                key = Utf8.parse(key);\n\t            }\n\n\t            // Shortcuts\n\t            var hasherBlockSize = hasher.blockSize;\n\t            var hasherBlockSizeBytes = hasherBlockSize * 4;\n\n\t            // Allow arbitrary length keys\n\t            if (key.sigBytes > hasherBlockSizeBytes) {\n\t                key = hasher.finalize(key);\n\t            }\n\n\t            // Clamp excess bits\n\t            key.clamp();\n\n\t            // Clone key for inner and outer pads\n\t            var oKey = this._oKey = key.clone();\n\t            var iKey = this._iKey = key.clone();\n\n\t            // Shortcuts\n\t            var oKeyWords = oKey.words;\n\t            var iKeyWords = iKey.words;\n\n\t            // XOR keys with pad constants\n\t            for (var i = 0; i < hasherBlockSize; i++) {\n\t                oKeyWords[i] ^= 0x5c5c5c5c;\n\t                iKeyWords[i] ^= 0x36363636;\n\t            }\n\t            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this HMAC to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Reset\n\t            hasher.reset();\n\t            hasher.update(this._iKey);\n\t        },\n\n\t        /**\n\t         * Updates this HMAC with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {HMAC} This HMAC instance.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.update('message');\n\t         *     hmacHasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            this._hasher.update(messageUpdate);\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the HMAC computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The HMAC.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmac = hmacHasher.finalize();\n\t         *     var hmac = hmacHasher.finalize('message');\n\t         *     var hmac = hmacHasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Compute HMAC\n\t            var innerHash = hasher.finalize(messageUpdate);\n\t            hasher.reset();\n\t            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n\t            return hmac;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/hmac.js?");

/***/ }),

/***/ "./node_modules/crypto-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/crypto-js/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"), __webpack_require__(/*! ./lib-typedarrays */ \"./node_modules/crypto-js/lib-typedarrays.js\"), __webpack_require__(/*! ./enc-utf16 */ \"./node_modules/crypto-js/enc-utf16.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./enc-base64url */ \"./node_modules/crypto-js/enc-base64url.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./sha1 */ \"./node_modules/crypto-js/sha1.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"), __webpack_require__(/*! ./sha224 */ \"./node_modules/crypto-js/sha224.js\"), __webpack_require__(/*! ./sha512 */ \"./node_modules/crypto-js/sha512.js\"), __webpack_require__(/*! ./sha384 */ \"./node_modules/crypto-js/sha384.js\"), __webpack_require__(/*! ./sha3 */ \"./node_modules/crypto-js/sha3.js\"), __webpack_require__(/*! ./ripemd160 */ \"./node_modules/crypto-js/ripemd160.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"), __webpack_require__(/*! ./pbkdf2 */ \"./node_modules/crypto-js/pbkdf2.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"), __webpack_require__(/*! ./mode-cfb */ \"./node_modules/crypto-js/mode-cfb.js\"), __webpack_require__(/*! ./mode-ctr */ \"./node_modules/crypto-js/mode-ctr.js\"), __webpack_require__(/*! ./mode-ctr-gladman */ \"./node_modules/crypto-js/mode-ctr-gladman.js\"), __webpack_require__(/*! ./mode-ofb */ \"./node_modules/crypto-js/mode-ofb.js\"), __webpack_require__(/*! ./mode-ecb */ \"./node_modules/crypto-js/mode-ecb.js\"), __webpack_require__(/*! ./pad-ansix923 */ \"./node_modules/crypto-js/pad-ansix923.js\"), __webpack_require__(/*! ./pad-iso10126 */ \"./node_modules/crypto-js/pad-iso10126.js\"), __webpack_require__(/*! ./pad-iso97971 */ \"./node_modules/crypto-js/pad-iso97971.js\"), __webpack_require__(/*! ./pad-zeropadding */ \"./node_modules/crypto-js/pad-zeropadding.js\"), __webpack_require__(/*! ./pad-nopadding */ \"./node_modules/crypto-js/pad-nopadding.js\"), __webpack_require__(/*! ./format-hex */ \"./node_modules/crypto-js/format-hex.js\"), __webpack_require__(/*! ./aes */ \"./node_modules/crypto-js/aes.js\"), __webpack_require__(/*! ./tripledes */ \"./node_modules/crypto-js/tripledes.js\"), __webpack_require__(/*! ./rc4 */ \"./node_modules/crypto-js/rc4.js\"), __webpack_require__(/*! ./rabbit */ \"./node_modules/crypto-js/rabbit.js\"), __webpack_require__(/*! ./rabbit-legacy */ \"./node_modules/crypto-js/rabbit-legacy.js\"), __webpack_require__(/*! ./blowfish */ \"./node_modules/crypto-js/blowfish.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/index.js?");

/***/ }),

/***/ "./node_modules/crypto-js/lib-typedarrays.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Check if typed arrays are supported\n\t    if (typeof ArrayBuffer != 'function') {\n\t        return;\n\t    }\n\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\n\t    // Reference original init\n\t    var superInit = WordArray.init;\n\n\t    // Augment WordArray.init to handle typed arrays\n\t    var subInit = WordArray.init = function (typedArray) {\n\t        // Convert buffers to uint8\n\t        if (typedArray instanceof ArrayBuffer) {\n\t            typedArray = new Uint8Array(typedArray);\n\t        }\n\n\t        // Convert other array views to uint8\n\t        if (\n\t            typedArray instanceof Int8Array ||\n\t            (typeof Uint8ClampedArray !== \"undefined\" && typedArray instanceof Uint8ClampedArray) ||\n\t            typedArray instanceof Int16Array ||\n\t            typedArray instanceof Uint16Array ||\n\t            typedArray instanceof Int32Array ||\n\t            typedArray instanceof Uint32Array ||\n\t            typedArray instanceof Float32Array ||\n\t            typedArray instanceof Float64Array\n\t        ) {\n\t            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t        }\n\n\t        // Handle Uint8Array\n\t        if (typedArray instanceof Uint8Array) {\n\t            // Shortcut\n\t            var typedArrayByteLength = typedArray.byteLength;\n\n\t            // Extract bytes\n\t            var words = [];\n\t            for (var i = 0; i < typedArrayByteLength; i++) {\n\t                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n\t            }\n\n\t            // Initialize this word array\n\t            superInit.call(this, words, typedArrayByteLength);\n\t        } else {\n\t            // Else call normal init\n\t            superInit.apply(this, arguments);\n\t        }\n\t    };\n\n\t    subInit.prototype = WordArray;\n\t}());\n\n\n\treturn CryptoJS.lib.WordArray;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/lib-typedarrays.js?");

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/md5.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-cfb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-cfb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher Feedback block mode.\n\t */\n\tCryptoJS.mode.CFB = (function () {\n\t    var CFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    CFB.Encryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // Remember this block to use with next block\n\t            this._prevBlock = words.slice(offset, offset + blockSize);\n\t        }\n\t    });\n\n\t    CFB.Decryptor = CFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher;\n\t            var blockSize = cipher.blockSize;\n\n\t            // Remember this block to use with next block\n\t            var thisBlock = words.slice(offset, offset + blockSize);\n\n\t            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n\t            // This block becomes the previous block\n\t            this._prevBlock = thisBlock;\n\t        }\n\t    });\n\n\t    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n\t        var keystream;\n\n\t        // Shortcut\n\t        var iv = this._iv;\n\n\t        // Generate keystream\n\t        if (iv) {\n\t            keystream = iv.slice(0);\n\n\t            // Remove IV for subsequent blocks\n\t            this._iv = undefined;\n\t        } else {\n\t            keystream = this._prevBlock;\n\t        }\n\t        cipher.encryptBlock(keystream, 0);\n\n\t        // Encrypt\n\t        for (var i = 0; i < blockSize; i++) {\n\t            words[offset + i] ^= keystream[i];\n\t        }\n\t    }\n\n\t    return CFB;\n\t}());\n\n\n\treturn CryptoJS.mode.CFB;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/mode-cfb.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr-gladman.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr-gladman.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n\t * derived from CryptoJS.mode.CTR\n\t * Jan Hruby jhruby.web@gmail.com\n\t */\n\tCryptoJS.mode.CTRGladman = (function () {\n\t    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();\n\n\t\tfunction incWord(word)\n\t\t{\n\t\t\tif (((word >> 24) & 0xff) === 0xff) { //overflow\n\t\t\tvar b1 = (word >> 16)&0xff;\n\t\t\tvar b2 = (word >> 8)&0xff;\n\t\t\tvar b3 = word & 0xff;\n\n\t\t\tif (b1 === 0xff) // overflow b1\n\t\t\t{\n\t\t\tb1 = 0;\n\t\t\tif (b2 === 0xff)\n\t\t\t{\n\t\t\t\tb2 = 0;\n\t\t\t\tif (b3 === 0xff)\n\t\t\t\t{\n\t\t\t\t\tb3 = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t++b3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++b2;\n\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t++b1;\n\t\t\t}\n\n\t\t\tword = 0;\n\t\t\tword += (b1 << 16);\n\t\t\tword += (b2 << 8);\n\t\t\tword += b3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tword += (0x01 << 24);\n\t\t\t}\n\t\t\treturn word;\n\t\t}\n\n\t\tfunction incCounter(counter)\n\t\t{\n\t\t\tif ((counter[0] = incWord(counter[0])) === 0)\n\t\t\t{\n\t\t\t\t// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n\t\t\t\tcounter[1] = incWord(counter[1]);\n\t\t\t}\n\t\t\treturn counter;\n\t\t}\n\n\t    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\n\t\t\t\tincCounter(counter);\n\n\t\t\t\tvar keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTRGladman.Decryptor = Encryptor;\n\n\t    return CTRGladman;\n\t}());\n\n\n\n\n\treturn CryptoJS.mode.CTRGladman;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/mode-ctr-gladman.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Counter block mode.\n\t */\n\tCryptoJS.mode.CTR = (function () {\n\t    var CTR = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = CTR.Encryptor = CTR.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var counter = this._counter;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                counter = this._counter = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            var keystream = counter.slice(0);\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Increment counter\n\t            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    CTR.Decryptor = Encryptor;\n\n\t    return CTR;\n\t}());\n\n\n\treturn CryptoJS.mode.CTR;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/mode-ctr.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ecb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ecb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Electronic Codebook block mode.\n\t */\n\tCryptoJS.mode.ECB = (function () {\n\t    var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    ECB.Encryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.encryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    ECB.Decryptor = ECB.extend({\n\t        processBlock: function (words, offset) {\n\t            this._cipher.decryptBlock(words, offset);\n\t        }\n\t    });\n\n\t    return ECB;\n\t}());\n\n\n\treturn CryptoJS.mode.ECB;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/mode-ecb.js?");

/***/ }),

/***/ "./node_modules/crypto-js/mode-ofb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ofb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Output Feedback block mode.\n\t */\n\tCryptoJS.mode.OFB = (function () {\n\t    var OFB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t    var Encryptor = OFB.Encryptor = OFB.extend({\n\t        processBlock: function (words, offset) {\n\t            // Shortcuts\n\t            var cipher = this._cipher\n\t            var blockSize = cipher.blockSize;\n\t            var iv = this._iv;\n\t            var keystream = this._keystream;\n\n\t            // Generate keystream\n\t            if (iv) {\n\t                keystream = this._keystream = iv.slice(0);\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            }\n\t            cipher.encryptBlock(keystream, 0);\n\n\t            // Encrypt\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= keystream[i];\n\t            }\n\t        }\n\t    });\n\n\t    OFB.Decryptor = Encryptor;\n\n\t    return OFB;\n\t}());\n\n\n\treturn CryptoJS.mode.OFB;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/mode-ofb.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-ansix923.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-ansix923.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ANSI X.923 padding strategy.\n\t */\n\tCryptoJS.pad.AnsiX923 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcuts\n\t        var dataSigBytes = data.sigBytes;\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;\n\n\t        // Compute last byte position\n\t        var lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\n\t        data.sigBytes += nPaddingBytes;\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Ansix923;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/pad-ansix923.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso10126.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso10126.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO 10126 padding strategy.\n\t */\n\tCryptoJS.pad.Iso10126 = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Count padding bytes\n\t        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t        // Pad\n\t        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).\n\t             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));\n\t    },\n\n\t    unpad: function (data) {\n\t        // Get number of padding bytes from last byte\n\t        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t        // Remove padding\n\t        data.sigBytes -= nPaddingBytes;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso10126;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/pad-iso10126.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso97971.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso97971.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * ISO/IEC 9797-1 Padding Method 2.\n\t */\n\tCryptoJS.pad.Iso97971 = {\n\t    pad: function (data, blockSize) {\n\t        // Add 0x80 byte\n\t        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));\n\n\t        // Zero pad the rest\n\t        CryptoJS.pad.ZeroPadding.pad(data, blockSize);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Remove zero padding\n\t        CryptoJS.pad.ZeroPadding.unpad(data);\n\n\t        // Remove one more byte -- the 0x80 byte\n\t        data.sigBytes--;\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.Iso97971;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/pad-iso97971.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-nopadding.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/pad-nopadding.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * A noop padding strategy.\n\t */\n\tCryptoJS.pad.NoPadding = {\n\t    pad: function () {\n\t    },\n\n\t    unpad: function () {\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.NoPadding;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/pad-nopadding.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pad-zeropadding.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/pad-zeropadding.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Zero padding strategy.\n\t */\n\tCryptoJS.pad.ZeroPadding = {\n\t    pad: function (data, blockSize) {\n\t        // Shortcut\n\t        var blockSizeBytes = blockSize * 4;\n\n\t        // Pad\n\t        data.clamp();\n\t        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);\n\t    },\n\n\t    unpad: function (data) {\n\t        // Shortcut\n\t        var dataWords = data.words;\n\n\t        // Unpad\n\t        var i = data.sigBytes - 1;\n\t        for (var i = data.sigBytes - 1; i >= 0; i--) {\n\t            if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {\n\t                data.sigBytes = i + 1;\n\t                break;\n\t            }\n\t        }\n\t    }\n\t};\n\n\n\treturn CryptoJS.pad.ZeroPadding;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/pad-zeropadding.js?");

/***/ }),

/***/ "./node_modules/crypto-js/pbkdf2.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/pbkdf2.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"), __webpack_require__(/*! ./hmac */ \"./node_modules/crypto-js/hmac.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\t    var HMAC = C_algo.HMAC;\n\n\t    /**\n\t     * Password-Based Key Derivation Function 2 algorithm.\n\t     */\n\t    var PBKDF2 = C_algo.PBKDF2 = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hasher to use. Default: SHA256\n\t         * @property {number} iterations The number of iterations to perform. Default: 250000\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: SHA256,\n\t            iterations: 250000\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create();\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Computes the Password-Based Key Derivation Function 2.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init HMAC\n\t            var hmac = HMAC.create(cfg.hasher, password);\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\t            var blockIndex = WordArray.create([0x00000001]);\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var blockIndexWords = blockIndex.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                var block = hmac.update(salt).finalize(blockIndex);\n\t                hmac.reset();\n\n\t                // Shortcuts\n\t                var blockWords = block.words;\n\t                var blockWordsLength = blockWords.length;\n\n\t                // Iterations\n\t                var intermediate = block;\n\t                for (var i = 1; i < iterations; i++) {\n\t                    intermediate = hmac.finalize(intermediate);\n\t                    hmac.reset();\n\n\t                    // Shortcut\n\t                    var intermediateWords = intermediate.words;\n\n\t                    // XOR intermediate with block\n\t                    for (var j = 0; j < blockWordsLength; j++) {\n\t                        blockWords[j] ^= intermediateWords[j];\n\t                    }\n\t                }\n\n\t                derivedKey.concat(block);\n\t                blockIndexWords[0]++;\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Computes the Password-Based Key Derivation Function 2.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.PBKDF2(password, salt);\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.PBKDF2 = function (password, salt, cfg) {\n\t        return PBKDF2.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.PBKDF2;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/pbkdf2.js?");

/***/ }),

/***/ "./node_modules/crypto-js/rabbit-legacy.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/rabbit-legacy.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm.\n\t     *\n\t     * This is a legacy version that neglected to convert the key to little-endian.\n\t     * This error doesn't affect the cipher's security,\n\t     * but it does affect its compatibility with other implementations.\n\t     */\n\t    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);\n\t}());\n\n\n\treturn CryptoJS.RabbitLegacy;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/rabbit-legacy.js?");

/***/ }),

/***/ "./node_modules/crypto-js/rabbit.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/rabbit.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable objects\n\t    var S  = [];\n\t    var C_ = [];\n\t    var G  = [];\n\n\t    /**\n\t     * Rabbit stream cipher algorithm\n\t     */\n\t    var Rabbit = C_algo.Rabbit = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var K = this._key.words;\n\t            var iv = this.cfg.iv;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Generate initial state values\n\t            var X = this._X = [\n\t                K[0], (K[3] << 16) | (K[2] >>> 16),\n\t                K[1], (K[0] << 16) | (K[3] >>> 16),\n\t                K[2], (K[1] << 16) | (K[0] >>> 16),\n\t                K[3], (K[2] << 16) | (K[1] >>> 16)\n\t            ];\n\n\t            // Generate initial counter values\n\t            var C = this._C = [\n\t                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n\t                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n\t                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n\t                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)\n\t            ];\n\n\t            // Carry bit\n\t            this._b = 0;\n\n\t            // Iterate the system four times\n\t            for (var i = 0; i < 4; i++) {\n\t                nextState.call(this);\n\t            }\n\n\t            // Modify the counters\n\t            for (var i = 0; i < 8; i++) {\n\t                C[i] ^= X[(i + 4) & 7];\n\t            }\n\n\t            // IV setup\n\t            if (iv) {\n\t                // Shortcuts\n\t                var IV = iv.words;\n\t                var IV_0 = IV[0];\n\t                var IV_1 = IV[1];\n\n\t                // Generate four subvectors\n\t                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n\t                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n\t                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n\t                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);\n\n\t                // Modify counter values\n\t                C[0] ^= i0;\n\t                C[1] ^= i1;\n\t                C[2] ^= i2;\n\t                C[3] ^= i3;\n\t                C[4] ^= i0;\n\t                C[5] ^= i1;\n\t                C[6] ^= i2;\n\t                C[7] ^= i3;\n\n\t                // Iterate the system four times\n\t                for (var i = 0; i < 4; i++) {\n\t                    nextState.call(this);\n\t                }\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var X = this._X;\n\n\t            // Iterate the system\n\t            nextState.call(this);\n\n\t            // Generate four keystream words\n\t            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n\t            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n\t            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n\t            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n\t            for (var i = 0; i < 4; i++) {\n\t                // Swap endian\n\t                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |\n\t                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);\n\n\t                // Encrypt\n\t                M[offset + i] ^= S[i];\n\t            }\n\t        },\n\n\t        blockSize: 128/32,\n\n\t        ivSize: 64/32\n\t    });\n\n\t    function nextState() {\n\t        // Shortcuts\n\t        var X = this._X;\n\t        var C = this._C;\n\n\t        // Save old counter values\n\t        for (var i = 0; i < 8; i++) {\n\t            C_[i] = C[i];\n\t        }\n\n\t        // Calculate new counter values\n\t        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n\t        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n\t        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n\t        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n\t        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n\t        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n\t        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n\t        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n\t        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n\t        // Calculate the g-values\n\t        for (var i = 0; i < 8; i++) {\n\t            var gx = X[i] + C[i];\n\n\t            // Construct high and low argument for squaring\n\t            var ga = gx & 0xffff;\n\t            var gb = gx >>> 16;\n\n\t            // Calculate high and low result of squaring\n\t            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n\t            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n\t            // High XOR low\n\t            G[i] = gh ^ gl;\n\t        }\n\n\t        // Calculate new state values\n\t        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n\t        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;\n\t        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n\t        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;\n\t        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n\t        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;\n\t        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n\t        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.Rabbit = StreamCipher._createHelper(Rabbit);\n\t}());\n\n\n\treturn CryptoJS.Rabbit;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/rabbit.js?");

/***/ }),

/***/ "./node_modules/crypto-js/rc4.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/rc4.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var StreamCipher = C_lib.StreamCipher;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * RC4 stream cipher algorithm.\n\t     */\n\t    var RC4 = C_algo.RC4 = StreamCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            var keySigBytes = key.sigBytes;\n\n\t            // Init sbox\n\t            var S = this._S = [];\n\t            for (var i = 0; i < 256; i++) {\n\t                S[i] = i;\n\t            }\n\n\t            // Key setup\n\t            for (var i = 0, j = 0; i < 256; i++) {\n\t                var keyByteIndex = i % keySigBytes;\n\t                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\n\n\t                j = (j + S[i] + keyByte) % 256;\n\n\t                // Swap\n\t                var t = S[i];\n\t                S[i] = S[j];\n\t                S[j] = t;\n\t            }\n\n\t            // Counters\n\t            this._i = this._j = 0;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            M[offset] ^= generateKeystreamWord.call(this);\n\t        },\n\n\t        keySize: 256/32,\n\n\t        ivSize: 0\n\t    });\n\n\t    function generateKeystreamWord() {\n\t        // Shortcuts\n\t        var S = this._S;\n\t        var i = this._i;\n\t        var j = this._j;\n\n\t        // Generate keystream word\n\t        var keystreamWord = 0;\n\t        for (var n = 0; n < 4; n++) {\n\t            i = (i + 1) % 256;\n\t            j = (j + S[i]) % 256;\n\n\t            // Swap\n\t            var t = S[i];\n\t            S[i] = S[j];\n\t            S[j] = t;\n\n\t            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\n\t        }\n\n\t        // Update counters\n\t        this._i = i;\n\t        this._j = j;\n\n\t        return keystreamWord;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4 = StreamCipher._createHelper(RC4);\n\n\t    /**\n\t     * Modified RC4 stream cipher algorithm.\n\t     */\n\t    var RC4Drop = C_algo.RC4Drop = RC4.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} drop The number of keystream words to drop. Default 192\n\t         */\n\t        cfg: RC4.cfg.extend({\n\t            drop: 192\n\t        }),\n\n\t        _doReset: function () {\n\t            RC4._doReset.call(this);\n\n\t            // Drop\n\t            for (var i = this.cfg.drop; i > 0; i--) {\n\t                generateKeystreamWord.call(this);\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.RC4Drop = StreamCipher._createHelper(RC4Drop);\n\t}());\n\n\n\treturn CryptoJS.RC4;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/rc4.js?");

/***/ }),

/***/ "./node_modules/crypto-js/ripemd160.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/ripemd160.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/** @preserve\n\t(c) 2012 by Cdric Mesnil. All rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\t    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\t    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t*/\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var _zl = WordArray.create([\n\t        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,\n\t        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,\n\t        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,\n\t        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);\n\t    var _zr = WordArray.create([\n\t        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,\n\t        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,\n\t        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,\n\t        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,\n\t        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);\n\t    var _sl = WordArray.create([\n\t         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,\n\t        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,\n\t        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,\n\t          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,\n\t        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);\n\t    var _sr = WordArray.create([\n\t        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,\n\t        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,\n\t        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,\n\t        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,\n\t        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);\n\n\t    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\n\t    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\n\t    /**\n\t     * RIPEMD160 hash algorithm.\n\t     */\n\t    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                // Swap\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\t            // Shortcut\n\t            var H  = this._hash.words;\n\t            var hl = _hl.words;\n\t            var hr = _hr.words;\n\t            var zl = _zl.words;\n\t            var zr = _zr.words;\n\t            var sl = _sl.words;\n\t            var sr = _sr.words;\n\n\t            // Working variables\n\t            var al, bl, cl, dl, el;\n\t            var ar, br, cr, dr, er;\n\n\t            ar = al = H[0];\n\t            br = bl = H[1];\n\t            cr = cl = H[2];\n\t            dr = dl = H[3];\n\t            er = el = H[4];\n\t            // Computation\n\t            var t;\n\t            for (var i = 0; i < 80; i += 1) {\n\t                t = (al +  M[offset+zl[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f1(bl,cl,dl) + hl[0];\n\t                } else if (i<32) {\n\t\t            t +=  f2(bl,cl,dl) + hl[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(bl,cl,dl) + hl[2];\n\t                } else if (i<64) {\n\t\t            t +=  f4(bl,cl,dl) + hl[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f5(bl,cl,dl) + hl[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sl[i]);\n\t                t = (t+el)|0;\n\t                al = el;\n\t                el = dl;\n\t                dl = rotl(cl, 10);\n\t                cl = bl;\n\t                bl = t;\n\n\t                t = (ar + M[offset+zr[i]])|0;\n\t                if (i<16){\n\t\t            t +=  f5(br,cr,dr) + hr[0];\n\t                } else if (i<32) {\n\t\t            t +=  f4(br,cr,dr) + hr[1];\n\t                } else if (i<48) {\n\t\t            t +=  f3(br,cr,dr) + hr[2];\n\t                } else if (i<64) {\n\t\t            t +=  f2(br,cr,dr) + hr[3];\n\t                } else {// if (i<80) {\n\t\t            t +=  f1(br,cr,dr) + hr[4];\n\t                }\n\t                t = t|0;\n\t                t =  rotl(t,sr[i]) ;\n\t                t = (t+er)|0;\n\t                ar = er;\n\t                er = dr;\n\t                dr = rotl(cr, 10);\n\t                cr = br;\n\t                br = t;\n\t            }\n\t            // Intermediate hash value\n\t            t    = (H[1] + cl + dr)|0;\n\t            H[1] = (H[2] + dl + er)|0;\n\t            H[2] = (H[3] + el + ar)|0;\n\t            H[3] = (H[4] + al + br)|0;\n\t            H[4] = (H[0] + bl + cr)|0;\n\t            H[0] =  t;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)\n\t            );\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 5; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                // Swap\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\n\t    function f1(x, y, z) {\n\t        return ((x) ^ (y) ^ (z));\n\n\t    }\n\n\t    function f2(x, y, z) {\n\t        return (((x)&(y)) | ((~x)&(z)));\n\t    }\n\n\t    function f3(x, y, z) {\n\t        return (((x) | (~(y))) ^ (z));\n\t    }\n\n\t    function f4(x, y, z) {\n\t        return (((x) & (z)) | ((y)&(~(z))));\n\t    }\n\n\t    function f5(x, y, z) {\n\t        return ((x) ^ ((y) |(~(z))));\n\n\t    }\n\n\t    function rotl(x,n) {\n\t        return (x<<n) | (x>>>(32-n));\n\t    }\n\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.RIPEMD160('message');\n\t     *     var hash = CryptoJS.RIPEMD160(wordArray);\n\t     */\n\t    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n\t     */\n\t    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);\n\t}(Math));\n\n\n\treturn CryptoJS.RIPEMD160;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/ripemd160.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha1.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-1 hash algorithm.\n\t     */\n\t    var SHA1 = C_algo.SHA1 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476,\n\t                0xc3d2e1f0\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\n\t            // Computation\n\t            for (var i = 0; i < 80; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t                    W[i] = (n << 1) | (n >>> 31);\n\t                }\n\n\t                var t = ((a << 5) | (a >>> 27)) + e + W[i];\n\t                if (i < 20) {\n\t                    t += ((b & c) | (~b & d)) + 0x5a827999;\n\t                } else if (i < 40) {\n\t                    t += (b ^ c ^ d) + 0x6ed9eba1;\n\t                } else if (i < 60) {\n\t                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n\t                } else /* if (i < 80) */ {\n\t                    t += (b ^ c ^ d) - 0x359d3e2a;\n\t                }\n\n\t                e = d;\n\t                d = c;\n\t                c = (b << 30) | (b >>> 2);\n\t                b = a;\n\t                a = t;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA1('message');\n\t     *     var hash = CryptoJS.SHA1(wordArray);\n\t     */\n\t    C.SHA1 = Hasher._createHelper(SHA1);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA1(message, key);\n\t     */\n\t    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t}());\n\n\n\treturn CryptoJS.SHA1;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/sha1.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha224.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha224.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./sha256 */ \"./node_modules/crypto-js/sha256.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\n\t    /**\n\t     * SHA-224 hash algorithm.\n\t     */\n\t    var SHA224 = C_algo.SHA224 = SHA256.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA256._doFinalize.call(this);\n\n\t            hash.sigBytes -= 4;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA224('message');\n\t     *     var hash = CryptoJS.SHA224(wordArray);\n\t     */\n\t    C.SHA224 = SHA256._createHelper(SHA224);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA224(message, key);\n\t     */\n\t    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);\n\t}());\n\n\n\treturn CryptoJS.SHA224;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/sha224.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha256.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha256.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/sha256.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha3.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha3.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var C_algo = C.algo;\n\n\t    // Constants tables\n\t    var RHO_OFFSETS = [];\n\t    var PI_INDEXES  = [];\n\t    var ROUND_CONSTANTS = [];\n\n\t    // Compute Constants\n\t    (function () {\n\t        // Compute rho offset constants\n\t        var x = 1, y = 0;\n\t        for (var t = 0; t < 24; t++) {\n\t            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;\n\n\t            var newX = y % 5;\n\t            var newY = (2 * x + 3 * y) % 5;\n\t            x = newX;\n\t            y = newY;\n\t        }\n\n\t        // Compute pi index constants\n\t        for (var x = 0; x < 5; x++) {\n\t            for (var y = 0; y < 5; y++) {\n\t                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n\t            }\n\t        }\n\n\t        // Compute round constants\n\t        var LFSR = 0x01;\n\t        for (var i = 0; i < 24; i++) {\n\t            var roundConstantMsw = 0;\n\t            var roundConstantLsw = 0;\n\n\t            for (var j = 0; j < 7; j++) {\n\t                if (LFSR & 0x01) {\n\t                    var bitPosition = (1 << j) - 1;\n\t                    if (bitPosition < 32) {\n\t                        roundConstantLsw ^= 1 << bitPosition;\n\t                    } else /* if (bitPosition >= 32) */ {\n\t                        roundConstantMsw ^= 1 << (bitPosition - 32);\n\t                    }\n\t                }\n\n\t                // Compute next LFSR\n\t                if (LFSR & 0x80) {\n\t                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n\t                    LFSR = (LFSR << 1) ^ 0x71;\n\t                } else {\n\t                    LFSR <<= 1;\n\t                }\n\t            }\n\n\t            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n\t        }\n\t    }());\n\n\t    // Reusable objects for temporary values\n\t    var T = [];\n\t    (function () {\n\t        for (var i = 0; i < 25; i++) {\n\t            T[i] = X64Word.create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-3 hash algorithm.\n\t     */\n\t    var SHA3 = C_algo.SHA3 = Hasher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} outputLength\n\t         *   The desired number of bits in the output hash.\n\t         *   Only values permitted are: 224, 256, 384, 512.\n\t         *   Default: 512\n\t         */\n\t        cfg: Hasher.cfg.extend({\n\t            outputLength: 512\n\t        }),\n\n\t        _doReset: function () {\n\t            var state = this._state = []\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = new X64Word.init();\n\t            }\n\n\t            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var nBlockSizeLanes = this.blockSize / 2;\n\n\t            // Absorb\n\t            for (var i = 0; i < nBlockSizeLanes; i++) {\n\t                // Shortcuts\n\t                var M2i  = M[offset + 2 * i];\n\t                var M2i1 = M[offset + 2 * i + 1];\n\n\t                // Swap endian\n\t                M2i = (\n\t                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)\n\t                );\n\t                M2i1 = (\n\t                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |\n\t                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Absorb message into state\n\t                var lane = state[i];\n\t                lane.high ^= M2i1;\n\t                lane.low  ^= M2i;\n\t            }\n\n\t            // Rounds\n\t            for (var round = 0; round < 24; round++) {\n\t                // Theta\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Mix column lanes\n\t                    var tMsw = 0, tLsw = 0;\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        tMsw ^= lane.high;\n\t                        tLsw ^= lane.low;\n\t                    }\n\n\t                    // Temporary values\n\t                    var Tx = T[x];\n\t                    Tx.high = tMsw;\n\t                    Tx.low  = tLsw;\n\t                }\n\t                for (var x = 0; x < 5; x++) {\n\t                    // Shortcuts\n\t                    var Tx4 = T[(x + 4) % 5];\n\t                    var Tx1 = T[(x + 1) % 5];\n\t                    var Tx1Msw = Tx1.high;\n\t                    var Tx1Lsw = Tx1.low;\n\n\t                    // Mix surrounding columns\n\t                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n\t                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n\t                    for (var y = 0; y < 5; y++) {\n\t                        var lane = state[x + 5 * y];\n\t                        lane.high ^= tMsw;\n\t                        lane.low  ^= tLsw;\n\t                    }\n\t                }\n\n\t                // Rho Pi\n\t                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {\n\t                    var tMsw;\n\t                    var tLsw;\n\n\t                    // Shortcuts\n\t                    var lane = state[laneIndex];\n\t                    var laneMsw = lane.high;\n\t                    var laneLsw = lane.low;\n\t                    var rhoOffset = RHO_OFFSETS[laneIndex];\n\n\t                    // Rotate lanes\n\t                    if (rhoOffset < 32) {\n\t                        tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n\t                        tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n\t                    } else /* if (rhoOffset >= 32) */ {\n\t                        tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n\t                        tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n\t                    }\n\n\t                    // Transpose lanes\n\t                    var TPiLane = T[PI_INDEXES[laneIndex]];\n\t                    TPiLane.high = tMsw;\n\t                    TPiLane.low  = tLsw;\n\t                }\n\n\t                // Rho pi at x = y = 0\n\t                var T0 = T[0];\n\t                var state0 = state[0];\n\t                T0.high = state0.high;\n\t                T0.low  = state0.low;\n\n\t                // Chi\n\t                for (var x = 0; x < 5; x++) {\n\t                    for (var y = 0; y < 5; y++) {\n\t                        // Shortcuts\n\t                        var laneIndex = x + 5 * y;\n\t                        var lane = state[laneIndex];\n\t                        var TLane = T[laneIndex];\n\t                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];\n\t                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n\t                        // Mix rows\n\t                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n\t                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);\n\t                    }\n\t                }\n\n\t                // Iota\n\t                var lane = state[0];\n\t                var roundConstant = ROUND_CONSTANTS[round];\n\t                lane.high ^= roundConstant.high;\n\t                lane.low  ^= roundConstant.low;\n\t            }\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\t            var blockSizeBits = this.blockSize * 32;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);\n\t            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var state = this._state;\n\t            var outputLengthBytes = this.cfg.outputLength / 8;\n\t            var outputLengthLanes = outputLengthBytes / 8;\n\n\t            // Squeeze\n\t            var hashWords = [];\n\t            for (var i = 0; i < outputLengthLanes; i++) {\n\t                // Shortcuts\n\t                var lane = state[i];\n\t                var laneMsw = lane.high;\n\t                var laneLsw = lane.low;\n\n\t                // Swap endian\n\t                laneMsw = (\n\t                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)\n\t                );\n\t                laneLsw = (\n\t                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |\n\t                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)\n\t                );\n\n\t                // Squeeze state to retrieve hash\n\t                hashWords.push(laneLsw);\n\t                hashWords.push(laneMsw);\n\t            }\n\n\t            // Return final computed hash\n\t            return new WordArray.init(hashWords, outputLengthBytes);\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\n\t            var state = clone._state = this._state.slice(0);\n\t            for (var i = 0; i < 25; i++) {\n\t                state[i] = state[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA3('message');\n\t     *     var hash = CryptoJS.SHA3(wordArray);\n\t     */\n\t    C.SHA3 = Hasher._createHelper(SHA3);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA3(message, key);\n\t     */\n\t    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA3;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/sha3.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha384.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha384.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"), __webpack_require__(/*! ./sha512 */ \"./node_modules/crypto-js/sha512.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA512 = C_algo.SHA512;\n\n\t    /**\n\t     * SHA-384 hash algorithm.\n\t     */\n\t    var SHA384 = C_algo.SHA384 = SHA512.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),\n\t                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),\n\t                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),\n\t                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA512._doFinalize.call(this);\n\n\t            hash.sigBytes -= 16;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA384('message');\n\t     *     var hash = CryptoJS.SHA384(wordArray);\n\t     */\n\t    C.SHA384 = SHA512._createHelper(SHA384);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA384(message, key);\n\t     */\n\t    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);\n\t}());\n\n\n\treturn CryptoJS.SHA384;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/sha384.js?");

/***/ }),

/***/ "./node_modules/crypto-js/sha512.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha512.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./x64-core */ \"./node_modules/crypto-js/x64-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_x64 = C.x64;\n\t    var X64Word = C_x64.Word;\n\t    var X64WordArray = C_x64.WordArray;\n\t    var C_algo = C.algo;\n\n\t    function X64Word_create() {\n\t        return X64Word.create.apply(X64Word, arguments);\n\t    }\n\n\t    // Constants\n\t    var K = [\n\t        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),\n\t        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),\n\t        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),\n\t        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),\n\t        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),\n\t        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),\n\t        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),\n\t        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),\n\t        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),\n\t        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),\n\t        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),\n\t        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),\n\t        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),\n\t        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),\n\t        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),\n\t        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),\n\t        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),\n\t        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),\n\t        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),\n\t        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),\n\t        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),\n\t        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),\n\t        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),\n\t        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),\n\t        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),\n\t        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),\n\t        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),\n\t        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),\n\t        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),\n\t        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),\n\t        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),\n\t        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),\n\t        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),\n\t        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),\n\t        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),\n\t        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),\n\t        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),\n\t        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),\n\t        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),\n\t        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)\n\t    ];\n\n\t    // Reusable objects\n\t    var W = [];\n\t    (function () {\n\t        for (var i = 0; i < 80; i++) {\n\t            W[i] = X64Word_create();\n\t        }\n\t    }());\n\n\t    /**\n\t     * SHA-512 hash algorithm.\n\t     */\n\t    var SHA512 = C_algo.SHA512 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new X64WordArray.init([\n\t                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),\n\t                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),\n\t                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),\n\t                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var H0 = H[0];\n\t            var H1 = H[1];\n\t            var H2 = H[2];\n\t            var H3 = H[3];\n\t            var H4 = H[4];\n\t            var H5 = H[5];\n\t            var H6 = H[6];\n\t            var H7 = H[7];\n\n\t            var H0h = H0.high;\n\t            var H0l = H0.low;\n\t            var H1h = H1.high;\n\t            var H1l = H1.low;\n\t            var H2h = H2.high;\n\t            var H2l = H2.low;\n\t            var H3h = H3.high;\n\t            var H3l = H3.low;\n\t            var H4h = H4.high;\n\t            var H4l = H4.low;\n\t            var H5h = H5.high;\n\t            var H5l = H5.low;\n\t            var H6h = H6.high;\n\t            var H6l = H6.low;\n\t            var H7h = H7.high;\n\t            var H7l = H7.low;\n\n\t            // Working variables\n\t            var ah = H0h;\n\t            var al = H0l;\n\t            var bh = H1h;\n\t            var bl = H1l;\n\t            var ch = H2h;\n\t            var cl = H2l;\n\t            var dh = H3h;\n\t            var dl = H3l;\n\t            var eh = H4h;\n\t            var el = H4l;\n\t            var fh = H5h;\n\t            var fl = H5l;\n\t            var gh = H6h;\n\t            var gl = H6l;\n\t            var hh = H7h;\n\t            var hl = H7l;\n\n\t            // Rounds\n\t            for (var i = 0; i < 80; i++) {\n\t                var Wil;\n\t                var Wih;\n\n\t                // Shortcut\n\t                var Wi = W[i];\n\n\t                // Extend message\n\t                if (i < 16) {\n\t                    Wih = Wi.high = M[offset + i * 2]     | 0;\n\t                    Wil = Wi.low  = M[offset + i * 2 + 1] | 0;\n\t                } else {\n\t                    // Gamma0\n\t                    var gamma0x  = W[i - 15];\n\t                    var gamma0xh = gamma0x.high;\n\t                    var gamma0xl = gamma0x.low;\n\t                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);\n\t                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n\n\t                    // Gamma1\n\t                    var gamma1x  = W[i - 2];\n\t                    var gamma1xh = gamma1x.high;\n\t                    var gamma1xl = gamma1x.low;\n\t                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);\n\t                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n\n\t                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n\t                    var Wi7  = W[i - 7];\n\t                    var Wi7h = Wi7.high;\n\t                    var Wi7l = Wi7.low;\n\n\t                    var Wi16  = W[i - 16];\n\t                    var Wi16h = Wi16.high;\n\t                    var Wi16l = Wi16.low;\n\n\t                    Wil = gamma0l + Wi7l;\n\t                    Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + gamma1l;\n\t                    Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n\t                    Wil = Wil + Wi16l;\n\t                    Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n\n\t                    Wi.high = Wih;\n\t                    Wi.low  = Wil;\n\t                }\n\n\t                var chh  = (eh & fh) ^ (~eh & gh);\n\t                var chl  = (el & fl) ^ (~el & gl);\n\t                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n\t                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n\t                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));\n\t                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));\n\t                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));\n\t                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));\n\n\t                // t1 = h + sigma1 + ch + K[i] + W[i]\n\t                var Ki  = K[i];\n\t                var Kih = Ki.high;\n\t                var Kil = Ki.low;\n\n\t                var t1l = hl + sigma1l;\n\t                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + chl;\n\t                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Kil;\n\t                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n\t                var t1l = t1l + Wil;\n\t                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n\n\t                // t2 = sigma0 + maj\n\t                var t2l = sigma0l + majl;\n\t                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n\t                // Update working variables\n\t                hh = gh;\n\t                hl = gl;\n\t                gh = fh;\n\t                gl = fl;\n\t                fh = eh;\n\t                fl = el;\n\t                el = (dl + t1l) | 0;\n\t                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n\t                dh = ch;\n\t                dl = cl;\n\t                ch = bh;\n\t                cl = bl;\n\t                bh = ah;\n\t                bl = al;\n\t                al = (t1l + t2l) | 0;\n\t                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H0l = H0.low  = (H0l + al);\n\t            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\n\t            H1l = H1.low  = (H1l + bl);\n\t            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\n\t            H2l = H2.low  = (H2l + cl);\n\t            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\n\t            H3l = H3.low  = (H3l + dl);\n\t            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\n\t            H4l = H4.low  = (H4l + el);\n\t            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\n\t            H5l = H5.low  = (H5l + fl);\n\t            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\n\t            H6l = H6.low  = (H6l + gl);\n\t            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\n\t            H7l = H7.low  = (H7l + hl);\n\t            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Convert hash to 32-bit word array before returning\n\t            var hash = this._hash.toX32();\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        },\n\n\t        blockSize: 1024/32\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA512('message');\n\t     *     var hash = CryptoJS.SHA512(wordArray);\n\t     */\n\t    C.SHA512 = Hasher._createHelper(SHA512);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA512(message, key);\n\t     */\n\t    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);\n\t}());\n\n\n\treturn CryptoJS.SHA512;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/sha512.js?");

/***/ }),

/***/ "./node_modules/crypto-js/tripledes.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/tripledes.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory, undef) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"), __webpack_require__(/*! ./enc-base64 */ \"./node_modules/crypto-js/enc-base64.js\"), __webpack_require__(/*! ./md5 */ \"./node_modules/crypto-js/md5.js\"), __webpack_require__(/*! ./evpkdf */ \"./node_modules/crypto-js/evpkdf.js\"), __webpack_require__(/*! ./cipher-core */ \"./node_modules/crypto-js/cipher-core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Permuted Choice 1 constants\n\t    var PC1 = [\n\t        57, 49, 41, 33, 25, 17, 9,  1,\n\t        58, 50, 42, 34, 26, 18, 10, 2,\n\t        59, 51, 43, 35, 27, 19, 11, 3,\n\t        60, 52, 44, 36, 63, 55, 47, 39,\n\t        31, 23, 15, 7,  62, 54, 46, 38,\n\t        30, 22, 14, 6,  61, 53, 45, 37,\n\t        29, 21, 13, 5,  28, 20, 12, 4\n\t    ];\n\n\t    // Permuted Choice 2 constants\n\t    var PC2 = [\n\t        14, 17, 11, 24, 1,  5,\n\t        3,  28, 15, 6,  21, 10,\n\t        23, 19, 12, 4,  26, 8,\n\t        16, 7,  27, 20, 13, 2,\n\t        41, 52, 31, 37, 47, 55,\n\t        30, 40, 51, 45, 33, 48,\n\t        44, 49, 39, 56, 34, 53,\n\t        46, 42, 50, 36, 29, 32\n\t    ];\n\n\t    // Cumulative bit shift constants\n\t    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n\t    // SBOXes and round permutation constants\n\t    var SBOX_P = [\n\t        {\n\t            0x0: 0x808200,\n\t            0x10000000: 0x8000,\n\t            0x20000000: 0x808002,\n\t            0x30000000: 0x2,\n\t            0x40000000: 0x200,\n\t            0x50000000: 0x808202,\n\t            0x60000000: 0x800202,\n\t            0x70000000: 0x800000,\n\t            0x80000000: 0x202,\n\t            0x90000000: 0x800200,\n\t            0xa0000000: 0x8200,\n\t            0xb0000000: 0x808000,\n\t            0xc0000000: 0x8002,\n\t            0xd0000000: 0x800002,\n\t            0xe0000000: 0x0,\n\t            0xf0000000: 0x8202,\n\t            0x8000000: 0x0,\n\t            0x18000000: 0x808202,\n\t            0x28000000: 0x8202,\n\t            0x38000000: 0x8000,\n\t            0x48000000: 0x808200,\n\t            0x58000000: 0x200,\n\t            0x68000000: 0x808002,\n\t            0x78000000: 0x2,\n\t            0x88000000: 0x800200,\n\t            0x98000000: 0x8200,\n\t            0xa8000000: 0x808000,\n\t            0xb8000000: 0x800202,\n\t            0xc8000000: 0x800002,\n\t            0xd8000000: 0x8002,\n\t            0xe8000000: 0x202,\n\t            0xf8000000: 0x800000,\n\t            0x1: 0x8000,\n\t            0x10000001: 0x2,\n\t            0x20000001: 0x808200,\n\t            0x30000001: 0x800000,\n\t            0x40000001: 0x808002,\n\t            0x50000001: 0x8200,\n\t            0x60000001: 0x200,\n\t            0x70000001: 0x800202,\n\t            0x80000001: 0x808202,\n\t            0x90000001: 0x808000,\n\t            0xa0000001: 0x800002,\n\t            0xb0000001: 0x8202,\n\t            0xc0000001: 0x202,\n\t            0xd0000001: 0x800200,\n\t            0xe0000001: 0x8002,\n\t            0xf0000001: 0x0,\n\t            0x8000001: 0x808202,\n\t            0x18000001: 0x808000,\n\t            0x28000001: 0x800000,\n\t            0x38000001: 0x200,\n\t            0x48000001: 0x8000,\n\t            0x58000001: 0x800002,\n\t            0x68000001: 0x2,\n\t            0x78000001: 0x8202,\n\t            0x88000001: 0x8002,\n\t            0x98000001: 0x800202,\n\t            0xa8000001: 0x202,\n\t            0xb8000001: 0x808200,\n\t            0xc8000001: 0x800200,\n\t            0xd8000001: 0x0,\n\t            0xe8000001: 0x8200,\n\t            0xf8000001: 0x808002\n\t        },\n\t        {\n\t            0x0: 0x40084010,\n\t            0x1000000: 0x4000,\n\t            0x2000000: 0x80000,\n\t            0x3000000: 0x40080010,\n\t            0x4000000: 0x40000010,\n\t            0x5000000: 0x40084000,\n\t            0x6000000: 0x40004000,\n\t            0x7000000: 0x10,\n\t            0x8000000: 0x84000,\n\t            0x9000000: 0x40004010,\n\t            0xa000000: 0x40000000,\n\t            0xb000000: 0x84010,\n\t            0xc000000: 0x80010,\n\t            0xd000000: 0x0,\n\t            0xe000000: 0x4010,\n\t            0xf000000: 0x40080000,\n\t            0x800000: 0x40004000,\n\t            0x1800000: 0x84010,\n\t            0x2800000: 0x10,\n\t            0x3800000: 0x40004010,\n\t            0x4800000: 0x40084010,\n\t            0x5800000: 0x40000000,\n\t            0x6800000: 0x80000,\n\t            0x7800000: 0x40080010,\n\t            0x8800000: 0x80010,\n\t            0x9800000: 0x0,\n\t            0xa800000: 0x4000,\n\t            0xb800000: 0x40080000,\n\t            0xc800000: 0x40000010,\n\t            0xd800000: 0x84000,\n\t            0xe800000: 0x40084000,\n\t            0xf800000: 0x4010,\n\t            0x10000000: 0x0,\n\t            0x11000000: 0x40080010,\n\t            0x12000000: 0x40004010,\n\t            0x13000000: 0x40084000,\n\t            0x14000000: 0x40080000,\n\t            0x15000000: 0x10,\n\t            0x16000000: 0x84010,\n\t            0x17000000: 0x4000,\n\t            0x18000000: 0x4010,\n\t            0x19000000: 0x80000,\n\t            0x1a000000: 0x80010,\n\t            0x1b000000: 0x40000010,\n\t            0x1c000000: 0x84000,\n\t            0x1d000000: 0x40004000,\n\t            0x1e000000: 0x40000000,\n\t            0x1f000000: 0x40084010,\n\t            0x10800000: 0x84010,\n\t            0x11800000: 0x80000,\n\t            0x12800000: 0x40080000,\n\t            0x13800000: 0x4000,\n\t            0x14800000: 0x40004000,\n\t            0x15800000: 0x40084010,\n\t            0x16800000: 0x10,\n\t            0x17800000: 0x40000000,\n\t            0x18800000: 0x40084000,\n\t            0x19800000: 0x40000010,\n\t            0x1a800000: 0x40004010,\n\t            0x1b800000: 0x80010,\n\t            0x1c800000: 0x0,\n\t            0x1d800000: 0x4010,\n\t            0x1e800000: 0x40080010,\n\t            0x1f800000: 0x84000\n\t        },\n\t        {\n\t            0x0: 0x104,\n\t            0x100000: 0x0,\n\t            0x200000: 0x4000100,\n\t            0x300000: 0x10104,\n\t            0x400000: 0x10004,\n\t            0x500000: 0x4000004,\n\t            0x600000: 0x4010104,\n\t            0x700000: 0x4010000,\n\t            0x800000: 0x4000000,\n\t            0x900000: 0x4010100,\n\t            0xa00000: 0x10100,\n\t            0xb00000: 0x4010004,\n\t            0xc00000: 0x4000104,\n\t            0xd00000: 0x10000,\n\t            0xe00000: 0x4,\n\t            0xf00000: 0x100,\n\t            0x80000: 0x4010100,\n\t            0x180000: 0x4010004,\n\t            0x280000: 0x0,\n\t            0x380000: 0x4000100,\n\t            0x480000: 0x4000004,\n\t            0x580000: 0x10000,\n\t            0x680000: 0x10004,\n\t            0x780000: 0x104,\n\t            0x880000: 0x4,\n\t            0x980000: 0x100,\n\t            0xa80000: 0x4010000,\n\t            0xb80000: 0x10104,\n\t            0xc80000: 0x10100,\n\t            0xd80000: 0x4000104,\n\t            0xe80000: 0x4010104,\n\t            0xf80000: 0x4000000,\n\t            0x1000000: 0x4010100,\n\t            0x1100000: 0x10004,\n\t            0x1200000: 0x10000,\n\t            0x1300000: 0x4000100,\n\t            0x1400000: 0x100,\n\t            0x1500000: 0x4010104,\n\t            0x1600000: 0x4000004,\n\t            0x1700000: 0x0,\n\t            0x1800000: 0x4000104,\n\t            0x1900000: 0x4000000,\n\t            0x1a00000: 0x4,\n\t            0x1b00000: 0x10100,\n\t            0x1c00000: 0x4010000,\n\t            0x1d00000: 0x104,\n\t            0x1e00000: 0x10104,\n\t            0x1f00000: 0x4010004,\n\t            0x1080000: 0x4000000,\n\t            0x1180000: 0x104,\n\t            0x1280000: 0x4010100,\n\t            0x1380000: 0x0,\n\t            0x1480000: 0x10004,\n\t            0x1580000: 0x4000100,\n\t            0x1680000: 0x100,\n\t            0x1780000: 0x4010004,\n\t            0x1880000: 0x10000,\n\t            0x1980000: 0x4010104,\n\t            0x1a80000: 0x10104,\n\t            0x1b80000: 0x4000004,\n\t            0x1c80000: 0x4000104,\n\t            0x1d80000: 0x4010000,\n\t            0x1e80000: 0x4,\n\t            0x1f80000: 0x10100\n\t        },\n\t        {\n\t            0x0: 0x80401000,\n\t            0x10000: 0x80001040,\n\t            0x20000: 0x401040,\n\t            0x30000: 0x80400000,\n\t            0x40000: 0x0,\n\t            0x50000: 0x401000,\n\t            0x60000: 0x80000040,\n\t            0x70000: 0x400040,\n\t            0x80000: 0x80000000,\n\t            0x90000: 0x400000,\n\t            0xa0000: 0x40,\n\t            0xb0000: 0x80001000,\n\t            0xc0000: 0x80400040,\n\t            0xd0000: 0x1040,\n\t            0xe0000: 0x1000,\n\t            0xf0000: 0x80401040,\n\t            0x8000: 0x80001040,\n\t            0x18000: 0x40,\n\t            0x28000: 0x80400040,\n\t            0x38000: 0x80001000,\n\t            0x48000: 0x401000,\n\t            0x58000: 0x80401040,\n\t            0x68000: 0x0,\n\t            0x78000: 0x80400000,\n\t            0x88000: 0x1000,\n\t            0x98000: 0x80401000,\n\t            0xa8000: 0x400000,\n\t            0xb8000: 0x1040,\n\t            0xc8000: 0x80000000,\n\t            0xd8000: 0x400040,\n\t            0xe8000: 0x401040,\n\t            0xf8000: 0x80000040,\n\t            0x100000: 0x400040,\n\t            0x110000: 0x401000,\n\t            0x120000: 0x80000040,\n\t            0x130000: 0x0,\n\t            0x140000: 0x1040,\n\t            0x150000: 0x80400040,\n\t            0x160000: 0x80401000,\n\t            0x170000: 0x80001040,\n\t            0x180000: 0x80401040,\n\t            0x190000: 0x80000000,\n\t            0x1a0000: 0x80400000,\n\t            0x1b0000: 0x401040,\n\t            0x1c0000: 0x80001000,\n\t            0x1d0000: 0x400000,\n\t            0x1e0000: 0x40,\n\t            0x1f0000: 0x1000,\n\t            0x108000: 0x80400000,\n\t            0x118000: 0x80401040,\n\t            0x128000: 0x0,\n\t            0x138000: 0x401000,\n\t            0x148000: 0x400040,\n\t            0x158000: 0x80000000,\n\t            0x168000: 0x80001040,\n\t            0x178000: 0x40,\n\t            0x188000: 0x80000040,\n\t            0x198000: 0x1000,\n\t            0x1a8000: 0x80001000,\n\t            0x1b8000: 0x80400040,\n\t            0x1c8000: 0x1040,\n\t            0x1d8000: 0x80401000,\n\t            0x1e8000: 0x400000,\n\t            0x1f8000: 0x401040\n\t        },\n\t        {\n\t            0x0: 0x80,\n\t            0x1000: 0x1040000,\n\t            0x2000: 0x40000,\n\t            0x3000: 0x20000000,\n\t            0x4000: 0x20040080,\n\t            0x5000: 0x1000080,\n\t            0x6000: 0x21000080,\n\t            0x7000: 0x40080,\n\t            0x8000: 0x1000000,\n\t            0x9000: 0x20040000,\n\t            0xa000: 0x20000080,\n\t            0xb000: 0x21040080,\n\t            0xc000: 0x21040000,\n\t            0xd000: 0x0,\n\t            0xe000: 0x1040080,\n\t            0xf000: 0x21000000,\n\t            0x800: 0x1040080,\n\t            0x1800: 0x21000080,\n\t            0x2800: 0x80,\n\t            0x3800: 0x1040000,\n\t            0x4800: 0x40000,\n\t            0x5800: 0x20040080,\n\t            0x6800: 0x21040000,\n\t            0x7800: 0x20000000,\n\t            0x8800: 0x20040000,\n\t            0x9800: 0x0,\n\t            0xa800: 0x21040080,\n\t            0xb800: 0x1000080,\n\t            0xc800: 0x20000080,\n\t            0xd800: 0x21000000,\n\t            0xe800: 0x1000000,\n\t            0xf800: 0x40080,\n\t            0x10000: 0x40000,\n\t            0x11000: 0x80,\n\t            0x12000: 0x20000000,\n\t            0x13000: 0x21000080,\n\t            0x14000: 0x1000080,\n\t            0x15000: 0x21040000,\n\t            0x16000: 0x20040080,\n\t            0x17000: 0x1000000,\n\t            0x18000: 0x21040080,\n\t            0x19000: 0x21000000,\n\t            0x1a000: 0x1040000,\n\t            0x1b000: 0x20040000,\n\t            0x1c000: 0x40080,\n\t            0x1d000: 0x20000080,\n\t            0x1e000: 0x0,\n\t            0x1f000: 0x1040080,\n\t            0x10800: 0x21000080,\n\t            0x11800: 0x1000000,\n\t            0x12800: 0x1040000,\n\t            0x13800: 0x20040080,\n\t            0x14800: 0x20000000,\n\t            0x15800: 0x1040080,\n\t            0x16800: 0x80,\n\t            0x17800: 0x21040000,\n\t            0x18800: 0x40080,\n\t            0x19800: 0x21040080,\n\t            0x1a800: 0x0,\n\t            0x1b800: 0x21000000,\n\t            0x1c800: 0x1000080,\n\t            0x1d800: 0x40000,\n\t            0x1e800: 0x20040000,\n\t            0x1f800: 0x20000080\n\t        },\n\t        {\n\t            0x0: 0x10000008,\n\t            0x100: 0x2000,\n\t            0x200: 0x10200000,\n\t            0x300: 0x10202008,\n\t            0x400: 0x10002000,\n\t            0x500: 0x200000,\n\t            0x600: 0x200008,\n\t            0x700: 0x10000000,\n\t            0x800: 0x0,\n\t            0x900: 0x10002008,\n\t            0xa00: 0x202000,\n\t            0xb00: 0x8,\n\t            0xc00: 0x10200008,\n\t            0xd00: 0x202008,\n\t            0xe00: 0x2008,\n\t            0xf00: 0x10202000,\n\t            0x80: 0x10200000,\n\t            0x180: 0x10202008,\n\t            0x280: 0x8,\n\t            0x380: 0x200000,\n\t            0x480: 0x202008,\n\t            0x580: 0x10000008,\n\t            0x680: 0x10002000,\n\t            0x780: 0x2008,\n\t            0x880: 0x200008,\n\t            0x980: 0x2000,\n\t            0xa80: 0x10002008,\n\t            0xb80: 0x10200008,\n\t            0xc80: 0x0,\n\t            0xd80: 0x10202000,\n\t            0xe80: 0x202000,\n\t            0xf80: 0x10000000,\n\t            0x1000: 0x10002000,\n\t            0x1100: 0x10200008,\n\t            0x1200: 0x10202008,\n\t            0x1300: 0x2008,\n\t            0x1400: 0x200000,\n\t            0x1500: 0x10000000,\n\t            0x1600: 0x10000008,\n\t            0x1700: 0x202000,\n\t            0x1800: 0x202008,\n\t            0x1900: 0x0,\n\t            0x1a00: 0x8,\n\t            0x1b00: 0x10200000,\n\t            0x1c00: 0x2000,\n\t            0x1d00: 0x10002008,\n\t            0x1e00: 0x10202000,\n\t            0x1f00: 0x200008,\n\t            0x1080: 0x8,\n\t            0x1180: 0x202000,\n\t            0x1280: 0x200000,\n\t            0x1380: 0x10000008,\n\t            0x1480: 0x10002000,\n\t            0x1580: 0x2008,\n\t            0x1680: 0x10202008,\n\t            0x1780: 0x10200000,\n\t            0x1880: 0x10202000,\n\t            0x1980: 0x10200008,\n\t            0x1a80: 0x2000,\n\t            0x1b80: 0x202008,\n\t            0x1c80: 0x200008,\n\t            0x1d80: 0x0,\n\t            0x1e80: 0x10000000,\n\t            0x1f80: 0x10002008\n\t        },\n\t        {\n\t            0x0: 0x100000,\n\t            0x10: 0x2000401,\n\t            0x20: 0x400,\n\t            0x30: 0x100401,\n\t            0x40: 0x2100401,\n\t            0x50: 0x0,\n\t            0x60: 0x1,\n\t            0x70: 0x2100001,\n\t            0x80: 0x2000400,\n\t            0x90: 0x100001,\n\t            0xa0: 0x2000001,\n\t            0xb0: 0x2100400,\n\t            0xc0: 0x2100000,\n\t            0xd0: 0x401,\n\t            0xe0: 0x100400,\n\t            0xf0: 0x2000000,\n\t            0x8: 0x2100001,\n\t            0x18: 0x0,\n\t            0x28: 0x2000401,\n\t            0x38: 0x2100400,\n\t            0x48: 0x100000,\n\t            0x58: 0x2000001,\n\t            0x68: 0x2000000,\n\t            0x78: 0x401,\n\t            0x88: 0x100401,\n\t            0x98: 0x2000400,\n\t            0xa8: 0x2100000,\n\t            0xb8: 0x100001,\n\t            0xc8: 0x400,\n\t            0xd8: 0x2100401,\n\t            0xe8: 0x1,\n\t            0xf8: 0x100400,\n\t            0x100: 0x2000000,\n\t            0x110: 0x100000,\n\t            0x120: 0x2000401,\n\t            0x130: 0x2100001,\n\t            0x140: 0x100001,\n\t            0x150: 0x2000400,\n\t            0x160: 0x2100400,\n\t            0x170: 0x100401,\n\t            0x180: 0x401,\n\t            0x190: 0x2100401,\n\t            0x1a0: 0x100400,\n\t            0x1b0: 0x1,\n\t            0x1c0: 0x0,\n\t            0x1d0: 0x2100000,\n\t            0x1e0: 0x2000001,\n\t            0x1f0: 0x400,\n\t            0x108: 0x100400,\n\t            0x118: 0x2000401,\n\t            0x128: 0x2100001,\n\t            0x138: 0x1,\n\t            0x148: 0x2000000,\n\t            0x158: 0x100000,\n\t            0x168: 0x401,\n\t            0x178: 0x2100400,\n\t            0x188: 0x2000001,\n\t            0x198: 0x2100000,\n\t            0x1a8: 0x0,\n\t            0x1b8: 0x2100401,\n\t            0x1c8: 0x100401,\n\t            0x1d8: 0x400,\n\t            0x1e8: 0x2000400,\n\t            0x1f8: 0x100001\n\t        },\n\t        {\n\t            0x0: 0x8000820,\n\t            0x1: 0x20000,\n\t            0x2: 0x8000000,\n\t            0x3: 0x20,\n\t            0x4: 0x20020,\n\t            0x5: 0x8020820,\n\t            0x6: 0x8020800,\n\t            0x7: 0x800,\n\t            0x8: 0x8020000,\n\t            0x9: 0x8000800,\n\t            0xa: 0x20800,\n\t            0xb: 0x8020020,\n\t            0xc: 0x820,\n\t            0xd: 0x0,\n\t            0xe: 0x8000020,\n\t            0xf: 0x20820,\n\t            0x80000000: 0x800,\n\t            0x80000001: 0x8020820,\n\t            0x80000002: 0x8000820,\n\t            0x80000003: 0x8000000,\n\t            0x80000004: 0x8020000,\n\t            0x80000005: 0x20800,\n\t            0x80000006: 0x20820,\n\t            0x80000007: 0x20,\n\t            0x80000008: 0x8000020,\n\t            0x80000009: 0x820,\n\t            0x8000000a: 0x20020,\n\t            0x8000000b: 0x8020800,\n\t            0x8000000c: 0x0,\n\t            0x8000000d: 0x8020020,\n\t            0x8000000e: 0x8000800,\n\t            0x8000000f: 0x20000,\n\t            0x10: 0x20820,\n\t            0x11: 0x8020800,\n\t            0x12: 0x20,\n\t            0x13: 0x800,\n\t            0x14: 0x8000800,\n\t            0x15: 0x8000020,\n\t            0x16: 0x8020020,\n\t            0x17: 0x20000,\n\t            0x18: 0x0,\n\t            0x19: 0x20020,\n\t            0x1a: 0x8020000,\n\t            0x1b: 0x8000820,\n\t            0x1c: 0x8020820,\n\t            0x1d: 0x20800,\n\t            0x1e: 0x820,\n\t            0x1f: 0x8000000,\n\t            0x80000010: 0x20000,\n\t            0x80000011: 0x800,\n\t            0x80000012: 0x8020020,\n\t            0x80000013: 0x20820,\n\t            0x80000014: 0x20,\n\t            0x80000015: 0x8020000,\n\t            0x80000016: 0x8000000,\n\t            0x80000017: 0x8000820,\n\t            0x80000018: 0x8020820,\n\t            0x80000019: 0x8000020,\n\t            0x8000001a: 0x8000800,\n\t            0x8000001b: 0x0,\n\t            0x8000001c: 0x20800,\n\t            0x8000001d: 0x820,\n\t            0x8000001e: 0x20020,\n\t            0x8000001f: 0x8020800\n\t        }\n\t    ];\n\n\t    // Masks that select the SBOX input\n\t    var SBOX_MASK = [\n\t        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\n\t        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f\n\t    ];\n\n\t    /**\n\t     * DES block cipher algorithm.\n\t     */\n\t    var DES = C_algo.DES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\n\t            // Select 56 bits according to PC1\n\t            var keyBits = [];\n\t            for (var i = 0; i < 56; i++) {\n\t                var keyBitPos = PC1[i] - 1;\n\t                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;\n\t            }\n\n\t            // Assemble 16 subkeys\n\t            var subKeys = this._subKeys = [];\n\t            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {\n\t                // Create subkey\n\t                var subKey = subKeys[nSubKey] = [];\n\n\t                // Shortcut\n\t                var bitShift = BIT_SHIFTS[nSubKey];\n\n\t                // Select 48 bits according to PC2\n\t                for (var i = 0; i < 24; i++) {\n\t                    // Select from the left 28 key bits\n\t                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);\n\n\t                    // Select from the right 28 key bits\n\t                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);\n\t                }\n\n\t                // Since each subkey is applied to an expanded 32-bit input,\n\t                // the subkey can be broken into 8 values scaled to 32-bits,\n\t                // which allows the key to be used without expansion\n\t                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\n\t                for (var i = 1; i < 7; i++) {\n\t                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);\n\t                }\n\t                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\n\t            }\n\n\t            // Compute inverse subkeys\n\t            var invSubKeys = this._invSubKeys = [];\n\t            for (var i = 0; i < 16; i++) {\n\t                invSubKeys[i] = subKeys[15 - i];\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._subKeys);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._invSubKeys);\n\t        },\n\n\t        _doCryptBlock: function (M, offset, subKeys) {\n\t            // Get input\n\t            this._lBlock = M[offset];\n\t            this._rBlock = M[offset + 1];\n\n\t            // Initial permutation\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeLR.call(this, 1,  0x55555555);\n\n\t            // Rounds\n\t            for (var round = 0; round < 16; round++) {\n\t                // Shortcuts\n\t                var subKey = subKeys[round];\n\t                var lBlock = this._lBlock;\n\t                var rBlock = this._rBlock;\n\n\t                // Feistel function\n\t                var f = 0;\n\t                for (var i = 0; i < 8; i++) {\n\t                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n\t                }\n\t                this._lBlock = rBlock;\n\t                this._rBlock = lBlock ^ f;\n\t            }\n\n\t            // Undo swap from last round\n\t            var t = this._lBlock;\n\t            this._lBlock = this._rBlock;\n\t            this._rBlock = t;\n\n\t            // Final permutation\n\t            exchangeLR.call(this, 1,  0x55555555);\n\t            exchangeRL.call(this, 8,  0x00ff00ff);\n\t            exchangeRL.call(this, 2,  0x33333333);\n\t            exchangeLR.call(this, 16, 0x0000ffff);\n\t            exchangeLR.call(this, 4,  0x0f0f0f0f);\n\n\t            // Set output\n\t            M[offset] = this._lBlock;\n\t            M[offset + 1] = this._rBlock;\n\t        },\n\n\t        keySize: 64/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    // Swap bits across the left and right words\n\t    function exchangeLR(offset, mask) {\n\t        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\n\t        this._rBlock ^= t;\n\t        this._lBlock ^= t << offset;\n\t    }\n\n\t    function exchangeRL(offset, mask) {\n\t        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\n\t        this._lBlock ^= t;\n\t        this._rBlock ^= t << offset;\n\t    }\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.DES = BlockCipher._createHelper(DES);\n\n\t    /**\n\t     * Triple-DES block cipher algorithm.\n\t     */\n\t    var TripleDES = C_algo.TripleDES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            // Shortcuts\n\t            var key = this._key;\n\t            var keyWords = key.words;\n\t            // Make sure the key length is valid (64, 128 or >= 192 bit)\n\t            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {\n\t                throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');\n\t            }\n\n\t            // Extend the key according to the keying options defined in 3DES standard\n\t            var key1 = keyWords.slice(0, 2);\n\t            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);\n\t            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);\n\n\t            // Create DES instances\n\t            this._des1 = DES.createEncryptor(WordArray.create(key1));\n\t            this._des2 = DES.createEncryptor(WordArray.create(key2));\n\t            this._des3 = DES.createEncryptor(WordArray.create(key3));\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._des1.encryptBlock(M, offset);\n\t            this._des2.decryptBlock(M, offset);\n\t            this._des3.encryptBlock(M, offset);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            this._des3.decryptBlock(M, offset);\n\t            this._des2.encryptBlock(M, offset);\n\t            this._des1.decryptBlock(M, offset);\n\t        },\n\n\t        keySize: 192/32,\n\n\t        ivSize: 64/32,\n\n\t        blockSize: 64/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.TripleDES = BlockCipher._createHelper(TripleDES);\n\t}());\n\n\n\treturn CryptoJS.TripleDES;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/tripledes.js?");

/***/ }),

/***/ "./node_modules/crypto-js/x64-core.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/x64-core.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(";(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(/*! ./core */ \"./node_modules/crypto-js/core.js\"));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var X32WordArray = C_lib.WordArray;\n\n\t    /**\n\t     * x64 namespace.\n\t     */\n\t    var C_x64 = C.x64 = {};\n\n\t    /**\n\t     * A 64-bit word.\n\t     */\n\t    var X64Word = C_x64.Word = Base.extend({\n\t        /**\n\t         * Initializes a newly created 64-bit word.\n\t         *\n\t         * @param {number} high The high 32 bits.\n\t         * @param {number} low The low 32 bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n\t         */\n\t        init: function (high, low) {\n\t            this.high = high;\n\t            this.low = low;\n\t        }\n\n\t        /**\n\t         * Bitwise NOTs this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after negating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var negated = x64Word.not();\n\t         */\n\t        // not: function () {\n\t            // var high = ~this.high;\n\t            // var low = ~this.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ANDs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to AND with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ANDing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var anded = x64Word.and(anotherX64Word);\n\t         */\n\t        // and: function (word) {\n\t            // var high = this.high & word.high;\n\t            // var low = this.low & word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise ORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to OR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after ORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var ored = x64Word.or(anotherX64Word);\n\t         */\n\t        // or: function (word) {\n\t            // var high = this.high | word.high;\n\t            // var low = this.low | word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Bitwise XORs this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to XOR with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after XORing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var xored = x64Word.xor(anotherX64Word);\n\t         */\n\t        // xor: function (word) {\n\t            // var high = this.high ^ word.high;\n\t            // var low = this.low ^ word.low;\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftL(25);\n\t         */\n\t        // shiftL: function (n) {\n\t            // if (n < 32) {\n\t                // var high = (this.high << n) | (this.low >>> (32 - n));\n\t                // var low = this.low << n;\n\t            // } else {\n\t                // var high = this.low << (n - 32);\n\t                // var low = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Shifts this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to shift.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after shifting.\n\t         *\n\t         * @example\n\t         *\n\t         *     var shifted = x64Word.shiftR(7);\n\t         */\n\t        // shiftR: function (n) {\n\t            // if (n < 32) {\n\t                // var low = (this.low >>> n) | (this.high << (32 - n));\n\t                // var high = this.high >>> n;\n\t            // } else {\n\t                // var low = this.high >>> (n - 32);\n\t                // var high = 0;\n\t            // }\n\n\t            // return X64Word.create(high, low);\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the left.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotL(25);\n\t         */\n\t        // rotL: function (n) {\n\t            // return this.shiftL(n).or(this.shiftR(64 - n));\n\t        // },\n\n\t        /**\n\t         * Rotates this word n bits to the right.\n\t         *\n\t         * @param {number} n The number of bits to rotate.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after rotating.\n\t         *\n\t         * @example\n\t         *\n\t         *     var rotated = x64Word.rotR(7);\n\t         */\n\t        // rotR: function (n) {\n\t            // return this.shiftR(n).or(this.shiftL(64 - n));\n\t        // },\n\n\t        /**\n\t         * Adds this word with the passed word.\n\t         *\n\t         * @param {X64Word} word The x64-Word to add with this word.\n\t         *\n\t         * @return {X64Word} A new x64-Word object after adding.\n\t         *\n\t         * @example\n\t         *\n\t         *     var added = x64Word.add(anotherX64Word);\n\t         */\n\t        // add: function (word) {\n\t            // var low = (this.low + word.low) | 0;\n\t            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;\n\t            // var high = (this.high + word.high + carry) | 0;\n\n\t            // return X64Word.create(high, low);\n\t        // }\n\t    });\n\n\t    /**\n\t     * An array of 64-bit words.\n\t     *\n\t     * @property {Array} words The array of CryptoJS.x64.Word objects.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var X64WordArray = C_x64.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create();\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ]);\n\t         *\n\t         *     var wordArray = CryptoJS.x64.WordArray.create([\n\t         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n\t         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n\t         *     ], 10);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 8;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this 64-bit word array to a 32-bit word array.\n\t         *\n\t         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var x32WordArray = x64WordArray.toX32();\n\t         */\n\t        toX32: function () {\n\t            // Shortcuts\n\t            var x64Words = this.words;\n\t            var x64WordsLength = x64Words.length;\n\n\t            // Convert\n\t            var x32Words = [];\n\t            for (var i = 0; i < x64WordsLength; i++) {\n\t                var x64Word = x64Words[i];\n\t                x32Words.push(x64Word.high);\n\t                x32Words.push(x64Word.low);\n\t            }\n\n\t            return X32WordArray.create(x32Words, this.sigBytes);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {X64WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = x64WordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\n\t            // Clone \"words\" array\n\t            var words = clone.words = this.words.slice(0);\n\n\t            // Clone each X64Word object\n\t            var wordsLength = words.length;\n\t            for (var i = 0; i < wordsLength; i++) {\n\t                words[i] = words[i].clone();\n\t            }\n\n\t            return clone;\n\t        }\n\t    });\n\t}());\n\n\n\treturn CryptoJS;\n\n}));\n\n//# sourceURL=webpack://js.package/./node_modules/crypto-js/x64-core.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://js.package/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/file-saver/dist/FileSaver.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/file-saver/dist/FileSaver.min.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(a,b){if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (b),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof __webpack_require__.g&&__webpack_require__.g.global===__webpack_require__.g?__webpack_require__.g:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g, true&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map\n\n//# sourceURL=webpack://js.package/./node_modules/file-saver/dist/FileSaver.min.js?");

/***/ }),

/***/ "./node_modules/joi/dist/joi-browser.min.js":
/*!**************************************************!*\
  !*** ./node_modules/joi/dist/joi-browser.min.js ***!
  \**************************************************/
/***/ ((module) => {

eval("!function(e,t){ true?module.exports=t():0}(self,(()=>{return e={7629:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(9474),i=r(1687),o=r(8652),l=r(8160),c=r(3292),u=r(6354),f=r(8901),h=r(9708),m=r(6914),d=r(2294),p=r(6133),g=r(1152),y=r(8863),b=r(2036),v={Base:class{constructor(e){this.type=e,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new d.Ids,this._preferences=null,this._refs=new p.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return s(\"function\"==typeof h.describe,\"Manifest functionality disabled\"),h.describe(this)}allow(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return l.verifyFlat(t,\"allow\"),this._values(t,\"_valids\")}alter(e){s(e&&\"object\"==typeof e&&!Array.isArray(e),\"Invalid targets argument\"),s(!this._inRuleset(),\"Cannot set alterations inside a ruleset\");const t=this.clone();t.$_terms.alterations=t.$_terms.alterations||[];for(const r in e){const n=e[r];s(\"function\"==typeof n,\"Alteration adjuster for\",r,\"must be a function\"),t.$_terms.alterations.push({target:r,adjuster:n})}return t.$_temp.ruleset=!1,t}artifact(e){return s(void 0!==e,\"Artifact cannot be undefined\"),s(!this._cache,\"Cannot set an artifact with a rule cache\"),this.$_setFlag(\"artifact\",e)}cast(e){return s(!1===e||\"string\"==typeof e,\"Invalid to value\"),s(!1===e||this._definition.cast[e],\"Type\",this.type,\"does not support casting to\",e),this.$_setFlag(\"cast\",!1===e?void 0:e)}default(e,t){return this._default(\"default\",e,t)}description(e){return s(e&&\"string\"==typeof e,\"Description must be a non-empty string\"),this.$_setFlag(\"description\",e)}empty(e){const t=this.clone();return void 0!==e&&(e=t.$_compile(e,{override:!1})),t.$_setFlag(\"empty\",e,{clone:!1})}error(e){return s(e,\"Missing error\"),s(e instanceof Error||\"function\"==typeof e,\"Must provide a valid Error object or a function\"),this.$_setFlag(\"error\",e)}example(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return s(void 0!==e,\"Missing example\"),l.assertOptions(t,[\"override\"]),this._inner(\"examples\",e,{single:!0,override:t.override})}external(e,t){return\"object\"==typeof e&&(s(!t,\"Cannot combine options with description\"),t=e.description,e=e.method),s(\"function\"==typeof e,\"Method must be a function\"),s(void 0===t||t&&\"string\"==typeof t,\"Description must be a non-empty string\"),this._inner(\"externals\",{method:e,description:t},{single:!0})}failover(e,t){return this._default(\"failover\",e,t)}forbidden(){return this.presence(\"forbidden\")}id(e){return e?(s(\"string\"==typeof e,\"id must be a non-empty string\"),s(/^[^\\.]+$/.test(e),\"id cannot contain period character\"),this.$_setFlag(\"id\",e)):this.$_setFlag(\"id\",void 0)}invalid(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return this._values(t,\"_invalids\")}label(e){return s(e&&\"string\"==typeof e,\"Label name must be a non-empty string\"),this.$_setFlag(\"label\",e)}meta(e){return s(void 0!==e,\"Meta cannot be undefined\"),this._inner(\"metas\",e,{single:!0})}note(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];s(t.length,\"Missing notes\");for(const e of t)s(e&&\"string\"==typeof e,\"Notes must be non-empty strings\");return this._inner(\"notes\",t)}only(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return s(\"boolean\"==typeof e,\"Invalid mode:\",e),this.$_setFlag(\"only\",e)}optional(){return this.presence(\"optional\")}prefs(e){s(e,\"Missing preferences\"),s(void 0===e.context,\"Cannot override context\"),s(void 0===e.externals,\"Cannot override externals\"),s(void 0===e.warnings,\"Cannot override warnings\"),s(void 0===e.debug,\"Cannot override debug\"),l.checkPreferences(e);const t=this.clone();return t._preferences=l.preferences(t._preferences,e),t}presence(e){return s([\"optional\",\"required\",\"forbidden\"].includes(e),\"Unknown presence mode\",e),this.$_setFlag(\"presence\",e)}raw(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.$_setFlag(\"result\",e?\"raw\":void 0)}result(e){return s([\"raw\",\"strip\"].includes(e),\"Unknown result mode\",e),this.$_setFlag(\"result\",e)}required(){return this.presence(\"required\")}strict(e){const t=this.clone(),r=void 0!==e&&!e;return t._preferences=l.preferences(t._preferences,{convert:r}),t}strip(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.$_setFlag(\"result\",e?\"strip\":void 0)}tag(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];s(t.length,\"Missing tags\");for(const e of t)s(e&&\"string\"==typeof e,\"Tags must be non-empty strings\");return this._inner(\"tags\",t)}unit(e){return s(e&&\"string\"==typeof e,\"Unit name must be a non-empty string\"),this.$_setFlag(\"unit\",e)}valid(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];l.verifyFlat(t,\"valid\");const s=this.allow(...t);return s.$_setFlag(\"only\",!!s._valids,{clone:!1}),s}when(e,t){const r=this.clone();r.$_terms.whens||(r.$_terms.whens=[]);const n=c.when(r,e,t);if(![\"any\",\"link\"].includes(r.type)){const e=n.is?[n]:n.switch;for(const t of e)s(!t.then||\"any\"===t.then.type||t.then.type===r.type,\"Cannot combine\",r.type,\"with\",t.then&&t.then.type),s(!t.otherwise||\"any\"===t.otherwise.type||t.otherwise.type===r.type,\"Cannot combine\",r.type,\"with\",t.otherwise&&t.otherwise.type)}return r.$_terms.whens.push(n),r.$_mutateRebuild()}cache(e){s(!this._inRuleset(),\"Cannot set caching inside a ruleset\"),s(!this._cache,\"Cannot override schema cache\"),s(void 0===this._flags.artifact,\"Cannot cache a rule with an artifact\");const t=this.clone();return t._cache=e||o.provider.provision(),t.$_temp.ruleset=!1,t}clone(){const e=Object.create(Object.getPrototypeOf(this));return this._assign(e)}concat(e){s(l.isSchema(e),\"Invalid schema object\"),s(\"any\"===this.type||\"any\"===e.type||e.type===this.type,\"Cannot merge type\",this.type,\"with another type:\",e.type),s(!this._inRuleset(),\"Cannot concatenate onto a schema with open ruleset\"),s(!e._inRuleset(),\"Cannot concatenate a schema with open ruleset\");let t=this.clone();if(\"any\"===this.type&&\"any\"!==e.type){const r=e.clone();for(const e of Object.keys(t))\"type\"!==e&&(r[e]=t[e]);t=r}t._ids.concat(e._ids),t._refs.register(e,p.toSibling),t._preferences=t._preferences?l.preferences(t._preferences,e._preferences):e._preferences,t._valids=b.merge(t._valids,e._valids,e._invalids),t._invalids=b.merge(t._invalids,e._invalids,e._valids);for(const r of e._singleRules.keys())t._singleRules.has(r)&&(t._rules=t._rules.filter((e=>e.keep||e.name!==r)),t._singleRules.delete(r));for(const r of e._rules)e._definition.rules[r.method].multi||t._singleRules.set(r.name,r),t._rules.push(r);if(t._flags.empty&&e._flags.empty){t._flags.empty=t._flags.empty.concat(e._flags.empty);const r=Object.assign({},e._flags);delete r.empty,i(t._flags,r)}else if(e._flags.empty){t._flags.empty=e._flags.empty;const r=Object.assign({},e._flags);delete r.empty,i(t._flags,r)}else i(t._flags,e._flags);for(const r in e.$_terms){const s=e.$_terms[r];s?t.$_terms[r]?t.$_terms[r]=t.$_terms[r].concat(s):t.$_terms[r]=s.slice():t.$_terms[r]||(t.$_terms[r]=s)}return this.$_root._tracer&&this.$_root._tracer._combine(t,[this,e]),t.$_mutateRebuild()}extend(e){return s(!e.base,\"Cannot extend type with another base\"),f.type(this,e)}extract(e){return e=Array.isArray(e)?e:e.split(\".\"),this._ids.reach(e)}fork(e,t){s(!this._inRuleset(),\"Cannot fork inside a ruleset\");let r=this;for(let s of[].concat(e))s=Array.isArray(s)?s:s.split(\".\"),r=r._ids.fork(s,t,r);return r.$_temp.ruleset=!1,r}rule(e){const t=this._definition;l.assertOptions(e,Object.keys(t.modifiers)),s(!1!==this.$_temp.ruleset,\"Cannot apply rules to empty ruleset or the last rule added does not support rule properties\");const r=null===this.$_temp.ruleset?this._rules.length-1:this.$_temp.ruleset;s(r>=0&&r<this._rules.length,\"Cannot apply rules to empty ruleset\");const a=this.clone();for(let i=r;i<a._rules.length;++i){const r=a._rules[i],o=n(r);for(const n in e)t.modifiers[n](o,e[n]),s(o.name===r.name,\"Cannot change rule name\");a._rules[i]=o,a._singleRules.get(o.name)===r&&a._singleRules.set(o.name,o)}return a.$_temp.ruleset=!1,a.$_mutateRebuild()}get ruleset(){s(!this._inRuleset(),\"Cannot start a new ruleset without closing the previous one\");const e=this.clone();return e.$_temp.ruleset=e._rules.length,e}get $(){return this.ruleset}tailor(e){e=[].concat(e),s(!this._inRuleset(),\"Cannot tailor inside a ruleset\");let t=this;if(this.$_terms.alterations)for(const{target:r,adjuster:n}of this.$_terms.alterations)e.includes(r)&&(t=n(t),s(l.isSchema(t),\"Alteration adjuster for\",r,\"failed to return a schema object\"));return t=t.$_modify({each:t=>t.tailor(e),ref:!1}),t.$_temp.ruleset=!1,t.$_mutateRebuild()}tracer(){return g.location?g.location(this):this}validate(e,t){return y.entry(e,this,t)}validateAsync(e,t){return y.entryAsync(e,this,t)}$_addRule(e){\"string\"==typeof e&&(e={name:e}),s(e&&\"object\"==typeof e,\"Invalid options\"),s(e.name&&\"string\"==typeof e.name,\"Invalid rule name\");for(const t in e)s(\"_\"!==t[0],\"Cannot set private rule properties\");const t=Object.assign({},e);t._resolve=[],t.method=t.method||t.name;const r=this._definition.rules[t.method],n=t.args;s(r,\"Unknown rule\",t.method);const a=this.clone();if(n){s(1===Object.keys(n).length||Object.keys(n).length===this._definition.rules[t.name].args.length,\"Invalid rule definition for\",this.type,t.name);for(const e in n){let i=n[e];if(r.argsByName){const o=r.argsByName.get(e);if(o.ref&&l.isResolvable(i))t._resolve.push(e),a.$_mutateRegister(i);else if(o.normalize&&(i=o.normalize(i),n[e]=i),o.assert){const t=l.validateArg(i,e,o);s(!t,t,\"or reference\")}}void 0!==i?n[e]=i:delete n[e]}}return r.multi||(a._ruleRemove(t.name,{clone:!1}),a._singleRules.set(t.name,t)),!1===a.$_temp.ruleset&&(a.$_temp.ruleset=null),r.priority?a._rules.unshift(t):a._rules.push(t),a}$_compile(e,t){return c.schema(this.$_root,e,t)}$_createError(e,t,r,s,n){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=!1!==a.flags?this._flags:{},o=a.messages?m.merge(this._definition.messages,a.messages):this._definition.messages;return new u.Report(e,t,r,i,o,s,n)}$_getFlag(e){return this._flags[e]}$_getRule(e){return this._singleRules.get(e)}$_mapLabels(e){return e=Array.isArray(e)?e:e.split(\".\"),this._ids.labels(e)}$_match(e,t,r,s){(r=Object.assign({},r)).abortEarly=!0,r._externals=!1,t.snapshot();const n=!y.validate(e,this,t,r,s).errors;return t.restore(),n}$_modify(e){return l.assertOptions(e,[\"each\",\"once\",\"ref\",\"schema\"]),d.schema(this,e)||this}$_mutateRebuild(){return s(!this._inRuleset(),\"Cannot add this rule inside a ruleset\"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(e,t)=>{let{source:r,name:s,path:n,key:a}=t;const i=this._definition[r][s]&&this._definition[r][s].register;!1!==i&&this.$_mutateRegister(e,{family:i,key:a})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(e){let{family:t,key:r}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._refs.register(e,t),this._ids.register(e,{key:r})}$_property(e){return this._definition.properties[e]}$_reach(e){return this._ids.reach(e)}$_rootReferences(){return this._refs.roots()}$_setFlag(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};s(\"_\"===e[0]||!this._inRuleset(),\"Cannot set flag inside a ruleset\");const n=this._definition.flags[e]||{};if(a(t,n.default)&&(t=void 0),a(t,this._flags[e]))return this;const i=!1!==r.clone?this.clone():this;return void 0!==t?(i._flags[e]=t,i.$_mutateRegister(t)):delete i._flags[e],\"_\"!==e[0]&&(i.$_temp.ruleset=!1),i}$_parent(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),s=1;s<t;s++)r[s-1]=arguments[s];return this[e][l.symbols.parent].call(this,...r)}$_validate(e,t,r){return y.validate(e,this,t,r)}_assign(e){e.type=this.type,e.$_root=this.$_root,e.$_temp=Object.assign({},this.$_temp),e.$_temp.whens={},e._ids=this._ids.clone(),e._preferences=this._preferences,e._valids=this._valids&&this._valids.clone(),e._invalids=this._invalids&&this._invalids.clone(),e._rules=this._rules.slice(),e._singleRules=n(this._singleRules,{shallow:!0}),e._refs=this._refs.clone(),e._flags=Object.assign({},this._flags),e._cache=null,e.$_terms={};for(const t in this.$_terms)e.$_terms[t]=this.$_terms[t]?this.$_terms[t].slice():null;e.$_super={};for(const t in this.$_super)e.$_super[t]=this._super[t].bind(e);return e}_bare(){const e=this.clone();e._reset();const t=e._definition.terms;for(const r in t){const s=t[r];e.$_terms[r]=s.init}return e.$_mutateRebuild()}_default(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return l.assertOptions(r,\"literal\"),s(void 0!==t,\"Missing\",e,\"value\"),s(\"function\"==typeof t||!r.literal,\"Only function value supports literal option\"),\"function\"==typeof t&&r.literal&&(t={[l.symbols.literal]:!0,literal:t}),this.$_setFlag(e,t)}_generate(e,t,r){if(!this.$_terms.whens)return{schema:this};const s=[],n=[];for(let a=0;a<this.$_terms.whens.length;++a){const i=this.$_terms.whens[a];if(i.concat){s.push(i.concat),n.push(`${a}.concat`);continue}const o=i.ref?i.ref.resolve(e,t,r):e,l=i.is?[i]:i.switch,c=n.length;for(let c=0;c<l.length;++c){const{is:u,then:f,otherwise:h}=l[c],m=`${a}${i.switch?\".\"+c:\"\"}`;if(u.$_match(o,t.nest(u,`${m}.is`),r)){if(f){const a=t.localize([...t.path,`${m}.then`],t.ancestors,t.schemas),{schema:i,id:o}=f._generate(e,a,r);s.push(i),n.push(`${m}.then${o?`(${o})`:\"\"}`);break}}else if(h){const a=t.localize([...t.path,`${m}.otherwise`],t.ancestors,t.schemas),{schema:i,id:o}=h._generate(e,a,r);s.push(i),n.push(`${m}.otherwise${o?`(${o})`:\"\"}`);break}}if(i.break&&n.length>c)break}const a=n.join(\", \");if(t.mainstay.tracer.debug(t,\"rule\",\"when\",a),!a)return{schema:this};if(!t.mainstay.tracer.active&&this.$_temp.whens[a])return{schema:this.$_temp.whens[a],id:a};let i=this;this._definition.generate&&(i=this._definition.generate(this,e,t,r));for(const e of s)i=i.concat(e);return this.$_root._tracer&&this.$_root._tracer._combine(i,[this,...s]),this.$_temp.whens[a]=i,{schema:i,id:a}}_inner(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};s(!this._inRuleset(),`Cannot set ${e} inside a ruleset`);const n=this.clone();return n.$_terms[e]&&!r.override||(n.$_terms[e]=[]),r.single?n.$_terms[e].push(t):n.$_terms[e].push(...t),n.$_temp.ruleset=!1,n}_inRuleset(){return null!==this.$_temp.ruleset&&!1!==this.$_temp.ruleset}_ruleRemove(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this._singleRules.has(e))return this;const r=!1!==t.clone?this.clone():this;r._singleRules.delete(e);const s=[];for(let t=0;t<r._rules.length;++t){const n=r._rules[t];n.name!==e||n.keep?s.push(n):r._inRuleset()&&t<r.$_temp.ruleset&&--r.$_temp.ruleset}return r._rules=s,r}_values(e,t){l.verifyFlat(e,t.slice(1,-1));const r=this.clone(),n=e[0]===l.symbols.override;if(n&&(e=e.slice(1)),!r[t]&&e.length?r[t]=new b:n&&(r[t]=e.length?new b:null,r.$_mutateRebuild()),!r[t])return r;n&&r[t].override();for(const n of e){s(void 0!==n,\"Cannot call allow/valid/invalid with undefined\"),s(n!==l.symbols.override,\"Override must be the first value\");const e=\"_invalids\"===t?\"_valids\":\"_invalids\";r[e]&&(r[e].remove(n),r[e].length||(s(\"_valids\"===t||!r._flags.only,\"Setting invalid value\",n,\"leaves schema rejecting all values due to previous valid rule\"),r[e]=null)),r[t].add(n,r._refs)}return r}}};v.Base.prototype[l.symbols.any]={version:l.version,compile:c.compile,root:\"$_root\"},v.Base.prototype.isImmutable=!0,v.Base.prototype.deny=v.Base.prototype.invalid,v.Base.prototype.disallow=v.Base.prototype.invalid,v.Base.prototype.equal=v.Base.prototype.valid,v.Base.prototype.exist=v.Base.prototype.required,v.Base.prototype.not=v.Base.prototype.invalid,v.Base.prototype.options=v.Base.prototype.prefs,v.Base.prototype.preferences=v.Base.prototype.prefs,e.exports=new v.Base},8652:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(8160),i={max:1e3,supported:new Set([\"undefined\",\"boolean\",\"number\",\"string\"])};t.provider={provision:e=>new i.Cache(e)},i.Cache=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};a.assertOptions(e,[\"max\"]),s(void 0===e.max||e.max&&e.max>0&&isFinite(e.max),\"Invalid max cache size\"),this._max=e.max||i.max,this._map=new Map,this._list=new i.List}get length(){return this._map.size}set(e,t){if(null!==e&&!i.supported.has(typeof e))return;let r=this._map.get(e);if(r)return r.value=t,void this._list.first(r);r=this._list.unshift({key:e,value:t}),this._map.set(e,r),this._compact()}get(e){const t=this._map.get(e);if(t)return this._list.first(t),n(t.value)}_compact(){if(this._map.size>this._max){const e=this._list.pop();this._map.delete(e.key)}}},i.List=class{constructor(){this.tail=null,this.head=null}unshift(e){return e.next=null,e.prev=this.head,this.head&&(this.head.next=e),this.head=e,this.tail||(this.tail=e),e}first(e){e!==this.head&&(this._remove(e),this.unshift(e))}pop(){return this._remove(this.tail)}_remove(e){const{next:t,prev:r}=e;return t.prev=r,r&&(r.next=t),e===this.tail&&(this.tail=t),e.prev=null,e.next=null,e}}},8160:(e,t,r)=>{\"use strict\";const s=r(375),n=r(7916),a=r(5934);let i,o;const l={isoDate:/^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/};t.version=a.version,t.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:\"iso\",errors:{escapeHtml:!1,label:\"path\",language:null,render:!0,stack:!1,wrap:{label:'\"',array:\"[]\"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:\"optional\",skipFunctions:!1,stripUnknown:!1,warnings:!1},t.symbols={any:Symbol.for(\"@hapi/joi/schema\"),arraySingle:Symbol(\"arraySingle\"),deepDefault:Symbol(\"deepDefault\"),errors:Symbol(\"errors\"),literal:Symbol(\"literal\"),override:Symbol(\"override\"),parent:Symbol(\"parent\"),prefs:Symbol(\"prefs\"),ref:Symbol(\"ref\"),template:Symbol(\"template\"),values:Symbol(\"values\")},t.assertOptions=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"Options\";s(e&&\"object\"==typeof e&&!Array.isArray(e),\"Options must be of type object\");const n=Object.keys(e).filter((e=>!t.includes(e)));s(0===n.length,`${r} contain unknown keys: ${n}`)},t.checkPreferences=function(e){o=o||r(3378);const t=o.preferences.validate(e);if(t.error)throw new n([t.error.details[0].message])},t.compare=function(e,t,r){switch(r){case\"=\":return e===t;case\">\":return e>t;case\"<\":return e<t;case\">=\":return e>=t;case\"<=\":return e<=t}},t.default=function(e,t){return void 0===e?t:e},t.isIsoDate=function(e){return l.isoDate.test(e)},t.isNumber=function(e){return\"number\"==typeof e&&!isNaN(e)},t.isResolvable=function(e){return!!e&&(e[t.symbols.ref]||e[t.symbols.template])},t.isSchema=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e&&e[t.symbols.any];return!!n&&(s(r.legacy||n.version===t.version,\"Cannot mix different versions of joi schemas\"),!0)},t.isValues=function(e){return e[t.symbols.values]},t.limit=function(e){return Number.isSafeInteger(e)&&e>=0},t.preferences=function(e,s){i=i||r(6914),e=e||{},s=s||{};const n=Object.assign({},e,s);return s.errors&&e.errors&&(n.errors=Object.assign({},e.errors,s.errors),n.errors.wrap=Object.assign({},e.errors.wrap,s.errors.wrap)),s.messages&&(n.messages=i.compile(s.messages,e.messages)),delete n[t.symbols.prefs],n},t.tryWithPath=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};try{return e()}catch(e){throw void 0!==e.path?e.path=t+\".\"+e.path:e.path=t,r.append&&(e.message=`${e.message} (${e.path})`),e}},t.validateArg=function(e,r,s){let{assert:n,message:a}=s;if(t.isSchema(n)){const t=n.validate(e);if(!t.error)return;return t.error.message}if(!n(e))return r?`${r} ${a}`:a},t.verifyFlat=function(e,t){for(const r of e)s(!Array.isArray(r),\"Method no longer accepts array arguments:\",t)}},3292:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8160),a=r(6133),i={};t.schema=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n.assertOptions(r,[\"appendPath\",\"override\"]);try{return i.schema(e,t,r)}catch(e){throw r.appendPath&&void 0!==e.path&&(e.message=`${e.message} (${e.path})`),e}},i.schema=function(e,t,r){s(void 0!==t,\"Invalid undefined schema\"),Array.isArray(t)&&(s(t.length,\"Invalid empty array schema\"),1===t.length&&(t=t[0]));const a=function(t){for(var s=arguments.length,n=new Array(s>1?s-1:0),a=1;a<s;a++)n[a-1]=arguments[a];return!1!==r.override?t.valid(e.override,...n):t.valid(...n)};if(i.simple(t))return a(e,t);if(\"function\"==typeof t)return e.custom(t);if(s(\"object\"==typeof t,\"Invalid schema content:\",typeof t),n.isResolvable(t))return a(e,t);if(n.isSchema(t))return t;if(Array.isArray(t)){for(const r of t)if(!i.simple(r))return e.alternatives().try(...t);return a(e,...t)}return t instanceof RegExp?e.string().regex(t):t instanceof Date?a(e.date(),t):(s(Object.getPrototypeOf(t)===Object.getPrototypeOf({}),\"Schema can only contain plain objects\"),e.object().keys(t))},t.ref=function(e,t){return a.isRef(e)?e:a.create(e,t)},t.compile=function(e,r){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n.assertOptions(a,[\"legacy\"]);const o=r&&r[n.symbols.any];if(o)return s(a.legacy||o.version===n.version,\"Cannot mix different versions of joi schemas:\",o.version,n.version),r;if(\"object\"!=typeof r||!a.legacy)return t.schema(e,r,{appendPath:!0});const l=i.walk(r);return l?l.compile(l.root,r):t.schema(e,r,{appendPath:!0})},i.walk=function(e){if(\"object\"!=typeof e)return null;if(Array.isArray(e)){for(const t of e){const e=i.walk(t);if(e)return e}return null}const t=e[n.symbols.any];if(t)return{root:e[t.root],compile:t.compile};s(Object.getPrototypeOf(e)===Object.getPrototypeOf({}),\"Schema can only contain plain objects\");for(const t in e){const r=i.walk(e[t]);if(r)return r}return null},i.simple=function(e){return null===e||[\"boolean\",\"string\",\"number\"].includes(typeof e)},t.when=function(e,r,o){if(void 0===o&&(s(r&&\"object\"==typeof r,\"Missing options\"),o=r,r=a.create(\".\")),Array.isArray(o)&&(o={switch:o}),n.assertOptions(o,[\"is\",\"not\",\"then\",\"otherwise\",\"switch\",\"break\"]),n.isSchema(r))return s(void 0===o.is,'\"is\" can not be used with a schema condition'),s(void 0===o.not,'\"not\" can not be used with a schema condition'),s(void 0===o.switch,'\"switch\" can not be used with a schema condition'),i.condition(e,{is:r,then:o.then,otherwise:o.otherwise,break:o.break});if(s(a.isRef(r)||\"string\"==typeof r,\"Invalid condition:\",r),s(void 0===o.not||void 0===o.is,'Cannot combine \"is\" with \"not\"'),void 0===o.switch){let l=o;void 0!==o.not&&(l={is:o.not,then:o.otherwise,otherwise:o.then,break:o.break});let c=void 0!==l.is?e.$_compile(l.is):e.$_root.invalid(null,!1,0,\"\").required();return s(void 0!==l.then||void 0!==l.otherwise,'options must have at least one of \"then\", \"otherwise\", or \"switch\"'),s(void 0===l.break||void 0===l.then||void 0===l.otherwise,\"Cannot specify then, otherwise, and break all together\"),void 0===o.is||a.isRef(o.is)||n.isSchema(o.is)||(c=c.required()),i.condition(e,{ref:t.ref(r),is:c,then:l.then,otherwise:l.otherwise,break:l.break})}s(Array.isArray(o.switch),'\"switch\" must be an array'),s(void 0===o.is,'Cannot combine \"switch\" with \"is\"'),s(void 0===o.not,'Cannot combine \"switch\" with \"not\"'),s(void 0===o.then,'Cannot combine \"switch\" with \"then\"');const l={ref:t.ref(r),switch:[],break:o.break};for(let t=0;t<o.switch.length;++t){const r=o.switch[t],i=t===o.switch.length-1;n.assertOptions(r,i?[\"is\",\"then\",\"otherwise\"]:[\"is\",\"then\"]),s(void 0!==r.is,'Switch statement missing \"is\"'),s(void 0!==r.then,'Switch statement missing \"then\"');const c={is:e.$_compile(r.is),then:e.$_compile(r.then)};if(a.isRef(r.is)||n.isSchema(r.is)||(c.is=c.is.required()),i){s(void 0===o.otherwise||void 0===r.otherwise,'Cannot specify \"otherwise\" inside and outside a \"switch\"');const t=void 0!==o.otherwise?o.otherwise:r.otherwise;void 0!==t&&(s(void 0===l.break,\"Cannot specify both otherwise and break\"),c.otherwise=e.$_compile(t))}l.switch.push(c)}return l},i.condition=function(e,t){for(const r of[\"then\",\"otherwise\"])void 0===t[r]?delete t[r]:t[r]=e.$_compile(t[r]);return t}},6354:(e,t,r)=>{\"use strict\";const s=r(5688),n=r(8160),a=r(3328);t.Report=class{constructor(e,r,s,n,a,i,o){if(this.code=e,this.flags=n,this.messages=a,this.path=i.path,this.prefs=o,this.state=i,this.value=r,this.message=null,this.template=null,this.local=s||{},this.local.label=t.label(this.flags,this.state,this.prefs,this.messages),void 0===this.value||this.local.hasOwnProperty(\"value\")||(this.local.value=this.value),this.path.length){const e=this.path[this.path.length-1];\"object\"!=typeof e&&(this.local.key=e)}}_setTemplate(e){if(this.template=e,!this.flags.label&&0===this.path.length){const e=this._template(this.template,\"root\");e&&(this.local.label=e)}}toString(){if(this.message)return this.message;const e=this.code;if(!this.prefs.errors.render)return this.code;const t=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return void 0===t?`Error code \"${e}\" is not defined, your custom type is missing the correct messages definition`:(this.message=t.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^\"\" /,\"\").trim()),this.message)}_template(e,r){return t.template(this.value,e,r||this.code,this.state,this.prefs)}},t.path=function(e){let t=\"\";for(const r of e)\"object\"!=typeof r&&(\"string\"==typeof r?(t&&(t+=\".\"),t+=r):t+=`[${r}]`);return t},t.template=function(e,t,r,s,i){if(!t)return;if(a.isTemplate(t))return\"root\"!==r?t:null;let o=i.errors.language;if(n.isResolvable(o)&&(o=o.resolve(e,s,i)),o&&t[o]){if(void 0!==t[o][r])return t[o][r];if(void 0!==t[o][\"*\"])return t[o][\"*\"]}return t[r]?t[r]:t[\"*\"]},t.label=function(e,r,s,n){if(e.label)return e.label;if(!s.errors.label)return\"\";let a=r.path;\"key\"===s.errors.label&&r.path.length>1&&(a=r.path.slice(-1));return t.path(a)||t.template(null,s.messages,\"root\",r,s)||n&&t.template(null,n,\"root\",r,s)||\"value\"},t.process=function(e,r,s){if(!e)return null;const{override:n,message:a,details:i}=t.details(e);if(n)return n;if(s.errors.stack)return new t.ValidationError(a,i,r);const o=Error.stackTraceLimit;Error.stackTraceLimit=0;const l=new t.ValidationError(a,i,r);return Error.stackTraceLimit=o,l},t.details=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=[];const s=[];for(const n of e){if(n instanceof Error){if(!1!==t.override)return{override:n};const e=n.toString();r.push(e),s.push({message:e,type:\"override\",context:{error:n}});continue}const e=n.toString();r.push(e),s.push({message:e,path:n.path.filter((e=>\"object\"!=typeof e)),type:n.code,context:n.local})}return r.length>1&&(r=[...new Set(r)]),{message:r.join(\". \"),details:s}},t.ValidationError=class extends Error{constructor(e,t,r){super(e),this._original=r,this.details=t}static isError(e){return e instanceof t.ValidationError}},t.ValidationError.prototype.isJoi=!0,t.ValidationError.prototype.name=\"ValidationError\",t.ValidationError.prototype.annotate=s.error},8901:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(8160),i=r(6914),o={};t.type=function(e,t){const r=Object.getPrototypeOf(e),l=n(r),c=e._assign(Object.create(l)),u=Object.assign({},t);delete u.base,l._definition=u;const f=r._definition||{};u.messages=i.merge(f.messages,u.messages),u.properties=Object.assign({},f.properties,u.properties),c.type=u.type,u.flags=Object.assign({},f.flags,u.flags);const h=Object.assign({},f.terms);if(u.terms)for(const e in u.terms){const t=u.terms[e];s(void 0===c.$_terms[e],\"Invalid term override for\",u.type,e),c.$_terms[e]=t.init,h[e]=t}u.terms=h,u.args||(u.args=f.args),u.prepare=o.prepare(u.prepare,f.prepare),u.coerce&&(\"function\"==typeof u.coerce&&(u.coerce={method:u.coerce}),u.coerce.from&&!Array.isArray(u.coerce.from)&&(u.coerce={method:u.coerce.method,from:[].concat(u.coerce.from)})),u.coerce=o.coerce(u.coerce,f.coerce),u.validate=o.validate(u.validate,f.validate);const m=Object.assign({},f.rules);if(u.rules)for(const e in u.rules){const t=u.rules[e];s(\"object\"==typeof t,\"Invalid rule definition for\",u.type,e);let r=t.method;if(void 0===r&&(r=function(){return this.$_addRule(e)}),r&&(s(!l[e],\"Rule conflict in\",u.type,e),l[e]=r),s(!m[e],\"Rule conflict in\",u.type,e),m[e]=t,t.alias){const e=[].concat(t.alias);for(const r of e)l[r]=t.method}t.args&&(t.argsByName=new Map,t.args=t.args.map((e=>(\"string\"==typeof e&&(e={name:e}),s(!t.argsByName.has(e.name),\"Duplicated argument name\",e.name),a.isSchema(e.assert)&&(e.assert=e.assert.strict().label(e.name)),t.argsByName.set(e.name,e),e))))}u.rules=m;const d=Object.assign({},f.modifiers);if(u.modifiers)for(const e in u.modifiers){s(!l[e],\"Rule conflict in\",u.type,e);const t=u.modifiers[e];s(\"function\"==typeof t,\"Invalid modifier definition for\",u.type,e);const r=function(t){return this.rule({[e]:t})};l[e]=r,d[e]=t}if(u.modifiers=d,u.overrides){l._super=r,c.$_super={};for(const e in u.overrides)s(r[e],\"Cannot override missing\",e),u.overrides[e][a.symbols.parent]=r[e],c.$_super[e]=r[e].bind(c);Object.assign(l,u.overrides)}u.cast=Object.assign({},f.cast,u.cast);const p=Object.assign({},f.manifest,u.manifest);return p.build=o.build(u.manifest&&u.manifest.build,f.manifest&&f.manifest.build),u.manifest=p,u.rebuild=o.rebuild(u.rebuild,f.rebuild),c},o.build=function(e,t){return e&&t?function(r,s){return t(e(r,s),s)}:e||t},o.coerce=function(e,t){return e&&t?{from:e.from&&t.from?[...new Set([...e.from,...t.from])]:null,method(r,s){let n;if((!t.from||t.from.includes(typeof r))&&(n=t.method(r,s),n)){if(n.errors||void 0===n.value)return n;r=n.value}if(!e.from||e.from.includes(typeof r)){const t=e.method(r,s);if(t)return t}return n}}:e||t},o.prepare=function(e,t){return e&&t?function(r,s){const n=e(r,s);if(n){if(n.errors||void 0===n.value)return n;r=n.value}return t(r,s)||n}:e||t},o.rebuild=function(e,t){return e&&t?function(r){t(r),e(r)}:e||t},o.validate=function(e,t){return e&&t?function(r,s){const n=t(r,s);if(n){if(n.errors&&(!Array.isArray(n.errors)||n.errors.length))return n;r=n.value}return e(r,s)||n}:e||t}},5107:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(8652),i=r(8160),o=r(3292),l=r(6354),c=r(8901),u=r(9708),f=r(6133),h=r(3328),m=r(1152);let d;const p={types:{alternatives:r(4946),any:r(8068),array:r(546),boolean:r(4937),date:r(7500),function:r(390),link:r(8785),number:r(3832),object:r(8966),string:r(7417),symbol:r(8826)},aliases:{alt:\"alternatives\",bool:\"boolean\",func:\"function\"},root:function(){const e={_types:new Set(Object.keys(p.types))};for(const t of e._types)e[t]=function(){for(var e=arguments.length,r=new Array(e),n=0;n<e;n++)r[n]=arguments[n];return s(!r.length||[\"alternatives\",\"link\",\"object\"].includes(t),\"The\",t,\"type does not allow arguments\"),p.generate(this,p.types[t],r)};for(const t of[\"allow\",\"custom\",\"disallow\",\"equal\",\"exist\",\"forbidden\",\"invalid\",\"not\",\"only\",\"optional\",\"options\",\"prefs\",\"preferences\",\"required\",\"strip\",\"valid\",\"when\"])e[t]=function(){return this.any()[t](...arguments)};Object.assign(e,p.methods);for(const t in p.aliases){const r=p.aliases[t];e[t]=e[r]}return e.x=e.expression,m.setup&&m.setup(e),e}};p.methods={ValidationError:l.ValidationError,version:i.version,cache:a.provider,assert(e,t){for(var r=arguments.length,s=new Array(r>2?r-2:0),n=2;n<r;n++)s[n-2]=arguments[n];p.assert(e,t,!0,s)},attempt(e,t){for(var r=arguments.length,s=new Array(r>2?r-2:0),n=2;n<r;n++)s[n-2]=arguments[n];return p.assert(e,t,!1,s)},build(e){return s(\"function\"==typeof u.build,\"Manifest functionality disabled\"),u.build(this,e)},checkPreferences(e){i.checkPreferences(e)},compile(e,t){return o.compile(this,e,t)},defaults(e){s(\"function\"==typeof e,\"modifier must be a function\");const t=Object.assign({},this);for(const r of t._types){const n=e(t[r]());s(i.isSchema(n),\"modifier must return a valid schema object\"),t[r]=function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return p.generate(this,n,t)}}return t},expression(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return new h(...t)},extend(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];i.verifyFlat(t,\"extend\"),d=d||r(3378),s(t.length,\"You need to provide at least one extension\"),this.assert(t,d.extensions);const a=Object.assign({},this);a._types=new Set(a._types);for(let e of t){\"function\"==typeof e&&(e=e(a)),this.assert(e,d.extension);const t=p.expandExtension(e,a);for(const e of t){s(void 0===a[e.type]||a._types.has(e.type),\"Cannot override name\",e.type);const t=e.base||this.any(),r=c.type(t,e);a._types.add(e.type),a[e.type]=function(){for(var e=arguments.length,t=new Array(e),s=0;s<e;s++)t[s]=arguments[s];return p.generate(this,r,t)}}}return a},isError:l.ValidationError.isError,isExpression:h.isTemplate,isRef:f.isRef,isSchema:i.isSchema,in(){return f.in(...arguments)},override:i.symbols.override,ref(){return f.create(...arguments)},types(){const e={};for(const t of this._types)e[t]=this[t]();for(const t in p.aliases)e[t]=this[t]();return e}},p.assert=function(e,t,r,s){const a=s[0]instanceof Error||\"string\"==typeof s[0]?s[0]:null,o=null!==a?s[1]:s[0],c=t.validate(e,i.preferences({errors:{stack:!0}},o||{}));let u=c.error;if(!u)return c.value;if(a instanceof Error)throw a;const f=r&&\"function\"==typeof u.annotate?u.annotate():u.message;throw u instanceof l.ValidationError==0&&(u=n(u)),u.message=a?`${a} ${f}`:f,u},p.generate=function(e,t,r){return s(e,\"Must be invoked on a Joi instance.\"),t.$_root=e,t._definition.args&&r.length?t._definition.args(t,...r):t},p.expandExtension=function(e,t){if(\"string\"==typeof e.type)return[e];const r=[];for(const s of t._types)if(e.type.test(s)){const n=Object.assign({},e);n.type=s,n.base=t[s](),r.push(n)}return r},e.exports=p.root()},6914:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(3328);t.compile=function(e,t){if(\"string\"==typeof e)return s(!t,\"Cannot set single message string\"),new a(e);if(a.isTemplate(e))return s(!t,\"Cannot set single message template\"),e;s(\"object\"==typeof e&&!Array.isArray(e),\"Invalid message options\"),t=t?n(t):{};for(let r in e){const n=e[r];if(\"root\"===r||a.isTemplate(n)){t[r]=n;continue}if(\"string\"==typeof n){t[r]=new a(n);continue}s(\"object\"==typeof n&&!Array.isArray(n),\"Invalid message for\",r);const i=r;for(r in t[i]=t[i]||{},n){const e=n[r];\"root\"===r||a.isTemplate(e)?t[i][r]=e:(s(\"string\"==typeof e,\"Invalid message for\",r,\"in\",i),t[i][r]=new a(e))}}return t},t.decompile=function(e){const t={};for(let r in e){const s=e[r];if(\"root\"===r){t.root=s;continue}if(a.isTemplate(s)){t[r]=s.describe({compact:!0});continue}const n=r;for(r in t[n]={},s){const e=s[r];\"root\"!==r?t[n][r]=e.describe({compact:!0}):t[n].root=e}}return t},t.merge=function(e,r){if(!e)return t.compile(r);if(!r)return e;if(\"string\"==typeof r)return new a(r);if(a.isTemplate(r))return r;const i=n(e);for(let e in r){const t=r[e];if(\"root\"===e||a.isTemplate(t)){i[e]=t;continue}if(\"string\"==typeof t){i[e]=new a(t);continue}s(\"object\"==typeof t&&!Array.isArray(t),\"Invalid message for\",e);const n=e;for(e in i[n]=i[n]||{},t){const r=t[e];\"root\"===e||a.isTemplate(r)?i[n][e]=r:(s(\"string\"==typeof r,\"Invalid message for\",e,\"in\",n),i[n][e]=new a(r))}}return i}},2294:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8160),a=r(6133),i={};t.Ids=i.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const e=new i.Ids;return e._byId=new Map(this._byId),e._byKey=new Map(this._byKey),e._schemaChain=this._schemaChain,e}concat(e){e._schemaChain&&(this._schemaChain=!0);for(const[t,r]of e._byId.entries())s(!this._byKey.has(t),\"Schema id conflicts with existing key:\",t),this._byId.set(t,r);for(const[t,r]of e._byKey.entries())s(!this._byId.has(t),\"Schema key conflicts with existing id:\",t),this._byKey.set(t,r)}fork(e,t,r){const a=this._collect(e);a.push({schema:r});const o=a.shift();let l={id:o.id,schema:t(o.schema)};s(n.isSchema(l.schema),\"adjuster function failed to return a joi schema type\");for(const e of a)l={id:e.id,schema:i.fork(e.schema,l.id,l.schema)};return l.schema}labels(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=e[0],s=this._get(r);if(!s)return[...t,...e].join(\".\");const n=e.slice(1);return t=[...t,s.schema._flags.label||r],n.length?s.schema._ids.labels(n,t):t.join(\".\")}reach(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=e[0],n=this._get(r);s(n,\"Schema does not contain path\",[...t,...e].join(\".\"));const a=e.slice(1);return a.length?n.schema._ids.reach(a,[...t,r]):n.schema}register(e){let{key:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e||!n.isSchema(e))return;(e.$_property(\"schemaChain\")||e._ids._schemaChain)&&(this._schemaChain=!0);const r=e._flags.id;if(r){const t=this._byId.get(r);s(!t||t.schema===e,\"Cannot add different schemas with the same id:\",r),s(!this._byKey.has(r),\"Schema id conflicts with existing key:\",r),this._byId.set(r,{schema:e,id:r})}t&&(s(!this._byKey.has(t),\"Schema already contains key:\",t),s(!this._byId.has(t),\"Schema key conflicts with existing id:\",t),this._byKey.set(t,{schema:e,id:t}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const n=e[0],a=this._get(n);s(a,\"Schema does not contain path\",[...t,...e].join(\".\")),r=[a,...r];const i=e.slice(1);return i.length?a.schema._ids._collect(i,[...t,n],r):r}_get(e){return this._byId.get(e)||this._byKey.get(e)}},i.fork=function(e,r,s){const n=t.schema(e,{each:(e,t)=>{let{key:n}=t;if(r===(e._flags.id||n))return s},ref:!1});return n?n.$_mutateRebuild():e},t.schema=function(e,t){let r;for(const s in e._flags){if(\"_\"===s[0])continue;const n=i.scan(e._flags[s],{source:\"flags\",name:s},t);void 0!==n&&(r=r||e.clone(),r._flags[s]=n)}for(let s=0;s<e._rules.length;++s){const n=e._rules[s],a=i.scan(n.args,{source:\"rules\",name:n.name},t);if(void 0!==a){r=r||e.clone();const t=Object.assign({},n);t.args=a,r._rules[s]=t,r._singleRules.get(n.name)===n&&r._singleRules.set(n.name,t)}}for(const s in e.$_terms){if(\"_\"===s[0])continue;const n=i.scan(e.$_terms[s],{source:\"terms\",name:s},t);void 0!==n&&(r=r||e.clone(),r.$_terms[s]=n)}return r},i.scan=function(e,t,r,s,o){const l=s||[];if(null===e||\"object\"!=typeof e)return;let c;if(Array.isArray(e)){for(let s=0;s<e.length;++s){const n=\"terms\"===t.source&&\"keys\"===t.name&&e[s].key,a=i.scan(e[s],t,r,[s,...l],n);void 0!==a&&(c=c||e.slice(),c[s]=a)}return c}if(!1!==r.schema&&n.isSchema(e)||!1!==r.ref&&a.isRef(e)){const s=r.each(e,{...t,path:l,key:o});if(s===e)return;return s}for(const s in e){if(\"_\"===s[0])continue;const n=i.scan(e[s],t,r,[s,...l],o);void 0!==n&&(c=c||Object.assign({},e),c[s]=n)}return c}},6133:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(9621),i=r(8160);let o;const l={symbol:Symbol(\"ref\"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:\".\",type:\"value\"}};t.create=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};s(\"string\"==typeof e,\"Invalid reference key:\",e),i.assertOptions(t,[\"adjust\",\"ancestor\",\"in\",\"iterables\",\"map\",\"prefix\",\"render\",\"separator\"]),s(!t.prefix||\"object\"==typeof t.prefix,\"options.prefix must be of type object\");const r=Object.assign({},l.defaults,t);delete r.prefix;const n=r.separator,a=l.context(e,n,t.prefix);if(r.type=a.type,e=a.key,\"value\"===r.type)if(a.root&&(s(!n||e[0]!==n,\"Cannot specify relative path with root prefix\"),r.ancestor=\"root\",e||(e=null)),n&&n===e)e=null,r.ancestor=0;else if(void 0!==r.ancestor)s(!n||!e||e[0]!==n,\"Cannot combine prefix with ancestor option\");else{const[t,s]=l.ancestor(e,n);s&&\"\"===(e=e.slice(s))&&(e=null),r.ancestor=t}return r.path=n?null===e?[]:e.split(n):[e],new l.Ref(r)},t.in=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.create(e,{...r,in:!0})},t.isRef=function(e){return!!e&&!!e[i.symbols.ref]},l.Ref=class{constructor(e){s(\"object\"==typeof e,\"Invalid reference construction\"),i.assertOptions(e,[\"adjust\",\"ancestor\",\"in\",\"iterables\",\"map\",\"path\",\"render\",\"separator\",\"type\",\"depth\",\"key\",\"root\",\"display\"]),s([!1,void 0].includes(e.separator)||\"string\"==typeof e.separator&&1===e.separator.length,\"Invalid separator\"),s(!e.adjust||\"function\"==typeof e.adjust,\"options.adjust must be a function\"),s(!e.map||Array.isArray(e.map),\"options.map must be an array\"),s(!e.map||!e.adjust,\"Cannot set both map and adjust options\"),Object.assign(this,l.defaults,e),s(\"value\"===this.type||void 0===this.ancestor,\"Non-value references cannot reference ancestors\"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(e,t,r,n){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};return s(!this.in||a.in,\"Invalid in() reference usage\"),\"global\"===this.type?this._resolve(r.context,t,a):\"local\"===this.type?this._resolve(n,t,a):this.ancestor?\"root\"===this.ancestor?this._resolve(t.ancestors[t.ancestors.length-1],t,a):(s(this.ancestor<=t.ancestors.length,\"Invalid reference exceeds the schema root:\",this.display),this._resolve(t.ancestors[this.ancestor-1],t,a)):this._resolve(e,t,a)}_resolve(e,t,r){let s;if(\"value\"===this.type&&t.mainstay.shadow&&!1!==r.shadow&&(s=t.mainstay.shadow.get(this.absolute(t))),void 0===s&&(s=a(e,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(s=this.adjust(s)),this.map){const e=this.map.get(s);void 0!==e&&(s=e)}return t.mainstay&&t.mainstay.tracer.resolve(t,this,s),s}toString(){return this.display}absolute(e){return[...e.path.slice(0,-this.ancestor),...this.path]}clone(){return new l.Ref(this)}describe(){const e={path:this.path};\"value\"!==this.type&&(e.type=this.type),\".\"!==this.separator&&(e.separator=this.separator),\"value\"===this.type&&1!==this.ancestor&&(e.ancestor=this.ancestor),this.map&&(e.map=[...this.map]);for(const t of[\"adjust\",\"iterables\",\"render\"])null!==this[t]&&void 0!==this[t]&&(e[t]=this[t]);return!1!==this.in&&(e.in=!0),{ref:e}}updateDisplay(){const e=null!==this.key?this.key:\"\";if(\"value\"!==this.type)return void(this.display=`ref:${this.type}:${e}`);if(!this.separator)return void(this.display=`ref:${e}`);if(!this.ancestor)return void(this.display=`ref:${this.separator}${e}`);if(\"root\"===this.ancestor)return void(this.display=`ref:root:${e}`);if(1===this.ancestor)return void(this.display=`ref:${e||\"..\"}`);const t=new Array(this.ancestor+1).fill(this.separator).join(\"\");this.display=`ref:${t}${e||\"\"}`}},l.Ref.prototype[i.symbols.ref]=!0,t.build=function(e){return\"value\"===(e=Object.assign({},l.defaults,e)).type&&void 0===e.ancestor&&(e.ancestor=1),new l.Ref(e)},l.context=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(e=e.trim(),r){const s=void 0===r.global?\"$\":r.global;if(s!==t&&e.startsWith(s))return{key:e.slice(s.length),type:\"global\"};const n=void 0===r.local?\"#\":r.local;if(n!==t&&e.startsWith(n))return{key:e.slice(n.length),type:\"local\"};const a=void 0===r.root?\"/\":r.root;if(a!==t&&e.startsWith(a))return{key:e.slice(a.length),type:\"value\",root:!0}}return{key:e,type:\"value\"}},l.ancestor=function(e,t){if(!t)return[1,0];if(e[0]!==t)return[1,0];if(e[1]!==t)return[0,1];let r=2;for(;e[r]===t;)++r;return[r-1,r]},t.toSibling=0,t.toParent=1,t.Manager=class{constructor(){this.refs=[]}register(e,s){if(e)if(s=void 0===s?t.toParent:s,Array.isArray(e))for(const t of e)this.register(t,s);else if(i.isSchema(e))for(const t of e._refs.refs)t.ancestor-s>=0&&this.refs.push({ancestor:t.ancestor-s,root:t.root});else t.isRef(e)&&\"value\"===e.type&&e.ancestor-s>=0&&this.refs.push({ancestor:e.ancestor-s,root:e.root}),o=o||r(3328),o.isTemplate(e)&&this.register(e.refs(),s)}get length(){return this.refs.length}clone(){const e=new t.Manager;return e.refs=n(this.refs),e}reset(){this.refs=[]}roots(){return this.refs.filter((e=>!e.ancestor)).map((e=>e.root))}}},3378:(e,t,r)=>{\"use strict\";const s=r(5107),n={};n.wrap=s.string().min(1).max(2).allow(!1),t.preferences=s.object({allowUnknown:s.boolean(),abortEarly:s.boolean(),artifacts:s.boolean(),cache:s.boolean(),context:s.object(),convert:s.boolean(),dateFormat:s.valid(\"date\",\"iso\",\"string\",\"time\",\"utc\"),debug:s.boolean(),errors:{escapeHtml:s.boolean(),label:s.valid(\"path\",\"key\",!1),language:[s.string(),s.object().ref()],render:s.boolean(),stack:s.boolean(),wrap:{label:n.wrap,array:n.wrap,string:n.wrap}},externals:s.boolean(),messages:s.object(),noDefaults:s.boolean(),nonEnumerables:s.boolean(),presence:s.valid(\"required\",\"optional\",\"forbidden\"),skipFunctions:s.boolean(),stripUnknown:s.object({arrays:s.boolean(),objects:s.boolean()}).or(\"arrays\",\"objects\").allow(!0,!1),warnings:s.boolean()}).strict(),n.nameRx=/^[a-zA-Z0-9]\\w*$/,n.rule=s.object({alias:s.array().items(s.string().pattern(n.nameRx)).single(),args:s.array().items(s.string(),s.object({name:s.string().pattern(n.nameRx).required(),ref:s.boolean(),assert:s.alternatives([s.function(),s.object().schema()]).conditional(\"ref\",{is:!0,then:s.required()}),normalize:s.function(),message:s.string().when(\"assert\",{is:s.function(),then:s.required()})})),convert:s.boolean(),manifest:s.boolean(),method:s.function().allow(!1),multi:s.boolean(),validate:s.function()}),t.extension=s.object({type:s.alternatives([s.string(),s.object().regex()]).required(),args:s.function(),cast:s.object().pattern(n.nameRx,s.object({from:s.function().maxArity(1).required(),to:s.function().minArity(1).maxArity(2).required()})),base:s.object().schema().when(\"type\",{is:s.object().regex(),then:s.forbidden()}),coerce:[s.function().maxArity(3),s.object({method:s.function().maxArity(3).required(),from:s.array().items(s.string()).single()})],flags:s.object().pattern(n.nameRx,s.object({setter:s.string(),default:s.any()})),manifest:{build:s.function().arity(2)},messages:[s.object(),s.string()],modifiers:s.object().pattern(n.nameRx,s.function().minArity(1).maxArity(2)),overrides:s.object().pattern(n.nameRx,s.function()),prepare:s.function().maxArity(3),rebuild:s.function().arity(1),rules:s.object().pattern(n.nameRx,n.rule),terms:s.object().pattern(n.nameRx,s.object({init:s.array().allow(null).required(),manifest:s.object().pattern(/.+/,[s.valid(\"schema\",\"single\"),s.object({mapped:s.object({from:s.string().required(),to:s.string().required()}).required()})])})),validate:s.function().maxArity(3)}).strict(),t.extensions=s.array().items(s.object(),s.function().arity(1)).strict(),n.desc={buffer:s.object({buffer:s.string()}),func:s.object({function:s.function().required(),options:{literal:!0}}),override:s.object({override:!0}),ref:s.object({ref:s.object({type:s.valid(\"value\",\"global\",\"local\"),path:s.array().required(),separator:s.string().length(1).allow(!1),ancestor:s.number().min(0).integer().allow(\"root\"),map:s.array().items(s.array().length(2)).min(1),adjust:s.function(),iterables:s.boolean(),in:s.boolean(),render:s.boolean()}).required()}),regex:s.object({regex:s.string().min(3)}),special:s.object({special:s.valid(\"deep\").required()}),template:s.object({template:s.string().required(),options:s.object()}),value:s.object({value:s.alternatives([s.object(),s.array()]).required()})},n.desc.entity=s.alternatives([s.array().items(s.link(\"...\")),s.boolean(),s.function(),s.number(),s.string(),n.desc.buffer,n.desc.func,n.desc.ref,n.desc.regex,n.desc.special,n.desc.template,n.desc.value,s.link(\"/\")]),n.desc.values=s.array().items(null,s.boolean(),s.function(),s.number().allow(1/0,-1/0),s.string().allow(\"\"),s.symbol(),n.desc.buffer,n.desc.func,n.desc.override,n.desc.ref,n.desc.regex,n.desc.template,n.desc.value),n.desc.messages=s.object().pattern(/.+/,[s.string(),n.desc.template,s.object().pattern(/.+/,[s.string(),n.desc.template])]),t.description=s.object({type:s.string().required(),flags:s.object({cast:s.string(),default:s.any(),description:s.string(),empty:s.link(\"/\"),failover:n.desc.entity,id:s.string(),label:s.string(),only:!0,presence:[\"optional\",\"required\",\"forbidden\"],result:[\"raw\",\"strip\"],strip:s.boolean(),unit:s.string()}).unknown(),preferences:{allowUnknown:s.boolean(),abortEarly:s.boolean(),artifacts:s.boolean(),cache:s.boolean(),convert:s.boolean(),dateFormat:[\"date\",\"iso\",\"string\",\"time\",\"utc\"],errors:{escapeHtml:s.boolean(),label:[\"path\",\"key\"],language:[s.string(),n.desc.ref],wrap:{label:n.wrap,array:n.wrap}},externals:s.boolean(),messages:n.desc.messages,noDefaults:s.boolean(),nonEnumerables:s.boolean(),presence:[\"required\",\"optional\",\"forbidden\"],skipFunctions:s.boolean(),stripUnknown:s.object({arrays:s.boolean(),objects:s.boolean()}).or(\"arrays\",\"objects\").allow(!0,!1),warnings:s.boolean()},allow:n.desc.values,invalid:n.desc.values,rules:s.array().min(1).items({name:s.string().required(),args:s.object().min(1),keep:s.boolean(),message:[s.string(),n.desc.messages],warn:s.boolean()}),keys:s.object().pattern(/.*/,s.link(\"/\")),link:n.desc.ref}).pattern(/^[a-z]\\w*$/,s.any())},493:(e,t,r)=>{\"use strict\";const s=r(8571),n=r(9621),a=r(8160),i={value:Symbol(\"value\")};e.exports=i.State=class{constructor(e,t,r){this.path=e,this.ancestors=t,this.mainstay=r.mainstay,this.schemas=r.schemas,this.debug=null}localize(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const s=new i.State(e,t,this);return r&&s.schemas&&(s.schemas=[i.schemas(r),...s.schemas]),s}nest(e,t){const r=new i.State(this.path,this.ancestors,this);return r.schemas=r.schemas&&[i.schemas(e),...r.schemas],r.debug=t,r}shadow(e,t){this.mainstay.shadow=this.mainstay.shadow||new i.Shadow,this.mainstay.shadow.set(this.path,e,t)}snapshot(){this.mainstay.shadow&&(this._snapshot=s(this.mainstay.shadow.node(this.path))),this.mainstay.snapshot()}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.restore()}commit(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.commit()}},i.schemas=function(e){return a.isSchema(e)?{schema:e}:e},i.Shadow=class{constructor(){this._values=null}set(e,t,r){if(!e.length)return;if(\"strip\"===r&&\"number\"==typeof e[e.length-1])return;this._values=this._values||new Map;let s=this._values;for(let t=0;t<e.length;++t){const r=e[t];let n=s.get(r);n||(n=new Map,s.set(r,n)),s=n}s[i.value]=t}get(e){const t=this.node(e);if(t)return t[i.value]}node(e){if(this._values)return n(this._values,e,{iterables:!0})}override(e,t){if(!this._values)return;const r=e.slice(0,-1),s=e[e.length-1],a=n(this._values,r,{iterables:!0});t?a.set(s,t):a&&a.delete(s)}}},3328:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(5277),i=r(1447),o=r(8160),l=r(6354),c=r(6133),u={symbol:Symbol(\"template\"),opens:new Array(1e3).join(\"\\0\"),closes:new Array(1e3).join(\"\u0001\"),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};e.exports=u.Template=class{constructor(e,t){if(s(\"string\"==typeof e,\"Template source must be a string\"),s(!e.includes(\"\\0\")&&!e.includes(\"\u0001\"),\"Template source cannot contain reserved control characters\"),this.source=e,this.rendered=e,this._template=null,t){const{functions:e,...r}=t;this._settings=Object.keys(r).length?n(r):void 0,this._functions=e,this._functions&&(s(Object.keys(this._functions).every((e=>\"string\"==typeof e)),\"Functions keys must be strings\"),s(Object.values(this._functions).every((e=>\"function\"==typeof e)),\"Functions values must be functions\"))}else this._settings=void 0,this._functions=void 0;this._parse()}_parse(){if(!this.source.includes(\"{\"))return;const e=u.encode(this.source),t=u.split(e);let r=!1;const s=[],n=t.shift();n&&s.push(n);for(const e of t){const t=\"{\"!==e[0],n=t?\"}\":\"}}\",a=e.indexOf(n);if(-1===a||\"{\"===e[1]){s.push(`{${u.decode(e)}`);continue}let i=e.slice(t?0:1,a);const o=\":\"===i[0];o&&(i=i.slice(1));const l=this._ref(u.decode(i),{raw:t,wrapped:o});s.push(l),\"string\"!=typeof l&&(r=!0);const c=e.slice(a+n.length);c&&s.push(u.decode(c))}r?this._template=s:this.rendered=s.join(\"\")}static date(e,t){return u.dateFormat[t.dateFormat].call(e)}describe(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!this._settings&&e.compact)return this.source;const t={template:this.source};return this._settings&&(t.options=this._settings),this._functions&&(t.functions=this._functions),t}static build(e){return new u.Template(e.template,e.options||e.functions?{...e.options,functions:e.functions}:void 0)}isDynamic(){return!!this._template}static isTemplate(e){return!!e&&!!e[o.symbols.template]}refs(){if(!this._template)return;const e=[];for(const t of this._template)\"string\"!=typeof t&&e.push(...t.refs);return e}resolve(e,t,r,s){return this._template&&1===this._template.length?this._part(this._template[0],e,t,r,s,{}):this.render(e,t,r,s)}_part(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),s=1;s<t;s++)r[s-1]=arguments[s];return e.ref?e.ref.resolve(...r):e.formula.evaluate(r)}render(e,t,r,s){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(!this.isDynamic())return this.rendered;const i=[];for(const o of this._template)if(\"string\"==typeof o)i.push(o);else{const l=this._part(o,e,t,r,s,n),c=u.stringify(l,e,t,r,s,n);if(void 0!==c){const e=o.raw||!1===(n.errors&&n.errors.escapeHtml)?c:a(c);i.push(u.wrap(e,o.wrapped&&r.errors.wrap.label))}}return i.join(\"\")}_ref(e,t){let{raw:r,wrapped:s}=t;const n=[],a=e=>{const t=c.create(e,this._settings);return n.push(t),e=>{const r=t.resolve(...e);return void 0!==r?r:null}};try{const t=this._functions?{...u.functions,...this._functions}:u.functions;var o=new i.Parser(e,{reference:a,functions:t,constants:u.constants})}catch(t){throw t.message=`Invalid template variable \"${e}\" fails due to: ${t.message}`,t}if(o.single){if(\"reference\"===o.single.type){const e=n[0];return{ref:e,raw:r,refs:n,wrapped:s||\"local\"===e.type&&\"label\"===e.key}}return u.stringify(o.single.value)}return{formula:o,raw:r,refs:n}}toString(){return this.source}},u.Template.prototype[o.symbols.template]=!0,u.Template.prototype.isImmutable=!0,u.encode=function(e){return e.replace(/\\\\(\\{+)/g,((e,t)=>u.opens.slice(0,t.length))).replace(/\\\\(\\}+)/g,((e,t)=>u.closes.slice(0,t.length)))},u.decode=function(e){return e.replace(/\\u0000/g,\"{\").replace(/\\u0001/g,\"}\")},u.split=function(e){const t=[];let r=\"\";for(let s=0;s<e.length;++s){const n=e[s];if(\"{\"===n){let n=\"\";for(;s+1<e.length&&\"{\"===e[s+1];)n+=\"{\",++s;t.push(r),r=n}else r+=n}return t.push(r),t},u.wrap=function(e,t){return t?1===t.length?`${t}${e}${t}`:`${t[0]}${e}${t[1]}`:e},u.stringify=function(e,t,r,s,n){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const i=typeof e,o=s&&s.errors&&s.errors.wrap||{};let l=!1;if(c.isRef(e)&&e.render&&(l=e.in,e=e.resolve(t,r,s,n,{in:e.in,...a})),null===e)return\"null\";if(\"string\"===i)return u.wrap(e,a.arrayItems&&o.string);if(\"number\"===i||\"function\"===i||\"symbol\"===i)return e.toString();if(\"object\"!==i)return JSON.stringify(e);if(e instanceof Date)return u.Template.date(e,s);if(e instanceof Map){const t=[];for(const[r,s]of e.entries())t.push(`${r.toString()} -> ${s.toString()}`);e=t}if(!Array.isArray(e))return e.toString();const f=[];for(const i of e)f.push(u.stringify(i,t,r,s,n,{arrayItems:!0,...a}));return u.wrap(f.join(\", \"),!l&&o.array)},u.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},u.functions={if:(e,t,r)=>e?t:r,length:e=>\"string\"==typeof e?e.length:e&&\"object\"==typeof e?Array.isArray(e)?e.length:Object.keys(e).length:null,msg(e){const[t,r,s,n,a]=this,i=a.messages;if(!i)return\"\";const o=l.template(t,i[0],e,r,s)||l.template(t,i[1],e,r,s);return o?o.render(t,r,s,n,a):\"\"},number:e=>\"number\"==typeof e?e:\"string\"==typeof e?parseFloat(e):\"boolean\"==typeof e?e?1:0:e instanceof Date?e.getTime():null}},4946:(e,t,r)=>{\"use strict\";const s=r(375),n=r(1687),a=r(8068),i=r(8160),o=r(3292),l=r(6354),c=r(6133),u={};e.exports=a.extend({type:\"alternatives\",flags:{match:{default:\"any\"}},terms:{matches:{init:[],register:c.toSibling}},args(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),s=1;s<t;s++)r[s-1]=arguments[s];return 1===r.length&&Array.isArray(r[0])?e.try(...r[0]):e.try(...r)},validate(e,t){const{schema:r,error:s,state:a,prefs:i}=t;if(r._flags.match){const t=[],o=[];for(let s=0;s<r.$_terms.matches.length;++s){const n=r.$_terms.matches[s],l=a.nest(n.schema,`match.${s}`);l.snapshot();const c=n.schema.$_validate(e,l,i);c.errors?(o.push(c.errors),l.restore()):(t.push(c.value),l.commit())}if(0===t.length)return{errors:s(\"alternatives.any\",{details:o.map((e=>l.details(e,{override:!1})))})};if(\"one\"===r._flags.match)return 1===t.length?{value:t[0]}:{errors:s(\"alternatives.one\")};if(t.length!==r.$_terms.matches.length)return{errors:s(\"alternatives.all\",{details:o.map((e=>l.details(e,{override:!1})))})};const c=e=>e.$_terms.matches.some((e=>\"object\"===e.schema.type||\"alternatives\"===e.schema.type&&c(e.schema)));return c(r)?{value:t.reduce(((e,t)=>n(e,t,{mergeArrays:!1})))}:{value:t[t.length-1]}}const o=[];for(let t=0;t<r.$_terms.matches.length;++t){const s=r.$_terms.matches[t];if(s.schema){const r=a.nest(s.schema,`match.${t}`);r.snapshot();const n=s.schema.$_validate(e,r,i);if(!n.errors)return r.commit(),n;r.restore(),o.push({schema:s.schema,reports:n.errors});continue}const n=s.ref?s.ref.resolve(e,a,i):e,l=s.is?[s]:s.switch;for(let r=0;r<l.length;++r){const o=l[r],{is:c,then:u,otherwise:f}=o,h=`match.${t}${s.switch?\".\"+r:\"\"}`;if(c.$_match(n,a.nest(c,`${h}.is`),i)){if(u)return u.$_validate(e,a.nest(u,`${h}.then`),i)}else if(f)return f.$_validate(e,a.nest(f,`${h}.otherwise`),i)}}return u.errors(o,t)},rules:{conditional:{method(e,t){s(!this._flags._endedSwitch,\"Unreachable condition\"),s(!this._flags.match,\"Cannot combine match mode\",this._flags.match,\"with conditional rule\"),s(void 0===t.break,\"Cannot use break option with alternatives conditional\");const r=this.clone(),n=o.when(r,e,t),a=n.is?[n]:n.switch;for(const e of a)if(e.then&&e.otherwise){r.$_setFlag(\"_endedSwitch\",!0,{clone:!1});break}return r.$_terms.matches.push(n),r.$_mutateRebuild()}},match:{method(e){if(s([\"any\",\"one\",\"all\"].includes(e),\"Invalid alternatives match mode\",e),\"any\"!==e)for(const t of this.$_terms.matches)s(t.schema,\"Cannot combine match mode\",e,\"with conditional rules\");return this.$_setFlag(\"match\",e)}},try:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];s(t.length,\"Missing alternative schemas\"),i.verifyFlat(t,\"try\"),s(!this._flags._endedSwitch,\"Unreachable condition\");const n=this.clone();for(const e of t)n.$_terms.matches.push({schema:n.$_compile(e)});return n.$_mutateRebuild()}}},overrides:{label(e){return this.$_parent(\"label\",e).$_modify({each:(t,r)=>\"is\"!==r.path[0]?t.label(e):void 0,ref:!1})}},rebuild(e){e.$_modify({each:t=>{i.isSchema(t)&&\"array\"===t.type&&e.$_setFlag(\"_arrayItems\",!0,{clone:!1})}})},manifest:{build(e,t){if(t.matches)for(const r of t.matches){const{schema:t,ref:s,is:n,not:a,then:i,otherwise:o}=r;e=t?e.try(t):s?e.conditional(s,{is:n,then:i,not:a,otherwise:o,switch:r.switch}):e.conditional(n,{then:i,otherwise:o})}return e}},messages:{\"alternatives.all\":\"{{#label}} does not match all of the required types\",\"alternatives.any\":\"{{#label}} does not match any of the allowed types\",\"alternatives.match\":\"{{#label}} does not match any of the allowed types\",\"alternatives.one\":\"{{#label}} matches more than one allowed type\",\"alternatives.types\":\"{{#label}} must be one of {{#types}}\"}}),u.errors=function(e,t){let{error:r,state:s}=t;if(!e.length)return{errors:r(\"alternatives.any\")};if(1===e.length)return{errors:e[0].reports};const n=new Set,a=[];for(const{reports:t,schema:i}of e){if(t.length>1)return u.unmatched(e,r);const o=t[0];if(o instanceof l.Report==0)return u.unmatched(e,r);if(o.state.path.length!==s.path.length){a.push({type:i.type,report:o});continue}if(\"any.only\"===o.code){for(const e of o.local.valids)n.add(e);continue}const[c,f]=o.code.split(\".\");\"base\"===f?n.add(c):a.push({type:i.type,report:o})}return a.length?1===a.length?{errors:a[0].report}:u.unmatched(e,r):{errors:r(\"alternatives.types\",{types:[...n]})}},u.unmatched=function(e,t){const r=[];for(const t of e)r.push(...t.reports);return{errors:t(\"alternatives.match\",l.details(r,{override:!1}))}}},8068:(e,t,r)=>{\"use strict\";const s=r(375),n=r(7629),a=r(8160),i=r(6914);e.exports=n.extend({type:\"any\",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(e,t){return s(\"function\"==typeof e,\"Method must be a function\"),s(void 0===t||t&&\"string\"==typeof t,\"Description must be a non-empty string\"),this.$_addRule({name:\"custom\",args:{method:e,description:t}})},validate(e,t,r){let{method:s}=r;try{return s(e,t)}catch(e){return t.error(\"any.custom\",{error:e})}},args:[\"method\",\"description\"],multi:!0},messages:{method(e){return this.prefs({messages:e})}},shared:{method(e){s(a.isSchema(e)&&e._flags.id,\"Schema must be a schema with an id\");const t=this.clone();return t.$_terms.shared=t.$_terms.shared||[],t.$_terms.shared.push(e),t.$_mutateRegister(e),t}},warning:{method(e,t){return s(e&&\"string\"==typeof e,\"Invalid warning code\"),this.$_addRule({name:\"warning\",args:{code:e,local:t},warn:!0})},validate(e,t,r){let{code:s,local:n}=r;return t.error(s,n)},args:[\"code\",\"local\"],multi:!0}},modifiers:{keep(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];e.keep=t},message(e,t){e.message=i.compile(t)},warn(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];e.warn=t}},manifest:{build(e,t){for(const r in t){const s=t[r];if([\"examples\",\"externals\",\"metas\",\"notes\",\"tags\"].includes(r))for(const t of s)e=e[r.slice(0,-1)](t);else if(\"alterations\"!==r)if(\"whens\"!==r){if(\"shared\"===r)for(const t of s)e=e.shared(t)}else for(const t of s){const{ref:r,is:s,not:n,then:a,otherwise:i,concat:o}=t;e=o?e.concat(o):r?e.when(r,{is:s,not:n,then:a,otherwise:i,switch:t.switch,break:t.break}):e.when(s,{then:a,otherwise:i,break:t.break})}else{const t={};for(const{target:e,adjuster:r}of s)t[e]=r;e=e.alter(t)}}return e}},messages:{\"any.custom\":\"{{#label}} failed custom validation because {{#error.message}}\",\"any.default\":\"{{#label}} threw an error when running default method\",\"any.failover\":\"{{#label}} threw an error when running failover method\",\"any.invalid\":\"{{#label}} contains an invalid value\",\"any.only\":'{{#label}} must be {if(#valids.length == 1, \"\", \"one of \")}{{#valids}}',\"any.ref\":\"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}\",\"any.required\":\"{{#label}} is required\",\"any.unknown\":\"{{#label}} is not allowed\"}})},546:(e,t,r)=>{\"use strict\";const s=r(375),n=r(9474),a=r(9621),i=r(8068),o=r(8160),l=r(3292),c={};e.exports=i.extend({type:\"array\",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:\"schema\"},ordered:{init:[],manifest:\"schema\"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:\"object\",method(e,t){let{schema:r,state:s,prefs:n}=t;if(!Array.isArray(e))return;const a=r.$_getRule(\"sort\");return a?c.sort(r,e,a.args.options,s,n):void 0}},validate(e,t){let{schema:r,error:s}=t;if(!Array.isArray(e)){if(r._flags.single){const t=[e];return t[o.symbols.arraySingle]=!0,{value:t}}return{errors:s(\"array.base\")}}if(r.$_getRule(\"items\")||r.$_terms.externals)return{value:e.slice()}},rules:{has:{method(e){e=this.$_compile(e,{appendPath:!0});const t=this.$_addRule({name:\"has\",args:{schema:e}});return t.$_mutateRegister(e),t},validate(e,t,r){let{state:s,prefs:n,error:a}=t,{schema:i}=r;const o=[e,...s.ancestors];for(let t=0;t<e.length;++t){const r=s.localize([...s.path,t],o,i);if(i.$_match(e[t],r,n))return e}const l=i._flags.label;return l?a(\"array.hasKnown\",{patternLabel:l}):a(\"array.hasUnknown\",null)},multi:!0},items:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];o.verifyFlat(t,\"items\");const s=this.$_addRule(\"items\");for(let e=0;e<t.length;++e){const r=o.tryWithPath((()=>this.$_compile(t[e])),e,{append:!0});s.$_terms.items.push(r)}return s.$_mutateRebuild()},validate(e,t){let{schema:r,error:s,state:n,prefs:a,errorsArray:i}=t;const l=r.$_terms._requireds.slice(),u=r.$_terms.ordered.slice(),f=[...r.$_terms._inclusions,...l],h=!e[o.symbols.arraySingle];delete e[o.symbols.arraySingle];const m=i();let d=e.length;for(let t=0;t<d;++t){const i=e[t];let o=!1,p=!1;const g=h?t:new Number(t),y=[...n.path,g];if(!r._flags.sparse&&void 0===i){if(m.push(s(\"array.sparse\",{key:g,path:y,pos:t,value:void 0},n.localize(y))),a.abortEarly)return m;u.shift();continue}const b=[e,...n.ancestors];for(const e of r.$_terms._exclusions)if(e.$_match(i,n.localize(y,b,e),a,{presence:\"ignore\"})){if(m.push(s(\"array.excludes\",{pos:t,value:i},n.localize(y))),a.abortEarly)return m;o=!0,u.shift();break}if(o)continue;if(r.$_terms.ordered.length){if(u.length){const o=u.shift(),l=o.$_validate(i,n.localize(y,b,o),a);if(l.errors){if(m.push(...l.errors),a.abortEarly)return m}else if(\"strip\"===o._flags.result)c.fastSplice(e,t),--t,--d;else{if(!r._flags.sparse&&void 0===l.value){if(m.push(s(\"array.sparse\",{key:g,path:y,pos:t,value:void 0},n.localize(y))),a.abortEarly)return m;continue}e[t]=l.value}continue}if(!r.$_terms.items.length){if(m.push(s(\"array.orderedLength\",{pos:t,limit:r.$_terms.ordered.length})),a.abortEarly)return m;break}}const v=[];let _=l.length;for(let o=0;o<_;++o){const u=n.localize(y,b,l[o]);u.snapshot();const f=l[o].$_validate(i,u,a);if(v[o]=f,!f.errors){if(u.commit(),e[t]=f.value,p=!0,c.fastSplice(l,o),--o,--_,!r._flags.sparse&&void 0===f.value&&(m.push(s(\"array.sparse\",{key:g,path:y,pos:t,value:void 0},n.localize(y))),a.abortEarly))return m;break}u.restore()}if(p)continue;const w=a.stripUnknown&&!!a.stripUnknown.arrays||!1;_=f.length;for(const u of f){let f;const h=l.indexOf(u);if(-1!==h)f=v[h];else{const l=n.localize(y,b,u);if(l.snapshot(),f=u.$_validate(i,l,a),!f.errors){l.commit(),\"strip\"===u._flags.result?(c.fastSplice(e,t),--t,--d):r._flags.sparse||void 0!==f.value?e[t]=f.value:(m.push(s(\"array.sparse\",{key:g,path:y,pos:t,value:void 0},n.localize(y))),o=!0),p=!0;break}l.restore()}if(1===_){if(w){c.fastSplice(e,t),--t,--d,p=!0;break}if(m.push(...f.errors),a.abortEarly)return m;o=!0;break}}if(!o&&(r.$_terms._inclusions.length||r.$_terms._requireds.length)&&!p){if(w){c.fastSplice(e,t),--t,--d;continue}if(m.push(s(\"array.includes\",{pos:t,value:i},n.localize(y))),a.abortEarly)return m}}return l.length&&c.fillMissedErrors(r,m,l,e,n,a),u.length&&(c.fillOrderedErrors(r,m,u,e,n,a),m.length||c.fillDefault(u,e,n,a)),m.length?m:e},priority:!0,manifest:!1},length:{method(e){return this.$_addRule({name:\"length\",args:{limit:e},operator:\"=\"})},validate(e,t,r,s){let{limit:n}=r,{name:a,operator:i,args:l}=s;return o.compare(e.length,n,i)?e:t.error(\"array.\"+a,{limit:l.limit,value:e})},args:[{name:\"limit\",ref:!0,assert:o.limit,message:\"must be a positive integer\"}]},max:{method(e){return this.$_addRule({name:\"max\",method:\"length\",args:{limit:e},operator:\"<=\"})}},min:{method(e){return this.$_addRule({name:\"min\",method:\"length\",args:{limit:e},operator:\">=\"})}},ordered:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];o.verifyFlat(t,\"ordered\");const s=this.$_addRule(\"items\");for(let e=0;e<t.length;++e){const r=o.tryWithPath((()=>this.$_compile(t[e])),e,{append:!0});c.validateSingle(r,s),s.$_mutateRegister(r),s.$_terms.ordered.push(r)}return s.$_mutateRebuild()}},single:{method(e){const t=void 0===e||!!e;return s(!t||!this._flags._arrayItems,\"Cannot specify single rule when array has array items\"),this.$_setFlag(\"single\",t)}},sort:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};o.assertOptions(e,[\"by\",\"order\"]);const t={order:e.order||\"ascending\"};return e.by&&(t.by=l.ref(e.by,{ancestor:0}),s(!t.by.ancestor,\"Cannot sort by ancestor\")),this.$_addRule({name:\"sort\",args:{options:t}})},validate(e,t,r){let{error:s,state:n,prefs:a,schema:i}=t,{options:o}=r;const{value:l,errors:u}=c.sort(i,e,o,n,a);if(u)return u;for(let t=0;t<e.length;++t)if(e[t]!==l[t])return s(\"array.sort\",{order:o.order,by:o.by?o.by.key:\"value\"});return e},convert:!0},sparse:{method(e){const t=void 0===e||!!e;return this._flags.sparse===t?this:(t?this.clone():this.$_addRule(\"items\")).$_setFlag(\"sparse\",t,{clone:!1})}},unique:{method(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};s(!e||\"function\"==typeof e||\"string\"==typeof e,\"comparator must be a function or a string\"),o.assertOptions(t,[\"ignoreUndefined\",\"separator\"]);const r={name:\"unique\",args:{options:t,comparator:e}};if(e)if(\"string\"==typeof e){const s=o.default(t.separator,\".\");r.path=s?e.split(s):[e]}else r.comparator=e;return this.$_addRule(r)},validate(e,t,r,i){let{state:o,error:l,schema:c}=t,{comparator:u,options:f}=r,{comparator:h,path:m}=i;const d={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),object:new Map,function:new Map,custom:new Map},p=h||n,g=f.ignoreUndefined;for(let t=0;t<e.length;++t){const r=m?a(e[t],m):e[t],n=h?d.custom:d[typeof r];if(s(n,\"Failed to find unique map container for type\",typeof r),n instanceof Map){const s=n.entries();let a;for(;!(a=s.next()).done;)if(p(a.value[0],r)){const r=o.localize([...o.path,t],[e,...o.ancestors]),s={pos:t,value:e[t],dupePos:a.value[1],dupeValue:e[a.value[1]]};return m&&(s.path=u),l(\"array.unique\",s,r)}n.set(r,t)}else{if((!g||void 0!==r)&&void 0!==n[r]){const s={pos:t,value:e[t],dupePos:n[r],dupeValue:e[n[r]]};return m&&(s.path=u),l(\"array.unique\",s,o.localize([...o.path,t],[e,...o.ancestors]))}n[r]=t}}return e},args:[\"comparator\",\"options\"],multi:!0}},cast:{set:{from:Array.isArray,to:(e,t)=>new Set(e)}},rebuild(e){e.$_terms._inclusions=[],e.$_terms._exclusions=[],e.$_terms._requireds=[];for(const t of e.$_terms.items)c.validateSingle(t,e),\"required\"===t._flags.presence?e.$_terms._requireds.push(t):\"forbidden\"===t._flags.presence?e.$_terms._exclusions.push(t):e.$_terms._inclusions.push(t);for(const t of e.$_terms.ordered)c.validateSingle(t,e)},manifest:{build:(e,t)=>(t.items&&(e=e.items(...t.items)),t.ordered&&(e=e.ordered(...t.ordered)),e)},messages:{\"array.base\":\"{{#label}} must be an array\",\"array.excludes\":\"{{#label}} contains an excluded value\",\"array.hasKnown\":\"{{#label}} does not contain at least one required match for type {:#patternLabel}\",\"array.hasUnknown\":\"{{#label}} does not contain at least one required match\",\"array.includes\":\"{{#label}} does not match any of the allowed types\",\"array.includesRequiredBoth\":\"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)\",\"array.includesRequiredKnowns\":\"{{#label}} does not contain {{#knownMisses}}\",\"array.includesRequiredUnknowns\":\"{{#label}} does not contain {{#unknownMisses}} required value(s)\",\"array.length\":\"{{#label}} must contain {{#limit}} items\",\"array.max\":\"{{#label}} must contain less than or equal to {{#limit}} items\",\"array.min\":\"{{#label}} must contain at least {{#limit}} items\",\"array.orderedLength\":\"{{#label}} must contain at most {{#limit}} items\",\"array.sort\":\"{{#label}} must be sorted in {#order} order by {{#by}}\",\"array.sort.mismatching\":\"{{#label}} cannot be sorted due to mismatching types\",\"array.sort.unsupported\":\"{{#label}} cannot be sorted due to unsupported type {#type}\",\"array.sparse\":\"{{#label}} must not be a sparse array item\",\"array.unique\":\"{{#label}} contains a duplicate value\"}}),c.fillMissedErrors=function(e,t,r,s,n,a){const i=[];let o=0;for(const e of r){const t=e._flags.label;t?i.push(t):++o}i.length?o?t.push(e.$_createError(\"array.includesRequiredBoth\",s,{knownMisses:i,unknownMisses:o},n,a)):t.push(e.$_createError(\"array.includesRequiredKnowns\",s,{knownMisses:i},n,a)):t.push(e.$_createError(\"array.includesRequiredUnknowns\",s,{unknownMisses:o},n,a))},c.fillOrderedErrors=function(e,t,r,s,n,a){const i=[];for(const e of r)\"required\"===e._flags.presence&&i.push(e);i.length&&c.fillMissedErrors(e,t,i,s,n,a)},c.fillDefault=function(e,t,r,s){const n=[];let a=!0;for(let i=e.length-1;i>=0;--i){const o=e[i],l=[t,...r.ancestors],c=o.$_validate(void 0,r.localize(r.path,l,o),s).value;if(a){if(void 0===c)continue;a=!1}n.unshift(c)}n.length&&t.push(...n)},c.fastSplice=function(e,t){let r=t;for(;r<e.length;)e[r++]=e[r];--e.length},c.validateSingle=function(e,t){(\"array\"===e.type||e._flags._arrayItems)&&(s(!t._flags.single,\"Cannot specify array item with single rule enabled\"),t.$_setFlag(\"_arrayItems\",!0,{clone:!1}))},c.sort=function(e,t,r,s,n){const a=\"ascending\"===r.order?1:-1,i=-1*a,o=a,l=(l,u)=>{let f=c.compare(l,u,i,o);if(null!==f)return f;if(r.by&&(l=r.by.resolve(l,s,n),u=r.by.resolve(u,s,n)),f=c.compare(l,u,i,o),null!==f)return f;const h=typeof l;if(h!==typeof u)throw e.$_createError(\"array.sort.mismatching\",t,null,s,n);if(\"number\"!==h&&\"string\"!==h)throw e.$_createError(\"array.sort.unsupported\",t,{type:h},s,n);return\"number\"===h?(l-u)*a:l<u?i:o};try{return{value:t.slice().sort(l)}}catch(e){return{errors:e}}},c.compare=function(e,t,r,s){return e===t?0:void 0===e?1:void 0===t?-1:null===e?s:null===t?r:null}},4937:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8068),a=r(8160),i=r(2036),o={isBool:function(e){return\"boolean\"==typeof e}};e.exports=n.extend({type:\"boolean\",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:\"values\"},truthy:{init:null,manifest:\"values\"}},coerce(e,t){let{schema:r}=t;if(\"boolean\"!=typeof e){if(\"string\"==typeof e){const t=r._flags.sensitive?e:e.toLowerCase();e=\"true\"===t||\"false\"!==t&&e}return\"boolean\"!=typeof e&&(e=r.$_terms.truthy&&r.$_terms.truthy.has(e,null,null,!r._flags.sensitive)||(!r.$_terms.falsy||!r.$_terms.falsy.has(e,null,null,!r._flags.sensitive))&&e),{value:e}}},validate(e,t){let{error:r}=t;if(\"boolean\"!=typeof e)return{value:e,errors:r(\"boolean.base\")}},rules:{truthy:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a.verifyFlat(t,\"truthy\");const n=this.clone();n.$_terms.truthy=n.$_terms.truthy||new i;for(let e=0;e<t.length;++e){const r=t[e];s(void 0!==r,\"Cannot call truthy with undefined\"),n.$_terms.truthy.add(r)}return n}},falsy:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];a.verifyFlat(t,\"falsy\");const n=this.clone();n.$_terms.falsy=n.$_terms.falsy||new i;for(let e=0;e<t.length;++e){const r=t[e];s(void 0!==r,\"Cannot call falsy with undefined\"),n.$_terms.falsy.add(r)}return n}},sensitive:{method(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.$_setFlag(\"sensitive\",e)}}},cast:{number:{from:o.isBool,to:(e,t)=>e?1:0},string:{from:o.isBool,to:(e,t)=>e?\"true\":\"false\"}},manifest:{build:(e,t)=>(t.truthy&&(e=e.truthy(...t.truthy)),t.falsy&&(e=e.falsy(...t.falsy)),e)},messages:{\"boolean.base\":\"{{#label}} must be a boolean\"}})},7500:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8068),a=r(8160),i=r(3328),o={isDate:function(e){return e instanceof Date}};e.exports=n.extend({type:\"date\",coerce:{from:[\"number\",\"string\"],method(e,t){let{schema:r}=t;return{value:o.parse(e,r._flags.format)||e}}},validate(e,t){let{schema:r,error:s,prefs:n}=t;if(e instanceof Date&&!isNaN(e.getTime()))return;const a=r._flags.format;return n.convert&&a&&\"string\"==typeof e?{value:e,errors:s(\"date.format\",{format:a})}:{value:e,errors:s(\"date.base\")}},rules:{compare:{method:!1,validate(e,t,r,s){let{date:n}=r,{name:i,operator:o,args:l}=s;const c=\"now\"===n?Date.now():n.getTime();return a.compare(e.getTime(),c,o)?e:t.error(\"date.\"+i,{limit:l.date,value:e})},args:[{name:\"date\",ref:!0,normalize:e=>\"now\"===e?e:o.parse(e),assert:e=>null!==e,message:\"must have a valid date format\"}]},format:{method(e){return s([\"iso\",\"javascript\",\"unix\"].includes(e),\"Unknown date format\",e),this.$_setFlag(\"format\",e)}},greater:{method(e){return this.$_addRule({name:\"greater\",method:\"compare\",args:{date:e},operator:\">\"})}},iso:{method(){return this.format(\"iso\")}},less:{method(e){return this.$_addRule({name:\"less\",method:\"compare\",args:{date:e},operator:\"<\"})}},max:{method(e){return this.$_addRule({name:\"max\",method:\"compare\",args:{date:e},operator:\"<=\"})}},min:{method(e){return this.$_addRule({name:\"min\",method:\"compare\",args:{date:e},operator:\">=\"})}},timestamp:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"javascript\";return s([\"javascript\",\"unix\"].includes(e),'\"type\" must be one of \"javascript, unix\"'),this.format(e)}}},cast:{number:{from:o.isDate,to:(e,t)=>e.getTime()},string:{from:o.isDate,to(e,t){let{prefs:r}=t;return i.date(e,r)}}},messages:{\"date.base\":\"{{#label}} must be a valid date\",\"date.format\":'{{#label}} must be in {msg(\"date.format.\" + #format) || #format} format',\"date.greater\":\"{{#label}} must be greater than {{:#limit}}\",\"date.less\":\"{{#label}} must be less than {{:#limit}}\",\"date.max\":\"{{#label}} must be less than or equal to {{:#limit}}\",\"date.min\":\"{{#label}} must be greater than or equal to {{:#limit}}\",\"date.format.iso\":\"ISO 8601 date\",\"date.format.javascript\":\"timestamp or number of milliseconds\",\"date.format.unix\":\"timestamp or number of seconds\"}}),o.parse=function(e,t){if(e instanceof Date)return e;if(\"string\"!=typeof e&&(isNaN(e)||!isFinite(e)))return null;if(/^\\s*$/.test(e))return null;if(\"iso\"===t)return a.isIsoDate(e)?o.date(e.toString()):null;const r=e;if(\"string\"==typeof e&&/^[+-]?\\d+(\\.\\d+)?$/.test(e)&&(e=parseFloat(e)),t){if(\"javascript\"===t)return o.date(1*e);if(\"unix\"===t)return o.date(1e3*e);if(\"string\"==typeof r)return null}return o.date(e)},o.date=function(e){const t=new Date(e);return isNaN(t.getTime())?null:t}},390:(e,t,r)=>{\"use strict\";const s=r(375),n=r(7824);e.exports=n.extend({type:\"function\",properties:{typeof:\"function\"},rules:{arity:{method(e){return s(Number.isSafeInteger(e)&&e>=0,\"n must be a positive integer\"),this.$_addRule({name:\"arity\",args:{n:e}})},validate(e,t,r){let{n:s}=r;return e.length===s?e:t.error(\"function.arity\",{n:s})}},class:{method(){return this.$_addRule(\"class\")},validate:(e,t)=>/^\\s*class\\s/.test(e.toString())?e:t.error(\"function.class\",{value:e})},minArity:{method(e){return s(Number.isSafeInteger(e)&&e>0,\"n must be a strict positive integer\"),this.$_addRule({name:\"minArity\",args:{n:e}})},validate(e,t,r){let{n:s}=r;return e.length>=s?e:t.error(\"function.minArity\",{n:s})}},maxArity:{method(e){return s(Number.isSafeInteger(e)&&e>=0,\"n must be a positive integer\"),this.$_addRule({name:\"maxArity\",args:{n:e}})},validate(e,t,r){let{n:s}=r;return e.length<=s?e:t.error(\"function.maxArity\",{n:s})}}},messages:{\"function.arity\":\"{{#label}} must have an arity of {{#n}}\",\"function.class\":\"{{#label}} must be a class\",\"function.maxArity\":\"{{#label}} must have an arity lesser or equal to {{#n}}\",\"function.minArity\":\"{{#label}} must have an arity greater or equal to {{#n}}\"}})},7824:(e,t,r)=>{\"use strict\";const s=r(978),n=r(375),a=r(8571),i=r(3652),o=r(8068),l=r(8160),c=r(3292),u=r(6354),f=r(6133),h=r(3328),m={renameDefaults:{alias:!1,multiple:!1,override:!1}};e.exports=o.extend({type:\"_keys\",properties:{typeof:\"object\"},flags:{unknown:{default:!1}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:\"schema\",to:\"key\"}}},patterns:{init:null},renames:{init:null}},args:(e,t)=>e.keys(t),validate(e,t){let{schema:r,error:s,state:n,prefs:a}=t;if(!e||typeof e!==r.$_property(\"typeof\")||Array.isArray(e))return{value:e,errors:s(\"object.base\",{type:r.$_property(\"typeof\")})};if(!(r.$_terms.renames||r.$_terms.dependencies||r.$_terms.keys||r.$_terms.patterns||r.$_terms.externals))return;e=m.clone(e,a);const i=[];if(r.$_terms.renames&&!m.rename(r,e,n,a,i))return{value:e,errors:i};if(!r.$_terms.keys&&!r.$_terms.patterns&&!r.$_terms.dependencies)return{value:e,errors:i};const o=new Set(Object.keys(e));if(r.$_terms.keys){const t=[e,...n.ancestors];for(const s of r.$_terms.keys){const r=s.key,l=e[r];o.delete(r);const c=n.localize([...n.path,r],t,s),u=s.schema.$_validate(l,c,a);if(u.errors){if(a.abortEarly)return{value:e,errors:u.errors};void 0!==u.value&&(e[r]=u.value),i.push(...u.errors)}else\"strip\"===s.schema._flags.result||void 0===u.value&&void 0!==l?delete e[r]:void 0!==u.value&&(e[r]=u.value)}}if(o.size||r._flags._hasPatternMatch){const t=m.unknown(r,e,o,i,n,a);if(t)return t}if(r.$_terms.dependencies)for(const t of r.$_terms.dependencies){if(null!==t.key&&!1===m.isPresent(t.options)(t.key.resolve(e,n,a,null,{shadow:!1})))continue;const s=m.dependencies[t.rel](r,t,e,n,a);if(s){const t=r.$_createError(s.code,e,s.context,n,a);if(a.abortEarly)return{value:e,errors:t};i.push(t)}}return{value:e,errors:i}},rules:{and:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return l.verifyFlat(t,\"and\"),m.dependency(this,\"and\",null,t)}},append:{method(e){return null==e||0===Object.keys(e).length?this:this.keys(e)}},assert:{method(e,t,r){h.isTemplate(e)||(e=c.ref(e)),n(void 0===r||\"string\"==typeof r,\"Message must be a string\"),t=this.$_compile(t,{appendPath:!0});const s=this.$_addRule({name:\"assert\",args:{subject:e,schema:t,message:r}});return s.$_mutateRegister(e),s.$_mutateRegister(t),s},validate(e,t,r){let{error:s,prefs:n,state:a}=t,{subject:i,schema:o,message:l}=r;const c=i.resolve(e,a,n),u=f.isRef(i)?i.absolute(a):[];return o.$_match(c,a.localize(u,[e,...a.ancestors],o),n)?e:s(\"object.assert\",{subject:i,message:l})},args:[\"subject\",\"schema\",\"message\"],multi:!0},instance:{method(e,t){return n(\"function\"==typeof e,\"constructor must be a function\"),t=t||e.name,this.$_addRule({name:\"instance\",args:{constructor:e,name:t}})},validate(e,t,r){let{constructor:s,name:n}=r;return e instanceof s?e:t.error(\"object.instance\",{type:n,value:e})},args:[\"constructor\",\"name\"]},keys:{method(e){n(void 0===e||\"object\"==typeof e,\"Object schema must be a valid object\"),n(!l.isSchema(e),\"Object schema cannot be a joi schema\");const t=this.clone();if(e)if(Object.keys(e).length){t.$_terms.keys=t.$_terms.keys?t.$_terms.keys.filter((t=>!e.hasOwnProperty(t.key))):new m.Keys;for(const r in e)l.tryWithPath((()=>t.$_terms.keys.push({key:r,schema:this.$_compile(e[r])})),r)}else t.$_terms.keys=new m.Keys;else t.$_terms.keys=null;return t.$_mutateRebuild()}},length:{method(e){return this.$_addRule({name:\"length\",args:{limit:e},operator:\"=\"})},validate(e,t,r,s){let{limit:n}=r,{name:a,operator:i,args:o}=s;return l.compare(Object.keys(e).length,n,i)?e:t.error(\"object.\"+a,{limit:o.limit,value:e})},args:[{name:\"limit\",ref:!0,assert:l.limit,message:\"must be a positive integer\"}]},max:{method(e){return this.$_addRule({name:\"max\",method:\"length\",args:{limit:e},operator:\"<=\"})}},min:{method(e){return this.$_addRule({name:\"min\",method:\"length\",args:{limit:e},operator:\">=\"})}},nand:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return l.verifyFlat(t,\"nand\"),m.dependency(this,\"nand\",null,t)}},or:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return l.verifyFlat(t,\"or\"),m.dependency(this,\"or\",null,t)}},oxor:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return m.dependency(this,\"oxor\",null,t)}},pattern:{method(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=e instanceof RegExp;s||(e=this.$_compile(e,{appendPath:!0})),n(void 0!==t,\"Invalid rule\"),l.assertOptions(r,[\"fallthrough\",\"matches\"]),s&&n(!e.flags.includes(\"g\")&&!e.flags.includes(\"y\"),\"pattern should not use global or sticky mode\"),t=this.$_compile(t,{appendPath:!0});const a=this.clone();a.$_terms.patterns=a.$_terms.patterns||[];const i={[s?\"regex\":\"schema\"]:e,rule:t};return r.matches&&(i.matches=this.$_compile(r.matches),\"array\"!==i.matches.type&&(i.matches=i.matches.$_root.array().items(i.matches)),a.$_mutateRegister(i.matches),a.$_setFlag(\"_hasPatternMatch\",!0,{clone:!1})),r.fallthrough&&(i.fallthrough=!0),a.$_terms.patterns.push(i),a.$_mutateRegister(t),a}},ref:{method(){return this.$_addRule(\"ref\")},validate:(e,t)=>f.isRef(e)?e:t.error(\"object.refType\",{value:e})},regex:{method(){return this.$_addRule(\"regex\")},validate:(e,t)=>e instanceof RegExp?e:t.error(\"object.regex\",{value:e})},rename:{method(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n(\"string\"==typeof e||e instanceof RegExp,\"Rename missing the from argument\"),n(\"string\"==typeof t||t instanceof h,\"Invalid rename to argument\"),n(t!==e,\"Cannot rename key to same name:\",e),l.assertOptions(r,[\"alias\",\"ignoreUndefined\",\"override\",\"multiple\"]);const a=this.clone();a.$_terms.renames=a.$_terms.renames||[];for(const t of a.$_terms.renames)n(t.from!==e,\"Cannot rename the same key multiple times\");return t instanceof h&&a.$_mutateRegister(t),a.$_terms.renames.push({from:e,to:t,options:s(m.renameDefaults,r)}),a}},schema:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"any\";return this.$_addRule({name:\"schema\",args:{type:e}})},validate(e,t,r){let{type:s}=r;return!l.isSchema(e)||\"any\"!==s&&e.type!==s?t.error(\"object.schema\",{type:s}):e}},unknown:{method(e){return this.$_setFlag(\"unknown\",!1!==e)}},with:{method(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return m.dependency(this,\"with\",e,t,r)}},without:{method(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return m.dependency(this,\"without\",e,t,r)}},xor:{method(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];return l.verifyFlat(t,\"xor\"),m.dependency(this,\"xor\",null,t)}}},overrides:{default(e,t){return void 0===e&&(e=l.symbols.deepDefault),this.$_parent(\"default\",e,t)}},rebuild(e){if(e.$_terms.keys){const t=new i.Sorter;for(const r of e.$_terms.keys)l.tryWithPath((()=>t.add(r,{after:r.schema.$_rootReferences(),group:r.key})),r.key);e.$_terms.keys=new m.Keys(...t.nodes)}},manifest:{build(e,t){if(t.keys&&(e=e.keys(t.keys)),t.dependencies)for(const{rel:r,key:s=null,peers:n,options:a}of t.dependencies)e=m.dependency(e,r,s,n,a);if(t.patterns)for(const{regex:r,schema:s,rule:n,fallthrough:a,matches:i}of t.patterns)e=e.pattern(r||s,n,{fallthrough:a,matches:i});if(t.renames)for(const{from:r,to:s,options:n}of t.renames)e=e.rename(r,s,n);return e}},messages:{\"object.and\":\"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}\",\"object.assert\":'{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\"object.base\":\"{{#label}} must be of type {{#type}}\",\"object.instance\":\"{{#label}} must be an instance of {{:#type}}\",\"object.length\":'{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\"object.max\":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\"object.min\":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\"object.missing\":\"{{#label}} must contain at least one of {{#peersWithLabels}}\",\"object.nand\":\"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}\",\"object.oxor\":\"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}\",\"object.pattern.match\":\"{{#label}} keys failed to match pattern requirements\",\"object.refType\":\"{{#label}} must be a Joi reference\",\"object.regex\":\"{{#label}} must be a RegExp object\",\"object.rename.multiple\":\"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}\",\"object.rename.override\":\"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists\",\"object.schema\":\"{{#label}} must be a Joi schema of {{#type}} type\",\"object.unknown\":\"{{#label}} is not allowed\",\"object.with\":\"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}\",\"object.without\":\"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}\",\"object.xor\":\"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}\"}}),m.clone=function(e,t){if(\"object\"==typeof e){if(t.nonEnumerables)return a(e,{shallow:!0});const r=Object.create(Object.getPrototypeOf(e));return Object.assign(r,e),r}const r=function(){for(var t=arguments.length,r=new Array(t),s=0;s<t;s++)r[s]=arguments[s];return e.apply(this,r)};return r.prototype=a(e.prototype),Object.defineProperty(r,\"name\",{value:e.name,writable:!1}),Object.defineProperty(r,\"length\",{value:e.length,writable:!1}),Object.assign(r,e),r},m.dependency=function(e,t,r,s,a){n(null===r||\"string\"==typeof r,t,\"key must be a strings\"),a||(a=s.length>1&&\"object\"==typeof s[s.length-1]?s.pop():{}),l.assertOptions(a,[\"separator\",\"isPresent\"]),s=[].concat(s);const i=l.default(a.separator,\".\"),o=[];for(const e of s)n(\"string\"==typeof e,t,\"peers must be strings\"),o.push(c.ref(e,{separator:i,ancestor:0,prefix:!1}));null!==r&&(r=c.ref(r,{separator:i,ancestor:0,prefix:!1}));const u=e.clone();return u.$_terms.dependencies=u.$_terms.dependencies||[],u.$_terms.dependencies.push(new m.Dependency(t,r,o,s,a)),u},m.dependencies={and(e,t,r,s,n){const a=[],i=[],o=t.peers.length,l=m.isPresent(t.options);for(const e of t.peers)!1===l(e.resolve(r,s,n,null,{shadow:!1}))?a.push(e.key):i.push(e.key);if(a.length!==o&&i.length!==o)return{code:\"object.and\",context:{present:i,presentWithLabels:m.keysToLabels(e,i),missing:a,missingWithLabels:m.keysToLabels(e,a)}}},nand(e,t,r,s,n){const a=[],i=m.isPresent(t.options);for(const e of t.peers)i(e.resolve(r,s,n,null,{shadow:!1}))&&a.push(e.key);if(a.length!==t.peers.length)return;const o=t.paths[0],l=t.paths.slice(1);return{code:\"object.nand\",context:{main:o,mainWithLabel:m.keysToLabels(e,o),peers:l,peersWithLabels:m.keysToLabels(e,l)}}},or(e,t,r,s,n){const a=m.isPresent(t.options);for(const e of t.peers)if(a(e.resolve(r,s,n,null,{shadow:!1})))return;return{code:\"object.missing\",context:{peers:t.paths,peersWithLabels:m.keysToLabels(e,t.paths)}}},oxor(e,t,r,s,n){const a=[],i=m.isPresent(t.options);for(const e of t.peers)i(e.resolve(r,s,n,null,{shadow:!1}))&&a.push(e.key);if(!a.length||1===a.length)return;const o={peers:t.paths,peersWithLabels:m.keysToLabels(e,t.paths)};return o.present=a,o.presentWithLabels=m.keysToLabels(e,a),{code:\"object.oxor\",context:o}},with(e,t,r,s,n){const a=m.isPresent(t.options);for(const i of t.peers)if(!1===a(i.resolve(r,s,n,null,{shadow:!1})))return{code:\"object.with\",context:{main:t.key.key,mainWithLabel:m.keysToLabels(e,t.key.key),peer:i.key,peerWithLabel:m.keysToLabels(e,i.key)}}},without(e,t,r,s,n){const a=m.isPresent(t.options);for(const i of t.peers)if(a(i.resolve(r,s,n,null,{shadow:!1})))return{code:\"object.without\",context:{main:t.key.key,mainWithLabel:m.keysToLabels(e,t.key.key),peer:i.key,peerWithLabel:m.keysToLabels(e,i.key)}}},xor(e,t,r,s,n){const a=[],i=m.isPresent(t.options);for(const e of t.peers)i(e.resolve(r,s,n,null,{shadow:!1}))&&a.push(e.key);if(1===a.length)return;const o={peers:t.paths,peersWithLabels:m.keysToLabels(e,t.paths)};return 0===a.length?{code:\"object.missing\",context:o}:(o.present=a,o.presentWithLabels=m.keysToLabels(e,a),{code:\"object.xor\",context:o})}},m.keysToLabels=function(e,t){return Array.isArray(t)?t.map((t=>e.$_mapLabels(t))):e.$_mapLabels(t)},m.isPresent=function(e){return\"function\"==typeof e.isPresent?e.isPresent:e=>void 0!==e},m.rename=function(e,t,r,s,n){const a={};for(const i of e.$_terms.renames){const o=[],l=\"string\"!=typeof i.from;if(l)for(const e in t){if(void 0===t[e]&&i.options.ignoreUndefined)continue;if(e===i.to)continue;const r=i.from.exec(e);r&&o.push({from:e,to:i.to,match:r})}else!Object.prototype.hasOwnProperty.call(t,i.from)||void 0===t[i.from]&&i.options.ignoreUndefined||o.push(i);for(const c of o){const o=c.from;let u=c.to;if(u instanceof h&&(u=u.render(t,r,s,c.match)),o!==u){if(!i.options.multiple&&a[u]&&(n.push(e.$_createError(\"object.rename.multiple\",t,{from:o,to:u,pattern:l},r,s)),s.abortEarly))return!1;if(Object.prototype.hasOwnProperty.call(t,u)&&!i.options.override&&!a[u]&&(n.push(e.$_createError(\"object.rename.override\",t,{from:o,to:u,pattern:l},r,s)),s.abortEarly))return!1;void 0===t[o]?delete t[u]:t[u]=t[o],a[u]=!0,i.options.alias||delete t[o]}}}return!0},m.unknown=function(e,t,r,s,n,a){if(e.$_terms.patterns){let i=!1;const o=e.$_terms.patterns.map((e=>{if(e.matches)return i=!0,[]})),l=[t,...n.ancestors];for(const i of r){const c=t[i],u=[...n.path,i];for(let f=0;f<e.$_terms.patterns.length;++f){const h=e.$_terms.patterns[f];if(h.regex){const e=h.regex.test(i);if(n.mainstay.tracer.debug(n,\"rule\",`pattern.${f}`,e?\"pass\":\"error\"),!e)continue}else if(!h.schema.$_match(i,n.nest(h.schema,`pattern.${f}`),a))continue;r.delete(i);const m=n.localize(u,l,{schema:h.rule,key:i}),d=h.rule.$_validate(c,m,a);if(d.errors){if(a.abortEarly)return{value:t,errors:d.errors};s.push(...d.errors)}if(h.matches&&o[f].push(i),t[i]=d.value,!h.fallthrough)break}}if(i)for(let r=0;r<o.length;++r){const i=o[r];if(!i)continue;const c=e.$_terms.patterns[r].matches,f=n.localize(n.path,l,c),h=c.$_validate(i,f,a);if(h.errors){const r=u.details(h.errors,{override:!1});r.matches=i;const o=e.$_createError(\"object.pattern.match\",t,r,n,a);if(a.abortEarly)return{value:t,errors:o};s.push(o)}}}if(r.size&&(e.$_terms.keys||e.$_terms.patterns)){if(a.stripUnknown&&!e._flags.unknown||a.skipFunctions){const e=!(!a.stripUnknown||!0!==a.stripUnknown&&!a.stripUnknown.objects);for(const s of r)e?(delete t[s],r.delete(s)):\"function\"==typeof t[s]&&r.delete(s)}if(!l.default(e._flags.unknown,a.allowUnknown))for(const i of r){const r=n.localize([...n.path,i],[]),o=e.$_createError(\"object.unknown\",t[i],{child:i},r,a,{flags:!1});if(a.abortEarly)return{value:t,errors:o};s.push(o)}}},m.Dependency=class{constructor(e,t,r,s,n){this.rel=e,this.key=t,this.peers=r,this.paths=s,this.options=n}describe(){const e={rel:this.rel,peers:this.paths};return null!==this.key&&(e.key=this.key.key),\".\"!==this.peers[0].separator&&(e.options={...e.options,separator:this.peers[0].separator}),this.options.isPresent&&(e.options={...e.options,isPresent:this.options.isPresent}),e}},m.Keys=class extends Array{concat(e){const t=this.slice(),r=new Map;for(let e=0;e<t.length;++e)r.set(t[e].key,e);for(const s of e){const e=s.key,n=r.get(e);void 0!==n?t[n]={key:e,schema:t[n].schema.concat(s.schema)}:t.push(s)}return t}}},8785:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8068),a=r(8160),i=r(3292),o=r(6354),l={};e.exports=n.extend({type:\"link\",properties:{schemaChain:!0},terms:{link:{init:null,manifest:\"single\",register:!1}},args:(e,t)=>e.ref(t),validate(e,t){let{schema:r,state:n,prefs:a}=t;s(r.$_terms.link,\"Uninitialized link schema\");const i=l.generate(r,e,n,a),o=r.$_terms.link[0].ref;return i.$_validate(e,n.nest(i,`link:${o.display}:${i.type}`),a)},generate:(e,t,r,s)=>l.generate(e,t,r,s),rules:{ref:{method(e){s(!this.$_terms.link,\"Cannot reinitialize schema\"),e=i.ref(e),s(\"value\"===e.type||\"local\"===e.type,\"Invalid reference type:\",e.type),s(\"local\"===e.type||\"root\"===e.ancestor||e.ancestor>0,\"Link cannot reference itself\");const t=this.clone();return t.$_terms.link=[{ref:e}],t}},relative:{method(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.$_setFlag(\"relative\",e)}}},overrides:{concat(e){s(this.$_terms.link,\"Uninitialized link schema\"),s(a.isSchema(e),\"Invalid schema object\"),s(\"link\"!==e.type,\"Cannot merge type link with another link\");const t=this.clone();return t.$_terms.whens||(t.$_terms.whens=[]),t.$_terms.whens.push({concat:e}),t.$_mutateRebuild()}},manifest:{build:(e,t)=>(s(t.link,\"Invalid link description missing link\"),e.ref(t.link))}}),l.generate=function(e,t,r,s){let n=r.mainstay.links.get(e);if(n)return n._generate(t,r,s).schema;const a=e.$_terms.link[0].ref,{perspective:i,path:o}=l.perspective(a,r);l.assert(i,\"which is outside of schema boundaries\",a,e,r,s);try{n=o.length?i.$_reach(o):i}catch(t){l.assert(!1,\"to non-existing schema\",a,e,r,s)}return l.assert(\"link\"!==n.type,\"which is another link\",a,e,r,s),e._flags.relative||r.mainstay.links.set(e,n),n._generate(t,r,s).schema},l.perspective=function(e,t){if(\"local\"===e.type){for(const{schema:r,key:s}of t.schemas){if((r._flags.id||s)===e.path[0])return{perspective:r,path:e.path.slice(1)};if(r.$_terms.shared)for(const t of r.$_terms.shared)if(t._flags.id===e.path[0])return{perspective:t,path:e.path.slice(1)}}return{perspective:null,path:null}}return\"root\"===e.ancestor?{perspective:t.schemas[t.schemas.length-1].schema,path:e.path}:{perspective:t.schemas[e.ancestor]&&t.schemas[e.ancestor].schema,path:e.path}},l.assert=function(e,t,r,n,a,i){e||s(!1,`\"${o.label(n._flags,a,i)}\" contains link reference \"${r.display}\" ${t}`)}},3832:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8068),a=r(8160),i={numberRx:/^\\s*[+-]?(?:(?:\\d+(?:\\.\\d*)?)|(?:\\.\\d+))(?:e([+-]?\\d+))?\\s*$/i,precisionRx:/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/,exponentialPartRegex:/[eE][+-]?\\d+$/,leadingSignAndZerosRegex:/^[+-]?(0*)?/,dotRegex:/\\./,trailingZerosRegex:/0+$/};e.exports=n.extend({type:\"number\",flags:{unsafe:{default:!1}},coerce:{from:\"string\",method(e,t){let{schema:r,error:s}=t;if(!e.match(i.numberRx))return;e=e.trim();const n={value:parseFloat(e)};if(0===n.value&&(n.value=0),!r._flags.unsafe)if(e.match(/e/i)){if(i.extractSignificantDigits(e)!==i.extractSignificantDigits(String(n.value)))return n.errors=s(\"number.unsafe\"),n}else{const t=n.value.toString();if(t.match(/e/i))return n;if(t!==i.normalizeDecimal(e))return n.errors=s(\"number.unsafe\"),n}return n}},validate(e,t){let{schema:r,error:s,prefs:n}=t;if(e===1/0||e===-1/0)return{value:e,errors:s(\"number.infinity\")};if(!a.isNumber(e))return{value:e,errors:s(\"number.base\")};const i={value:e};if(n.convert){const e=r.$_getRule(\"precision\");if(e){const t=Math.pow(10,e.args.limit);i.value=Math.round(i.value*t)/t}}return 0===i.value&&(i.value=0),!r._flags.unsafe&&(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)&&(i.errors=s(\"number.unsafe\")),i},rules:{compare:{method:!1,validate(e,t,r,s){let{limit:n}=r,{name:i,operator:o,args:l}=s;return a.compare(e,n,o)?e:t.error(\"number.\"+i,{limit:l.limit,value:e})},args:[{name:\"limit\",ref:!0,assert:a.isNumber,message:\"must be a number\"}]},greater:{method(e){return this.$_addRule({name:\"greater\",method:\"compare\",args:{limit:e},operator:\">\"})}},integer:{method(){return this.$_addRule(\"integer\")},validate:(e,t)=>Math.trunc(e)-e==0?e:t.error(\"number.integer\")},less:{method(e){return this.$_addRule({name:\"less\",method:\"compare\",args:{limit:e},operator:\"<\"})}},max:{method(e){return this.$_addRule({name:\"max\",method:\"compare\",args:{limit:e},operator:\"<=\"})}},min:{method(e){return this.$_addRule({name:\"min\",method:\"compare\",args:{limit:e},operator:\">=\"})}},multiple:{method(e){return this.$_addRule({name:\"multiple\",args:{base:e}})},validate(e,t,r,s){let{base:n}=r;return e*(1/n)%1==0?e:t.error(\"number.multiple\",{multiple:s.args.base,value:e})},args:[{name:\"base\",ref:!0,assert:e=>\"number\"==typeof e&&isFinite(e)&&e>0,message:\"must be a positive number\"}],multi:!0},negative:{method(){return this.sign(\"negative\")}},port:{method(){return this.$_addRule(\"port\")},validate:(e,t)=>Number.isSafeInteger(e)&&e>=0&&e<=65535?e:t.error(\"number.port\")},positive:{method(){return this.sign(\"positive\")}},precision:{method(e){return s(Number.isSafeInteger(e),\"limit must be an integer\"),this.$_addRule({name:\"precision\",args:{limit:e}})},validate(e,t,r){let{limit:s}=r;const n=e.toString().match(i.precisionRx);return Math.max((n[1]?n[1].length:0)-(n[2]?parseInt(n[2],10):0),0)<=s?e:t.error(\"number.precision\",{limit:s,value:e})},convert:!0},sign:{method(e){return s([\"negative\",\"positive\"].includes(e),\"Invalid sign\",e),this.$_addRule({name:\"sign\",args:{sign:e}})},validate(e,t,r){let{sign:s}=r;return\"negative\"===s&&e<0||\"positive\"===s&&e>0?e:t.error(`number.${s}`)}},unsafe:{method(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return s(\"boolean\"==typeof e,\"enabled must be a boolean\"),this.$_setFlag(\"unsafe\",e)}}},cast:{string:{from:e=>\"number\"==typeof e,to:(e,t)=>e.toString()}},messages:{\"number.base\":\"{{#label}} must be a number\",\"number.greater\":\"{{#label}} must be greater than {{#limit}}\",\"number.infinity\":\"{{#label}} cannot be infinity\",\"number.integer\":\"{{#label}} must be an integer\",\"number.less\":\"{{#label}} must be less than {{#limit}}\",\"number.max\":\"{{#label}} must be less than or equal to {{#limit}}\",\"number.min\":\"{{#label}} must be greater than or equal to {{#limit}}\",\"number.multiple\":\"{{#label}} must be a multiple of {{#multiple}}\",\"number.negative\":\"{{#label}} must be a negative number\",\"number.port\":\"{{#label}} must be a valid port\",\"number.positive\":\"{{#label}} must be a positive number\",\"number.precision\":\"{{#label}} must have no more than {{#limit}} decimal places\",\"number.unsafe\":\"{{#label}} must be a safe number\"}}),i.extractSignificantDigits=function(e){return e.replace(i.exponentialPartRegex,\"\").replace(i.dotRegex,\"\").replace(i.trailingZerosRegex,\"\").replace(i.leadingSignAndZerosRegex,\"\")},i.normalizeDecimal=function(e){return(e=e.replace(/^\\+/,\"\").replace(/\\.0*$/,\"\").replace(/^(-?)\\.([^\\.]*)$/,\"$10.$2\").replace(/^(-?)0+([0-9])/,\"$1$2\")).includes(\".\")&&e.endsWith(\"0\")&&(e=e.replace(/0+$/,\"\")),\"-0\"===e?\"0\":e}},8966:(e,t,r)=>{\"use strict\";const s=r(7824);e.exports=s.extend({type:\"object\",cast:{map:{from:e=>e&&\"object\"==typeof e,to:(e,t)=>new Map(Object.entries(e))}}})},7417:(e,t,r)=>{\"use strict\";const s=r(375),n=r(5380),a=r(1745),i=r(9959),o=r(6064),l=r(9926),c=r(5752),u=r(8068),f=r(8160),h={tlds:l instanceof Set&&{tlds:{allow:l,deny:null}},base64Regex:{true:{true:/^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/},false:{true:/^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/}},dataUriRegex:/^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,hexRegex:/^[a-f0-9]+$/i,ipRegex:i.regex({cidr:\"forbidden\"}).regex,isoDurationRegex:/^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,guidBrackets:{\"{\":\"}\",\"[\":\"]\",\"(\":\")\",\"\":\"\"},guidVersions:{uuidv1:\"1\",uuidv2:\"2\",uuidv3:\"3\",uuidv4:\"4\",uuidv5:\"5\",uuidv6:\"6\",uuidv7:\"7\",uuidv8:\"8\"},guidSeparators:new Set([void 0,!0,!1,\"-\",\":\"]),normalizationForms:[\"NFC\",\"NFD\",\"NFKC\",\"NFKD\"]};e.exports=u.extend({type:\"string\",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:\"string\",method(e,t){let{schema:r,state:s,prefs:n}=t;const a=r.$_getRule(\"normalize\");a&&(e=e.normalize(a.args.form));const i=r.$_getRule(\"case\");i&&(e=\"upper\"===i.args.direction?e.toLocaleUpperCase():e.toLocaleLowerCase());const o=r.$_getRule(\"trim\");if(o&&o.args.enabled&&(e=e.trim()),r.$_terms.replacements)for(const t of r.$_terms.replacements)e=e.replace(t.pattern,t.replacement);const l=r.$_getRule(\"hex\");if(l&&l.args.options.byteAligned&&e.length%2!=0&&(e=`0${e}`),r.$_getRule(\"isoDate\")){const t=h.isoDate(e);t&&(e=t)}if(r._flags.truncate){const t=r.$_getRule(\"max\");if(t){let a=t.args.limit;if(f.isResolvable(a)&&(a=a.resolve(e,s,n),!f.limit(a)))return{value:e,errors:r.$_createError(\"any.ref\",a,{ref:t.args.limit,arg:\"limit\",reason:\"must be a positive integer\"},s,n)};e=e.slice(0,a)}}return{value:e}}},validate(e,t){let{schema:r,error:s}=t;if(\"string\"!=typeof e)return{value:e,errors:s(\"string.base\")};if(\"\"===e){const t=r.$_getRule(\"min\");if(t&&0===t.args.limit)return;return{value:e,errors:s(\"string.empty\")}}},rules:{alphanum:{method(){return this.$_addRule(\"alphanum\")},validate:(e,t)=>/^[a-zA-Z0-9]+$/.test(e)?e:t.error(\"string.alphanum\")},base64:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return f.assertOptions(e,[\"paddingRequired\",\"urlSafe\"]),e={urlSafe:!1,paddingRequired:!0,...e},s(\"boolean\"==typeof e.paddingRequired,\"paddingRequired must be boolean\"),s(\"boolean\"==typeof e.urlSafe,\"urlSafe must be boolean\"),this.$_addRule({name:\"base64\",args:{options:e}})},validate(e,t,r){let{options:s}=r;return h.base64Regex[s.paddingRequired][s.urlSafe].test(e)?e:t.error(\"string.base64\")}},case:{method(e){return s([\"lower\",\"upper\"].includes(e),\"Invalid case:\",e),this.$_addRule({name:\"case\",args:{direction:e}})},validate(e,t,r){let{direction:s}=r;return\"lower\"===s&&e===e.toLocaleLowerCase()||\"upper\"===s&&e===e.toLocaleUpperCase()?e:t.error(`string.${s}case`)},convert:!0},creditCard:{method(){return this.$_addRule(\"creditCard\")},validate(e,t){let r=e.length,s=0,n=1;for(;r--;){const t=e.charAt(r)*n;s+=t-9*(t>9),n^=3}return s>0&&s%10==0?e:t.error(\"string.creditCard\")}},dataUri:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return f.assertOptions(e,[\"paddingRequired\"]),e={paddingRequired:!0,...e},s(\"boolean\"==typeof e.paddingRequired,\"paddingRequired must be boolean\"),this.$_addRule({name:\"dataUri\",args:{options:e}})},validate(e,t,r){let{options:s}=r;const n=e.match(h.dataUriRegex);if(n){if(!n[2])return e;if(\"base64\"!==n[2])return e;if(h.base64Regex[s.paddingRequired].false.test(n[3]))return e}return t.error(\"string.dataUri\")}},domain:{method(e){e&&f.assertOptions(e,[\"allowFullyQualified\",\"allowUnicode\",\"maxDomainSegments\",\"minDomainSegments\",\"tlds\"]);const t=h.addressOptions(e);return this.$_addRule({name:\"domain\",args:{options:e},address:t})},validate(e,t,r,s){let{address:a}=s;return n.isValid(e,a)?e:t.error(\"string.domain\")}},email:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};f.assertOptions(e,[\"allowFullyQualified\",\"allowUnicode\",\"ignoreLength\",\"maxDomainSegments\",\"minDomainSegments\",\"multiple\",\"separator\",\"tlds\"]),s(void 0===e.multiple||\"boolean\"==typeof e.multiple,\"multiple option must be an boolean\");const t=h.addressOptions(e),r=new RegExp(`\\\\s*[${e.separator?o(e.separator):\",\"}]\\\\s*`);return this.$_addRule({name:\"email\",args:{options:e},regex:r,address:t})},validate(e,t,r,s){let{options:n}=r,{regex:i,address:o}=s;const l=n.multiple?e.split(i):[e],c=[];for(const e of l)a.isValid(e,o)||c.push(e);return c.length?t.error(\"string.email\",{value:e,invalids:c}):e}},guid:{alias:\"uuid\",method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};f.assertOptions(e,[\"version\",\"separator\"]);let t=\"\";if(e.version){const r=[].concat(e.version);s(r.length>=1,\"version must have at least 1 valid version specified\");const n=new Set;for(let e=0;e<r.length;++e){const a=r[e];s(\"string\"==typeof a,\"version at position \"+e+\" must be a string\");const i=h.guidVersions[a.toLowerCase()];s(i,\"version at position \"+e+\" must be one of \"+Object.keys(h.guidVersions).join(\", \")),s(!n.has(i),\"version at position \"+e+\" must not be a duplicate\"),t+=i,n.add(i)}}s(h.guidSeparators.has(e.separator),'separator must be one of true, false, \"-\", or \":\"');const r=void 0===e.separator?\"[:-]?\":!0===e.separator?\"[:-]\":!1===e.separator?\"[]?\":`\\\\${e.separator}`,n=new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}(${r})[0-9A-F]{4}\\\\2?[${t||\"0-9A-F\"}][0-9A-F]{3}\\\\2?[${t?\"89AB\":\"0-9A-F\"}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`,\"i\");return this.$_addRule({name:\"guid\",args:{options:e},regex:n})},validate(e,t,r,s){let{regex:n}=s;const a=n.exec(e);return a?h.guidBrackets[a[1]]!==a[a.length-1]?t.error(\"string.guid\"):e:t.error(\"string.guid\")}},hex:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return f.assertOptions(e,[\"byteAligned\"]),e={byteAligned:!1,...e},s(\"boolean\"==typeof e.byteAligned,\"byteAligned must be boolean\"),this.$_addRule({name:\"hex\",args:{options:e}})},validate(e,t,r){let{options:s}=r;return h.hexRegex.test(e)?s.byteAligned&&e.length%2!=0?t.error(\"string.hexAlign\"):e:t.error(\"string.hex\")}},hostname:{method(){return this.$_addRule(\"hostname\")},validate:(e,t)=>n.isValid(e,{minDomainSegments:1})||h.ipRegex.test(e)?e:t.error(\"string.hostname\")},insensitive:{method(){return this.$_setFlag(\"insensitive\",!0)}},ip:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};f.assertOptions(e,[\"cidr\",\"version\"]);const{cidr:t,versions:r,regex:s}=i.regex(e),n=e.version?r:void 0;return this.$_addRule({name:\"ip\",args:{options:{cidr:t,version:n}},regex:s})},validate(e,t,r,s){let{options:n}=r,{regex:a}=s;return a.test(e)?e:n.version?t.error(\"string.ipVersion\",{value:e,cidr:n.cidr,version:n.version}):t.error(\"string.ip\",{value:e,cidr:n.cidr})}},isoDate:{method(){return this.$_addRule(\"isoDate\")},validate(e,t){let{error:r}=t;return h.isoDate(e)?e:r(\"string.isoDate\")}},isoDuration:{method(){return this.$_addRule(\"isoDuration\")},validate:(e,t)=>h.isoDurationRegex.test(e)?e:t.error(\"string.isoDuration\")},length:{method(e,t){return h.length(this,\"length\",e,\"=\",t)},validate(e,t,r,s){let{limit:n,encoding:a}=r,{name:i,operator:o,args:l}=s;const c=!a&&e.length;return f.compare(c,n,o)?e:t.error(\"string.\"+i,{limit:l.limit,value:e,encoding:a})},args:[{name:\"limit\",ref:!0,assert:f.limit,message:\"must be a positive integer\"},\"encoding\"]},lowercase:{method(){return this.case(\"lower\")}},max:{method(e,t){return h.length(this,\"max\",e,\"<=\",t)},args:[\"limit\",\"encoding\"]},min:{method(e,t){return h.length(this,\"min\",e,\">=\",t)},args:[\"limit\",\"encoding\"]},normalize:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"NFC\";return s(h.normalizationForms.includes(e),\"normalization form must be one of \"+h.normalizationForms.join(\", \")),this.$_addRule({name:\"normalize\",args:{form:e}})},validate(e,t,r){let{error:s}=t,{form:n}=r;return e===e.normalize(n)?e:s(\"string.normalize\",{value:e,form:n})},convert:!0},pattern:{alias:\"regex\",method(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};s(e instanceof RegExp,\"regex must be a RegExp\"),s(!e.flags.includes(\"g\")&&!e.flags.includes(\"y\"),\"regex should not use global or sticky mode\"),\"string\"==typeof t&&(t={name:t}),f.assertOptions(t,[\"invert\",\"name\"]);const r=[\"string.pattern\",t.invert?\".invert\":\"\",t.name?\".name\":\".base\"].join(\"\");return this.$_addRule({name:\"pattern\",args:{regex:e,options:t},errorCode:r})},validate(e,t,r,s){let{regex:n,options:a}=r,{errorCode:i}=s;return n.test(e)^a.invert?e:t.error(i,{name:a.name,regex:n,value:e})},args:[\"regex\",\"options\"],multi:!0},replace:{method(e,t){\"string\"==typeof e&&(e=new RegExp(o(e),\"g\")),s(e instanceof RegExp,\"pattern must be a RegExp\"),s(\"string\"==typeof t,\"replacement must be a String\");const r=this.clone();return r.$_terms.replacements||(r.$_terms.replacements=[]),r.$_terms.replacements.push({pattern:e,replacement:t}),r}},token:{method(){return this.$_addRule(\"token\")},validate:(e,t)=>/^\\w+$/.test(e)?e:t.error(\"string.token\")},trim:{method(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return s(\"boolean\"==typeof e,\"enabled must be a boolean\"),this.$_addRule({name:\"trim\",args:{enabled:e}})},validate(e,t,r){let{enabled:s}=r;return s&&e!==e.trim()?t.error(\"string.trim\"):e},convert:!0},truncate:{method(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return s(\"boolean\"==typeof e,\"enabled must be a boolean\"),this.$_setFlag(\"truncate\",e)}},uppercase:{method(){return this.case(\"upper\")}},uri:{method(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};f.assertOptions(e,[\"allowRelative\",\"allowQuerySquareBrackets\",\"domain\",\"relativeOnly\",\"scheme\"]),e.domain&&f.assertOptions(e.domain,[\"allowFullyQualified\",\"allowUnicode\",\"maxDomainSegments\",\"minDomainSegments\",\"tlds\"]);const{regex:t,scheme:r}=c.regex(e),s=e.domain?h.addressOptions(e.domain):null;return this.$_addRule({name:\"uri\",args:{options:e},regex:t,domain:s,scheme:r})},validate(e,t,r,s){let{options:a}=r,{regex:i,domain:o,scheme:l}=s;if([\"http:/\",\"https:/\"].includes(e))return t.error(\"string.uri\");const c=i.exec(e);if(c){const r=c[1]||c[2];return!o||a.allowRelative&&!r||n.isValid(r,o)?e:t.error(\"string.domain\",{value:r})}return a.relativeOnly?t.error(\"string.uriRelativeOnly\"):a.scheme?t.error(\"string.uriCustomScheme\",{scheme:l,value:e}):t.error(\"string.uri\")}}},manifest:{build(e,t){if(t.replacements)for(const{pattern:r,replacement:s}of t.replacements)e=e.replace(r,s);return e}},messages:{\"string.alphanum\":\"{{#label}} must only contain alpha-numeric characters\",\"string.base\":\"{{#label}} must be a string\",\"string.base64\":\"{{#label}} must be a valid base64 string\",\"string.creditCard\":\"{{#label}} must be a credit card\",\"string.dataUri\":\"{{#label}} must be a valid dataUri string\",\"string.domain\":\"{{#label}} must contain a valid domain name\",\"string.email\":\"{{#label}} must be a valid email\",\"string.empty\":\"{{#label}} is not allowed to be empty\",\"string.guid\":\"{{#label}} must be a valid GUID\",\"string.hex\":\"{{#label}} must only contain hexadecimal characters\",\"string.hexAlign\":\"{{#label}} hex decoded representation must be byte aligned\",\"string.hostname\":\"{{#label}} must be a valid hostname\",\"string.ip\":\"{{#label}} must be a valid ip address with a {{#cidr}} CIDR\",\"string.ipVersion\":\"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR\",\"string.isoDate\":\"{{#label}} must be in iso format\",\"string.isoDuration\":\"{{#label}} must be a valid ISO 8601 duration\",\"string.length\":\"{{#label}} length must be {{#limit}} characters long\",\"string.lowercase\":\"{{#label}} must only contain lowercase characters\",\"string.max\":\"{{#label}} length must be less than or equal to {{#limit}} characters long\",\"string.min\":\"{{#label}} length must be at least {{#limit}} characters long\",\"string.normalize\":\"{{#label}} must be unicode normalized in the {{#form}} form\",\"string.token\":\"{{#label}} must only contain alpha-numeric and underscore characters\",\"string.pattern.base\":\"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}\",\"string.pattern.name\":\"{{#label}} with value {:[.]} fails to match the {{#name}} pattern\",\"string.pattern.invert.base\":\"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}\",\"string.pattern.invert.name\":\"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern\",\"string.trim\":\"{{#label}} must not have leading or trailing whitespace\",\"string.uri\":\"{{#label}} must be a valid uri\",\"string.uriCustomScheme\":\"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern\",\"string.uriRelativeOnly\":\"{{#label}} must be a valid relative uri\",\"string.uppercase\":\"{{#label}} must only contain uppercase characters\"}}),h.addressOptions=function(e){if(!e)return e;if(s(void 0===e.minDomainSegments||Number.isSafeInteger(e.minDomainSegments)&&e.minDomainSegments>0,\"minDomainSegments must be a positive integer\"),s(void 0===e.maxDomainSegments||Number.isSafeInteger(e.maxDomainSegments)&&e.maxDomainSegments>0,\"maxDomainSegments must be a positive integer\"),!1===e.tlds)return e;if(!0===e.tlds||void 0===e.tlds)return s(h.tlds,\"Built-in TLD list disabled\"),Object.assign({},e,h.tlds);s(\"object\"==typeof e.tlds,\"tlds must be true, false, or an object\");const t=e.tlds.deny;if(t)return Array.isArray(t)&&(e=Object.assign({},e,{tlds:{deny:new Set(t)}})),s(e.tlds.deny instanceof Set,\"tlds.deny must be an array, Set, or boolean\"),s(!e.tlds.allow,\"Cannot specify both tlds.allow and tlds.deny lists\"),h.validateTlds(e.tlds.deny,\"tlds.deny\"),e;const r=e.tlds.allow;return r?!0===r?(s(h.tlds,\"Built-in TLD list disabled\"),Object.assign({},e,h.tlds)):(Array.isArray(r)&&(e=Object.assign({},e,{tlds:{allow:new Set(r)}})),s(e.tlds.allow instanceof Set,\"tlds.allow must be an array, Set, or boolean\"),h.validateTlds(e.tlds.allow,\"tlds.allow\"),e):e},h.validateTlds=function(e,t){for(const r of e)s(n.isValid(r,{minDomainSegments:1,maxDomainSegments:1}),`${t} must contain valid top level domain names`)},h.isoDate=function(e){if(!f.isIsoDate(e))return null;/.*T.*[+-]\\d\\d$/.test(e)&&(e+=\"00\");const t=new Date(e);return isNaN(t.getTime())?null:t.toISOString()},h.length=function(e,t,r,n,a){return s(!a||!1,\"Invalid encoding:\",a),e.$_addRule({name:t,method:\"length\",args:{limit:r,encoding:a},operator:n})}},8826:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8068),a={};a.Map=class extends Map{slice(){return new a.Map(this)}},e.exports=n.extend({type:\"symbol\",terms:{map:{init:new a.Map}},coerce:{method(e,t){let{schema:r,error:s}=t;const n=r.$_terms.map.get(e);return n&&(e=n),r._flags.only&&\"symbol\"!=typeof e?{value:e,errors:s(\"symbol.map\",{map:r.$_terms.map})}:{value:e}}},validate(e,t){let{error:r}=t;if(\"symbol\"!=typeof e)return{value:e,errors:r(\"symbol.base\")}},rules:{map:{method(e){e&&!e[Symbol.iterator]&&\"object\"==typeof e&&(e=Object.entries(e)),s(e&&e[Symbol.iterator],\"Iterable must be an iterable or object\");const t=this.clone(),r=[];for(const n of e){s(n&&n[Symbol.iterator],\"Entry must be an iterable\");const[e,a]=n;s(\"object\"!=typeof e&&\"function\"!=typeof e&&\"symbol\"!=typeof e,\"Key must not be of type object, function, or Symbol\"),s(\"symbol\"==typeof a,\"Value must be a Symbol\"),t.$_terms.map.set(e,a),r.push(a)}return t.valid(...r)}}},manifest:{build:(e,t)=>(t.map&&(e=e.map(t.map)),e)},messages:{\"symbol.base\":\"{{#label}} must be a symbol\",\"symbol.map\":\"{{#label}} must be one of {{#map}}\"}})},8863:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(738),i=r(9621),o=r(8160),l=r(6354),c=r(493),u={result:Symbol(\"result\")};t.entry=function(e,t,r){let n=o.defaults;r&&(s(void 0===r.warnings,\"Cannot override warnings preference in synchronous validation\"),s(void 0===r.artifacts,\"Cannot override artifacts preference in synchronous validation\"),n=o.preferences(o.defaults,r));const a=u.entry(e,t,n);s(!a.mainstay.externals.length,\"Schema with external rules must use validateAsync()\");const i={value:a.value};return a.error&&(i.error=a.error),a.mainstay.warnings.length&&(i.warning=l.details(a.mainstay.warnings)),a.mainstay.debug&&(i.debug=a.mainstay.debug),a.mainstay.artifacts&&(i.artifacts=a.mainstay.artifacts),i},t.entryAsync=async function(e,t,r){let s=o.defaults;r&&(s=o.preferences(o.defaults,r));const n=u.entry(e,t,s),a=n.mainstay;if(n.error)throw a.debug&&(n.error.debug=a.debug),n.error;if(a.externals.length){let t=n.value;const c=[];for(const n of a.externals){const f=n.state.path,h=\"link\"===n.schema.type?a.links.get(n.schema):null;let m,d,p=t;const g=f.length?[t]:[],y=f.length?i(e,f):e;if(f.length){m=f[f.length-1];let e=t;for(const t of f.slice(0,-1))e=e[t],g.unshift(e);d=g[0],p=d[m]}try{const e=(e,t)=>(h||n.schema).$_createError(e,p,t,n.state,s),i=await n.method(p,{schema:n.schema,linked:h,state:n.state,prefs:r,original:y,error:e,errorsArray:u.errorsArray,warn:(e,t)=>a.warnings.push((h||n.schema).$_createError(e,p,t,n.state,s)),message:(e,t)=>(h||n.schema).$_createError(\"external\",p,t,n.state,s,{messages:e})});if(void 0===i||i===p)continue;if(i instanceof l.Report){if(a.tracer.log(n.schema,n.state,\"rule\",\"external\",\"error\"),c.push(i),s.abortEarly)break;continue}if(Array.isArray(i)&&i[o.symbols.errors]){if(a.tracer.log(n.schema,n.state,\"rule\",\"external\",\"error\"),c.push(...i),s.abortEarly)break;continue}d?(a.tracer.value(n.state,\"rule\",p,i,\"external\"),d[m]=i):(a.tracer.value(n.state,\"rule\",t,i,\"external\"),t=i)}catch(e){throw s.errors.label&&(e.message+=` (${n.label})`),e}}if(n.value=t,c.length)throw n.error=l.process(c,e,s),a.debug&&(n.error.debug=a.debug),n.error}if(!s.warnings&&!s.debug&&!s.artifacts)return n.value;const c={value:n.value};return a.warnings.length&&(c.warning=l.details(a.warnings)),a.debug&&(c.debug=a.debug),a.artifacts&&(c.artifacts=a.artifacts),c},u.Mainstay=class{constructor(e,t,r){this.externals=[],this.warnings=[],this.tracer=e,this.debug=t,this.links=r,this.shadow=null,this.artifacts=null,this._snapshots=[]}snapshot(){this._snapshots.push({externals:this.externals.slice(),warnings:this.warnings.slice()})}restore(){const e=this._snapshots.pop();this.externals=e.externals,this.warnings=e.warnings}commit(){this._snapshots.pop()}},u.entry=function(e,r,s){const{tracer:n,cleanup:a}=u.tracer(r,s),i=s.debug?[]:null,o=r._ids._schemaChain?new Map:null,f=new u.Mainstay(n,i,o),h=r._ids._schemaChain?[{schema:r}]:null,m=new c([],[],{mainstay:f,schemas:h}),d=t.validate(e,r,m,s);a&&r.$_root.untrace();const p=l.process(d.errors,e,s);return{value:d.value,error:p,mainstay:f}},u.tracer=function(e,t){return e.$_root._tracer?{tracer:e.$_root._tracer._register(e)}:t.debug?(s(e.$_root.trace,\"Debug mode not supported\"),{tracer:e.$_root.trace()._register(e),cleanup:!0}):{tracer:u.ignore}},t.validate=function(e,t,r,s){let n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};if(t.$_terms.whens&&(t=t._generate(e,r,s).schema),t._preferences&&(s=u.prefs(t,s)),t._cache&&s.cache){const s=t._cache.get(e);if(r.mainstay.tracer.debug(r,\"validate\",\"cached\",!!s),s)return s}const a=(n,a,i)=>t.$_createError(n,e,a,i||r,s),i={original:e,prefs:s,schema:t,state:r,error:a,errorsArray:u.errorsArray,warn:(e,t,s)=>r.mainstay.warnings.push(a(e,t,s)),message:(n,a)=>t.$_createError(\"custom\",e,a,r,s,{messages:n})};r.mainstay.tracer.entry(t,r);const l=t._definition;if(l.prepare&&void 0!==e&&s.convert){const t=l.prepare(e,i);if(t){if(r.mainstay.tracer.value(r,\"prepare\",e,t.value),t.errors)return u.finalize(t.value,[].concat(t.errors),i);e=t.value}}if(l.coerce&&void 0!==e&&s.convert&&(!l.coerce.from||l.coerce.from.includes(typeof e))){const t=l.coerce.method(e,i);if(t){if(r.mainstay.tracer.value(r,\"coerced\",e,t.value),t.errors)return u.finalize(t.value,[].concat(t.errors),i);e=t.value}}const c=t._flags.empty;c&&c.$_match(u.trim(e,t),r.nest(c),o.defaults)&&(r.mainstay.tracer.value(r,\"empty\",e,void 0),e=void 0);const f=n.presence||t._flags.presence||(t._flags._endedSwitch?null:s.presence);if(void 0===e){if(\"forbidden\"===f)return u.finalize(e,null,i);if(\"required\"===f)return u.finalize(e,[t.$_createError(\"any.required\",e,null,r,s)],i);if(\"optional\"===f){if(t._flags.default!==o.symbols.deepDefault)return u.finalize(e,null,i);r.mainstay.tracer.value(r,\"default\",e,{}),e={}}}else if(\"forbidden\"===f)return u.finalize(e,[t.$_createError(\"any.unknown\",e,null,r,s)],i);const h=[];if(t._valids){const n=t._valids.get(e,r,s,t._flags.insensitive);if(n)return s.convert&&(r.mainstay.tracer.value(r,\"valids\",e,n.value),e=n.value),r.mainstay.tracer.filter(t,r,\"valid\",n),u.finalize(e,null,i);if(t._flags.only){const n=t.$_createError(\"any.only\",e,{valids:t._valids.values({display:!0})},r,s);if(s.abortEarly)return u.finalize(e,[n],i);h.push(n)}}if(t._invalids){const n=t._invalids.get(e,r,s,t._flags.insensitive);if(n){r.mainstay.tracer.filter(t,r,\"invalid\",n);const a=t.$_createError(\"any.invalid\",e,{invalids:t._invalids.values({display:!0})},r,s);if(s.abortEarly)return u.finalize(e,[a],i);h.push(a)}}if(l.validate){const t=l.validate(e,i);if(t&&(r.mainstay.tracer.value(r,\"base\",e,t.value),e=t.value,t.errors)){if(!Array.isArray(t.errors))return h.push(t.errors),u.finalize(e,h,i);if(t.errors.length)return h.push(...t.errors),u.finalize(e,h,i)}}return t._rules.length?u.rules(e,h,i):u.finalize(e,h,i)},u.rules=function(e,t,r){const{schema:s,state:n,prefs:a}=r;for(const i of s._rules){const l=s._definition.rules[i.method];if(l.convert&&a.convert){n.mainstay.tracer.log(s,n,\"rule\",i.name,\"full\");continue}let c,f=i.args;if(i._resolve.length){f=Object.assign({},f);for(const t of i._resolve){const r=l.argsByName.get(t),i=f[t].resolve(e,n,a),u=r.normalize?r.normalize(i):i,h=o.validateArg(u,null,r);if(h){c=s.$_createError(\"any.ref\",i,{arg:t,ref:f[t],reason:h},n,a);break}f[t]=u}}c=c||l.validate(e,r,f,i);const h=u.rule(c,i);if(h.errors){if(n.mainstay.tracer.log(s,n,\"rule\",i.name,\"error\"),i.warn){n.mainstay.warnings.push(...h.errors);continue}if(a.abortEarly)return u.finalize(e,h.errors,r);t.push(...h.errors)}else n.mainstay.tracer.log(s,n,\"rule\",i.name,\"pass\"),n.mainstay.tracer.value(n,\"rule\",e,h.value,i.name),e=h.value}return u.finalize(e,t,r)},u.rule=function(e,t){return e instanceof l.Report?(u.error(e,t),{errors:[e],value:null}):Array.isArray(e)&&e[o.symbols.errors]?(e.forEach((e=>u.error(e,t))),{errors:e,value:null}):{errors:null,value:e}},u.error=function(e,t){return t.message&&e._setTemplate(t.message),e},u.finalize=function(e,t,r){t=t||[];const{schema:n,state:a,prefs:i}=r;if(t.length){const s=u.default(\"failover\",void 0,t,r);void 0!==s&&(a.mainstay.tracer.value(a,\"failover\",e,s),e=s,t=[])}if(t.length&&n._flags.error)if(\"function\"==typeof n._flags.error){t=n._flags.error(t),Array.isArray(t)||(t=[t]);for(const e of t)s(e instanceof Error||e instanceof l.Report,\"error() must return an Error object\")}else t=[n._flags.error];if(void 0===e){const s=u.default(\"default\",e,t,r);a.mainstay.tracer.value(a,\"default\",e,s),e=s}if(n._flags.cast&&void 0!==e){const t=n._definition.cast[n._flags.cast];if(t.from(e)){const s=t.to(e,r);a.mainstay.tracer.value(a,\"cast\",e,s,n._flags.cast),e=s}}if(n.$_terms.externals&&i.externals&&!1!==i._externals)for(const{method:e}of n.$_terms.externals)a.mainstay.externals.push({method:e,schema:n,state:a,label:l.label(n._flags,a,i)});const o={value:e,errors:t.length?t:null};return n._flags.result&&(o.value=\"strip\"===n._flags.result?void 0:r.original,a.mainstay.tracer.value(a,n._flags.result,e,o.value),a.shadow(e,n._flags.result)),n._cache&&!1!==i.cache&&!n._refs.length&&n._cache.set(r.original,o),void 0===e||o.errors||void 0===n._flags.artifact||(a.mainstay.artifacts=a.mainstay.artifacts||new Map,a.mainstay.artifacts.has(n._flags.artifact)||a.mainstay.artifacts.set(n._flags.artifact,[]),a.mainstay.artifacts.get(n._flags.artifact).push(a.path)),o},u.prefs=function(e,t){const r=t===o.defaults;return r&&e._preferences[o.symbols.prefs]?e._preferences[o.symbols.prefs]:(t=o.preferences(t,e._preferences),r&&(e._preferences[o.symbols.prefs]=t),t)},u.default=function(e,t,r,s){const{schema:a,state:i,prefs:l}=s,c=a._flags[e];if(l.noDefaults||void 0===c)return t;if(i.mainstay.tracer.log(a,i,\"rule\",e,\"full\"),!c)return c;if(\"function\"==typeof c){const t=c.length?[n(i.ancestors[0]),s]:[];try{return c(...t)}catch(t){return void r.push(a.$_createError(`any.${e}`,null,{error:t},i,l))}}return\"object\"!=typeof c?c:c[o.symbols.literal]?c.literal:o.isResolvable(c)?c.resolve(t,i,l):n(c)},u.trim=function(e,t){if(\"string\"!=typeof e)return e;const r=t.$_getRule(\"trim\");return r&&r.args.enabled?e.trim():e},u.ignore={active:!1,debug:a,entry:a,filter:a,log:a,resolve:a,value:a},u.errorsArray=function(){const e=[];return e[o.symbols.errors]=!0,e}},2036:(e,t,r)=>{\"use strict\";const s=r(375),n=r(9474),a=r(8160),i={};e.exports=i.Values=class{constructor(e,t){this._values=new Set(e),this._refs=new Set(t),this._lowercase=i.lowercases(e),this._override=!1}get length(){return this._values.size+this._refs.size}add(e,t){a.isResolvable(e)?this._refs.has(e)||(this._refs.add(e),t&&t.register(e)):this.has(e,null,null,!1)||(this._values.add(e),\"string\"==typeof e&&this._lowercase.set(e.toLowerCase(),e))}static merge(e,t,r){if(e=e||new i.Values,t){if(t._override)return t.clone();for(const r of[...t._values,...t._refs])e.add(r)}if(r)for(const t of[...r._values,...r._refs])e.remove(t);return e.length?e:null}remove(e){a.isResolvable(e)?this._refs.delete(e):(this._values.delete(e),\"string\"==typeof e&&this._lowercase.delete(e.toLowerCase()))}has(e,t,r,s){return!!this.get(e,t,r,s)}get(e,t,r,s){if(!this.length)return!1;if(this._values.has(e))return{value:e};if(\"string\"==typeof e&&e&&s){const t=this._lowercase.get(e.toLowerCase());if(t)return{value:t}}if(!this._refs.size&&\"object\"!=typeof e)return!1;if(\"object\"==typeof e)for(const t of this._values)if(n(t,e))return{value:t};if(t)for(const a of this._refs){const i=a.resolve(e,t,r,null,{in:!0});if(void 0===i)continue;const o=a.in&&\"object\"==typeof i?Array.isArray(i)?i:Object.keys(i):[i];for(const t of o)if(typeof t==typeof e)if(s&&e&&\"string\"==typeof e){if(t.toLowerCase()===e.toLowerCase())return{value:t,ref:a}}else if(n(t,e))return{value:t,ref:a}}return!1}override(){this._override=!0}values(e){if(e&&e.display){const e=[];for(const t of[...this._values,...this._refs])void 0!==t&&e.push(t);return e}return Array.from([...this._values,...this._refs])}clone(){const e=new i.Values(this._values,this._refs);return e._override=this._override,e}concat(e){s(!e._override,\"Cannot concat override set of values\");const t=new i.Values([...this._values,...e._values],[...this._refs,...e._refs]);return t._override=this._override,t}describe(){const e=[];this._override&&e.push({override:!0});for(const t of this._values.values())e.push(t&&\"object\"==typeof t?{value:t}:t);for(const t of this._refs.values())e.push(t.describe());return e}},i.Values.prototype[a.symbols.values]=!0,i.Values.prototype.slice=i.Values.prototype.clone,i.lowercases=function(e){const t=new Map;if(e)for(const r of e)\"string\"==typeof r&&t.set(r.toLowerCase(),r);return t}},978:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(1687),i=r(9621),o={};e.exports=function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(s(e&&\"object\"==typeof e,\"Invalid defaults value: must be an object\"),s(!t||!0===t||\"object\"==typeof t,\"Invalid source value: must be true, falsy or an object\"),s(\"object\"==typeof r,\"Invalid options: must be an object\"),!t)return null;if(r.shallow)return o.applyToDefaultsWithShallow(e,t,r);const i=n(e);if(!0===t)return i;const l=void 0!==r.nullOverride&&r.nullOverride;return a(i,t,{nullOverride:l,mergeArrays:!1})},o.applyToDefaultsWithShallow=function(e,t,r){const l=r.shallow;s(Array.isArray(l),\"Invalid keys\");const c=new Map,u=!0===t?null:new Set;for(let r of l){r=Array.isArray(r)?r:r.split(\".\");const s=i(e,r);s&&\"object\"==typeof s?c.set(s,u&&i(t,r)||s):u&&u.add(r)}const f=n(e,{},c);if(!u)return f;for(const e of u)o.reachCopy(f,t,e);const h=void 0!==r.nullOverride&&r.nullOverride;return a(f,t,{nullOverride:h,mergeArrays:!1})},o.reachCopy=function(e,t,r){for(const e of r){if(!(e in t))return;const r=t[e];if(\"object\"!=typeof r||null===r)return;t=r}const s=t;let n=e;for(let e=0;e<r.length-1;++e){const t=r[e];\"object\"!=typeof n[t]&&(n[t]={}),n=n[t]}n[r[r.length-1]]=s}},375:(e,t,r)=>{\"use strict\";const s=r(7916);e.exports=function(e){if(!e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];if(1===r.length&&r[0]instanceof Error)throw r[0];throw new s(r)}}},8571:(e,t,r)=>{\"use strict\";const s=r(9621),n=r(4277),a=r(7043),i={needsProtoHack:new Set([n.set,n.map,n.weakSet,n.weakMap])};e.exports=i.clone=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(\"object\"!=typeof e||null===e)return e;let s=i.clone,o=r;if(t.shallow){if(!0!==t.shallow)return i.cloneWithShallow(e,t);s=e=>e}else if(o){const t=o.get(e);if(t)return t}else o=new Map;const l=n.getInternalProto(e);if(l===n.buffer)return!1;if(l===n.date)return new Date(e.getTime());if(l===n.regex)return new RegExp(e);const c=i.base(e,l,t);if(c===e)return e;if(o&&o.set(e,c),l===n.set)for(const r of e)c.add(s(r,t,o));else if(l===n.map)for(const[r,n]of e)c.set(r,s(n,t,o));const u=a.keys(e,t);for(const r of u){if(\"__proto__\"===r)continue;if(l===n.array&&\"length\"===r){c.length=e.length;continue}const a=Object.getOwnPropertyDescriptor(e,r);a?a.get||a.set?Object.defineProperty(c,r,a):a.enumerable?c[r]=s(e[r],t,o):Object.defineProperty(c,r,{enumerable:!1,writable:!0,configurable:!0,value:s(e[r],t,o)}):Object.defineProperty(c,r,{enumerable:!0,writable:!0,configurable:!0,value:s(e[r],t,o)})}return c},i.cloneWithShallow=function(e,t){const r=t.shallow;(t=Object.assign({},t)).shallow=!1;const n=new Map;for(const t of r){const r=s(e,t);\"object\"!=typeof r&&\"function\"!=typeof r||n.set(r,r)}return i.clone(e,t,n)},i.base=function(e,t,r){if(!1===r.prototype)return i.needsProtoHack.has(t)?new t.constructor:t===n.array?[]:{};const s=Object.getPrototypeOf(e);if(s&&s.isImmutable)return e;if(t===n.array){const e=[];return s!==t&&Object.setPrototypeOf(e,s),e}if(i.needsProtoHack.has(t)){const e=new s.constructor;return s!==t&&Object.setPrototypeOf(e,s),e}return Object.create(s)}},9474:(e,t,r)=>{\"use strict\";const s=r(4277),n={mismatched:null};e.exports=function(e,t,r){return r=Object.assign({prototype:!0},r),!!n.isDeepEqual(e,t,r,[])},n.isDeepEqual=function(e,t,r,a){if(e===t)return 0!==e||1/e==1/t;const i=typeof e;if(i!==typeof t)return!1;if(null===e||null===t)return!1;if(\"function\"===i){if(!r.deepFunction||e.toString()!==t.toString())return!1}else if(\"object\"!==i)return e!=e&&t!=t;const o=n.getSharedType(e,t,!!r.prototype);switch(o){case s.buffer:return!1;case s.promise:return e===t;case s.regex:return e.toString()===t.toString();case n.mismatched:return!1}for(let r=a.length-1;r>=0;--r)if(a[r].isSame(e,t))return!0;a.push(new n.SeenEntry(e,t));try{return!!n.isDeepEqualObj(o,e,t,r,a)}finally{a.pop()}},n.getSharedType=function(e,t,r){if(r)return Object.getPrototypeOf(e)!==Object.getPrototypeOf(t)?n.mismatched:s.getInternalProto(e);const a=s.getInternalProto(e);return a!==s.getInternalProto(t)?n.mismatched:a},n.valueOf=function(e){const t=e.valueOf;if(void 0===t)return e;try{return t.call(e)}catch(e){return e}},n.hasOwnEnumerableProperty=function(e,t){return Object.prototype.propertyIsEnumerable.call(e,t)},n.isSetSimpleEqual=function(e,t){for(const r of Set.prototype.values.call(e))if(!Set.prototype.has.call(t,r))return!1;return!0},n.isDeepEqualObj=function(e,t,r,a,i){const{isDeepEqual:o,valueOf:l,hasOwnEnumerableProperty:c}=n,{keys:u,getOwnPropertySymbols:f}=Object;if(e===s.array){if(!a.part){if(t.length!==r.length)return!1;for(let e=0;e<t.length;++e)if(!o(t[e],r[e],a,i))return!1;return!0}for(const e of t)for(const t of r)if(o(e,t,a,i))return!0}else if(e===s.set){if(t.size!==r.size)return!1;if(!n.isSetSimpleEqual(t,r)){const e=new Set(Set.prototype.values.call(r));for(const r of Set.prototype.values.call(t)){if(e.delete(r))continue;let t=!1;for(const s of e)if(o(r,s,a,i)){e.delete(s),t=!0;break}if(!t)return!1}}}else if(e===s.map){if(t.size!==r.size)return!1;for(const[e,s]of Map.prototype.entries.call(t)){if(void 0===s&&!Map.prototype.has.call(r,e))return!1;if(!o(s,Map.prototype.get.call(r,e),a,i))return!1}}else if(e===s.error&&(t.name!==r.name||t.message!==r.message))return!1;const h=l(t),m=l(r);if((t!==h||r!==m)&&!o(h,m,a,i))return!1;const d=u(t);if(!a.part&&d.length!==u(r).length&&!a.skip)return!1;let p=0;for(const e of d)if(a.skip&&a.skip.includes(e))void 0===r[e]&&++p;else{if(!c(r,e))return!1;if(!o(t[e],r[e],a,i))return!1}if(!a.part&&d.length-p!==u(r).length)return!1;if(!1!==a.symbols){const e=f(t),s=new Set(f(r));for(const n of e){if(!a.skip||!a.skip.includes(n))if(c(t,n)){if(!c(r,n))return!1;if(!o(t[n],r[n],a,i))return!1}else if(c(r,n))return!1;s.delete(n)}for(const e of s)if(c(r,e))return!1}return!0},n.SeenEntry=class{constructor(e,t){this.obj=e,this.ref=t}isSame(e,t){return this.obj===e&&this.ref===t}}},7916:(e,t,r)=>{\"use strict\";const s=r(8761);e.exports=class extends Error{constructor(e){super(e.filter((e=>\"\"!==e)).map((e=>\"string\"==typeof e?e:e instanceof Error?e.message:s(e))).join(\" \")||\"Unknown error\"),\"function\"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,t.assert)}}},5277:e=>{\"use strict\";const t={};e.exports=function(e){if(!e)return\"\";let r=\"\";for(let s=0;s<e.length;++s){const n=e.charCodeAt(s);t.isSafe(n)?r+=e[s]:r+=t.escapeHtmlChar(n)}return r},t.escapeHtmlChar=function(e){return t.namedHtml.get(e)||(e>=256?\"&#\"+e+\";\":`&#x${e.toString(16).padStart(2,\"0\")};`)},t.isSafe=function(e){return t.safeCharCodes.has(e)},t.namedHtml=new Map([[38,\"&amp;\"],[60,\"&lt;\"],[62,\"&gt;\"],[34,\"&quot;\"],[160,\"&nbsp;\"],[162,\"&cent;\"],[163,\"&pound;\"],[164,\"&curren;\"],[169,\"&copy;\"],[174,\"&reg;\"]]),t.safeCharCodes=function(){const e=new Set;for(let t=32;t<123;++t)(t>=97||t>=65&&t<=90||t>=48&&t<=57||32===t||46===t||44===t||45===t||58===t||95===t)&&e.add(t);return e}()},6064:e=>{\"use strict\";e.exports=function(e){return e.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g,\"\\\\$&\")}},738:e=>{\"use strict\";e.exports=function(){}},1687:(e,t,r)=>{\"use strict\";const s=r(375),n=r(8571),a=r(7043),i={};e.exports=i.merge=function(e,t,r){if(s(e&&\"object\"==typeof e,\"Invalid target value: must be an object\"),s(null==t||\"object\"==typeof t,\"Invalid source value: must be null, undefined, or an object\"),!t)return e;if(r=Object.assign({nullOverride:!0,mergeArrays:!0},r),Array.isArray(t)){s(Array.isArray(e),\"Cannot merge array onto an object\"),r.mergeArrays||(e.length=0);for(let s=0;s<t.length;++s)e.push(n(t[s],{symbols:r.symbols}));return e}const o=a.keys(t,r);for(let s=0;s<o.length;++s){const a=o[s];if(\"__proto__\"===a||!Object.prototype.propertyIsEnumerable.call(t,a))continue;const l=t[a];if(l&&\"object\"==typeof l){if(e[a]===l)continue;!e[a]||\"object\"!=typeof e[a]||Array.isArray(e[a])!==Array.isArray(l)||l instanceof Date||l instanceof RegExp?e[a]=n(l,{symbols:r.symbols}):i.merge(e[a],l,r)}else(null!=l||r.nullOverride)&&(e[a]=l)}return e}},9621:(e,t,r)=>{\"use strict\";const s=r(375),n={};e.exports=function(e,t,r){if(!1===t||null==t)return e;\"string\"==typeof(r=r||{})&&(r={separator:r});const a=Array.isArray(t);s(!a||!r.separator,\"Separator option is not valid for array-based chain\");const i=a?t:t.split(r.separator||\".\");let o=e;for(let e=0;e<i.length;++e){let a=i[e];const l=r.iterables&&n.iterables(o);if(Array.isArray(o)||\"set\"===l){const e=Number(a);Number.isInteger(e)&&(a=e<0?o.length+e:e)}if(!o||\"function\"==typeof o&&!1===r.functions||!l&&void 0===o[a]){s(!r.strict||e+1===i.length,\"Missing segment\",a,\"in reach path \",t),s(\"object\"==typeof o||!0===r.functions||\"function\"!=typeof o,\"Invalid segment\",a,\"in reach path \",t),o=r.default;break}o=l?\"set\"===l?[...o][a]:o.get(a):o[a]}return o},n.iterables=function(e){return e instanceof Set?\"set\":e instanceof Map?\"map\":void 0}},8761:e=>{\"use strict\";e.exports=function(){try{return JSON.stringify(...arguments)}catch(e){return\"[Cannot display object: \"+e.message+\"]\"}}},4277:(e,t)=>{\"use strict\";const r={};t=e.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},r.typeMap=new Map([[\"[object Error]\",t.error],[\"[object Map]\",t.map],[\"[object Promise]\",t.promise],[\"[object Set]\",t.set],[\"[object WeakMap]\",t.weakMap],[\"[object WeakSet]\",t.weakSet]]),t.getInternalProto=function(e){if(Array.isArray(e))return t.array;if(e instanceof Date)return t.date;if(e instanceof RegExp)return t.regex;if(e instanceof Error)return t.error;const s=Object.prototype.toString.call(e);return r.typeMap.get(s)||t.generic}},7043:(e,t)=>{\"use strict\";t.keys=function(e){return!1!==(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).symbols?Reflect.ownKeys(e):Object.getOwnPropertyNames(e)}},3652:(e,t,r)=>{\"use strict\";const s=r(375),n={};t.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(e,t){const r=[].concat((t=t||{}).before||[]),n=[].concat(t.after||[]),a=t.group||\"?\",i=t.sort||0;s(!r.includes(a),`Item cannot come before itself: ${a}`),s(!r.includes(\"?\"),\"Item cannot come before unassociated items\"),s(!n.includes(a),`Item cannot come after itself: ${a}`),s(!n.includes(\"?\"),\"Item cannot come after unassociated items\"),Array.isArray(e)||(e=[e]);for(const t of e){const e={seq:this._items.length,sort:i,before:r,after:n,group:a,node:t};this._items.push(e)}if(!t.manual){const e=this._sort();s(e,\"item\",\"?\"!==a?`added into group ${a}`:\"\",\"created a dependencies error\")}return this.nodes}merge(e){Array.isArray(e)||(e=[e]);for(const t of e)if(t)for(const e of t._items)this._items.push(Object.assign({},e));this._items.sort(n.mergeSort);for(let e=0;e<this._items.length;++e)this._items[e].seq=e;const t=this._sort();return s(t,\"merge created a dependencies error\"),this.nodes}sort(){const e=this._sort();return s(e,\"sort created a dependencies error\"),this.nodes}_sort(){const e={},t=Object.create(null),r=Object.create(null);for(const s of this._items){const n=s.seq,a=s.group;r[a]=r[a]||[],r[a].push(n),e[n]=s.before;for(const e of s.after)t[e]=t[e]||[],t[e].push(n)}for(const t in e){const s=[];for(const n in e[t]){const a=e[t][n];r[a]=r[a]||[],s.push(...r[a])}e[t]=s}for(const s in t)if(r[s])for(const n of r[s])e[n].push(...t[s]);const s={};for(const t in e){const r=e[t];for(const e of r)s[e]=s[e]||[],s[e].push(t)}const n={},a=[];for(let e=0;e<this._items.length;++e){let t=e;if(s[e]){t=null;for(let e=0;e<this._items.length;++e){if(!0===n[e])continue;s[e]||(s[e]=[]);const r=s[e].length;let a=0;for(let t=0;t<r;++t)n[s[e][t]]&&++a;if(a===r){t=e;break}}}null!==t&&(n[t]=!0,a.push(t))}if(a.length!==this._items.length)return!1;const i={};for(const e of this._items)i[e.seq]=e;this._items=[],this.nodes=[];for(const e of a){const t=i[e];this.nodes.push(t.node),this._items.push(t)}return!0}},n.mergeSort=(e,t)=>e.sort===t.sort?0:e.sort<t.sort?-1:1},5380:(e,t,r)=>{\"use strict\";const s=r(443),n=r(2178),a={minDomainSegments:2,nonAsciiRx:/[^\\x00-\\x7f]/,domainControlRx:/[\\x00-\\x20@\\:\\/\\\\#!\\$&\\'\\(\\)\\*\\+,;=\\?]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9\\-]*[a-zA-Z0-9])?$/,URL:s.URL||URL};t.analyze=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e)return n.code(\"DOMAIN_NON_EMPTY_STRING\");if(\"string\"!=typeof e)throw new Error(\"Invalid input: domain must be a string\");if(e.length>256)return n.code(\"DOMAIN_TOO_LONG\");if(a.nonAsciiRx.test(e)){if(!1===t.allowUnicode)return n.code(\"DOMAIN_INVALID_UNICODE_CHARS\");e=e.normalize(\"NFC\")}if(a.domainControlRx.test(e))return n.code(\"DOMAIN_INVALID_CHARS\");e=a.punycode(e),t.allowFullyQualified&&\".\"===e[e.length-1]&&(e=e.slice(0,-1));const r=t.minDomainSegments||a.minDomainSegments,s=e.split(\".\");if(s.length<r)return n.code(\"DOMAIN_SEGMENTS_COUNT\");if(t.maxDomainSegments&&s.length>t.maxDomainSegments)return n.code(\"DOMAIN_SEGMENTS_COUNT_MAX\");const i=t.tlds;if(i){const e=s[s.length-1].toLowerCase();if(i.deny&&i.deny.has(e)||i.allow&&!i.allow.has(e))return n.code(\"DOMAIN_FORBIDDEN_TLDS\")}for(let e=0;e<s.length;++e){const t=s[e];if(!t.length)return n.code(\"DOMAIN_EMPTY_SEGMENT\");if(t.length>63)return n.code(\"DOMAIN_LONG_SEGMENT\");if(e<s.length-1){if(!a.domainSegmentRx.test(t))return n.code(\"DOMAIN_INVALID_CHARS\")}else if(!a.tldSegmentRx.test(t))return n.code(\"DOMAIN_INVALID_TLDS_CHARS\")}return null},t.isValid=function(e,r){return!t.analyze(e,r)},a.punycode=function(e){e.includes(\"%\")&&(e=e.replace(/%/g,\"%25\"));try{return new a.URL(`http://${e}`).host}catch(t){return e}}},1745:(e,t,r)=>{\"use strict\";const s=r(9848),n=r(5380),a=r(2178),i={nonAsciiRx:/[^\\x00-\\x7f]/,encoder:new(s.TextEncoder||TextEncoder)};t.analyze=function(e,t){return i.email(e,t)},t.isValid=function(e,t){return!i.email(e,t)},i.email=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(\"string\"!=typeof e)throw new Error(\"Invalid input: email must be a string\");if(!e)return a.code(\"EMPTY_STRING\");const r=!i.nonAsciiRx.test(e);if(!r){if(!1===t.allowUnicode)return a.code(\"FORBIDDEN_UNICODE\");e=e.normalize(\"NFC\")}const s=e.split(\"@\");if(2!==s.length)return s.length>2?a.code(\"MULTIPLE_AT_CHAR\"):a.code(\"MISSING_AT_CHAR\");const[o,l]=s;if(!o)return a.code(\"EMPTY_LOCAL\");if(!t.ignoreLength){if(e.length>254)return a.code(\"ADDRESS_TOO_LONG\");if(i.encoder.encode(o).length>64)return a.code(\"LOCAL_TOO_LONG\")}return i.local(o,r)||n.analyze(l,t)},i.local=function(e,t){const r=e.split(\".\");for(const e of r){if(!e.length)return a.code(\"EMPTY_LOCAL_SEGMENT\");if(t){if(!i.atextRx.test(e))return a.code(\"INVALID_LOCAL_CHARS\")}else for(const t of e){if(i.atextRx.test(t))continue;const e=i.binary(t);if(!i.atomRx.test(e))return a.code(\"INVALID_LOCAL_CHARS\")}}},i.binary=function(e){return Array.from(i.encoder.encode(e)).map((e=>String.fromCharCode(e))).join(\"\")},i.atextRx=/^[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+$/,i.atomRx=new RegExp([\"(?:[\\\\xc2-\\\\xdf][\\\\x80-\\\\xbf])\",\"(?:\\\\xe0[\\\\xa0-\\\\xbf][\\\\x80-\\\\xbf])|(?:[\\\\xe1-\\\\xec][\\\\x80-\\\\xbf]{2})|(?:\\\\xed[\\\\x80-\\\\x9f][\\\\x80-\\\\xbf])|(?:[\\\\xee-\\\\xef][\\\\x80-\\\\xbf]{2})\",\"(?:\\\\xf0[\\\\x90-\\\\xbf][\\\\x80-\\\\xbf]{2})|(?:[\\\\xf1-\\\\xf3][\\\\x80-\\\\xbf]{3})|(?:\\\\xf4[\\\\x80-\\\\x8f][\\\\x80-\\\\xbf]{2})\"].join(\"|\"))},2178:(e,t)=>{\"use strict\";t.codes={EMPTY_STRING:\"Address must be a non-empty string\",FORBIDDEN_UNICODE:\"Address contains forbidden Unicode characters\",MULTIPLE_AT_CHAR:\"Address cannot contain more than one @ character\",MISSING_AT_CHAR:\"Address must contain one @ character\",EMPTY_LOCAL:\"Address local part cannot be empty\",ADDRESS_TOO_LONG:\"Address too long\",LOCAL_TOO_LONG:\"Address local part too long\",EMPTY_LOCAL_SEGMENT:\"Address local part contains empty dot-separated segment\",INVALID_LOCAL_CHARS:\"Address local part contains invalid character\",DOMAIN_NON_EMPTY_STRING:\"Domain must be a non-empty string\",DOMAIN_TOO_LONG:\"Domain too long\",DOMAIN_INVALID_UNICODE_CHARS:\"Domain contains forbidden Unicode characters\",DOMAIN_INVALID_CHARS:\"Domain contains invalid character\",DOMAIN_INVALID_TLDS_CHARS:\"Domain contains invalid tld character\",DOMAIN_SEGMENTS_COUNT:\"Domain lacks the minimum required number of segments\",DOMAIN_SEGMENTS_COUNT_MAX:\"Domain contains too many segments\",DOMAIN_FORBIDDEN_TLDS:\"Domain uses forbidden TLD\",DOMAIN_EMPTY_SEGMENT:\"Domain contains empty dot-separated segment\",DOMAIN_LONG_SEGMENT:\"Domain contains dot-separated segment that is too long\"},t.code=function(e){return{code:e,error:t.codes[e]}}},9959:(e,t,r)=>{\"use strict\";const s=r(375),n=r(5752);t.regex=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};s(void 0===e.cidr||\"string\"==typeof e.cidr,\"options.cidr must be a string\");const t=e.cidr?e.cidr.toLowerCase():\"optional\";s([\"required\",\"optional\",\"forbidden\"].includes(t),\"options.cidr must be one of required, optional, forbidden\"),s(void 0===e.version||\"string\"==typeof e.version||Array.isArray(e.version),\"options.version must be a string or an array of string\");let r=e.version||[\"ipv4\",\"ipv6\",\"ipvfuture\"];Array.isArray(r)||(r=[r]),s(r.length>=1,\"options.version must have at least 1 version specified\");for(let e=0;e<r.length;++e)s(\"string\"==typeof r[e],\"options.version must only contain strings\"),r[e]=r[e].toLowerCase(),s([\"ipv4\",\"ipv6\",\"ipvfuture\"].includes(r[e]),\"options.version contains unknown version \"+r[e]+\" - must be one of ipv4, ipv6, ipvfuture\");r=Array.from(new Set(r));const a=`(?:${r.map((e=>{if(\"forbidden\"===t)return n.ip[e];const r=`\\\\/${\"ipv4\"===e?n.ip.v4Cidr:n.ip.v6Cidr}`;return\"required\"===t?`${n.ip[e]}${r}`:`${n.ip[e]}(?:${r})?`})).join(\"|\")})`,i=new RegExp(`^${a}$`);return{cidr:t,versions:r,regex:i,raw:a}}},5752:(e,t,r)=>{\"use strict\";const s=r(375),n=r(6064),a={generate:function(){const e={},t=\"\\\\dA-Fa-f\",r=\"[\"+t+\"]\",s=\"\\\\w-\\\\.~\",n=\"!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=\",a=\"%\"+t,i=s+a+n+\":@\",o=\"[\"+i+\"]\",l=\"(?:0{0,2}\\\\d|0?[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\";e.ipv4address=\"(?:\"+l+\"\\\\.){3}\"+l;const c=r+\"{1,4}\",u=\"(?:\"+c+\":\"+c+\"|\"+e.ipv4address+\")\",f=\"(?:\"+c+\":){6}\"+u,h=\"::(?:\"+c+\":){5}\"+u,m=\"(?:\"+c+\")?::(?:\"+c+\":){4}\"+u,d=\"(?:(?:\"+c+\":){0,1}\"+c+\")?::(?:\"+c+\":){3}\"+u,p=\"(?:(?:\"+c+\":){0,2}\"+c+\")?::(?:\"+c+\":){2}\"+u,g=\"(?:(?:\"+c+\":){0,3}\"+c+\")?::\"+c+\":\"+u,y=\"(?:(?:\"+c+\":){0,4}\"+c+\")?::\"+u,b=\"(?:(?:\"+c+\":){0,5}\"+c+\")?::\"+c,v=\"(?:(?:\"+c+\":){0,6}\"+c+\")?::\";e.ipv4Cidr=\"(?:\\\\d|[1-2]\\\\d|3[0-2])\",e.ipv6Cidr=\"(?:0{0,2}\\\\d|0?[1-9]\\\\d|1[01]\\\\d|12[0-8])\",e.ipv6address=\"(?:\"+f+\"|\"+h+\"|\"+m+\"|\"+d+\"|\"+p+\"|\"+g+\"|\"+y+\"|\"+b+\"|\"+v+\")\",e.ipvFuture=\"v\"+r+\"+\\\\.[\"+s+n+\":]+\",e.scheme=\"[a-zA-Z][a-zA-Z\\\\d+-\\\\.]*\",e.schemeRegex=new RegExp(e.scheme);const _=\"[\"+s+a+n+\":]*\",w=\"[\"+s+a+n+\"]{1,255}\",$=\"(?:\\\\[(?:\"+e.ipv6address+\"|\"+e.ipvFuture+\")\\\\]|\"+e.ipv4address+\"|\"+w+\")\",x=\"(?:\"+_+\"@)?\"+$+\"(?::\\\\d*)?\",j=\"(?:\"+_+\"@)?(\"+$+\")(?::\\\\d*)?\",k=o+\"*\",R=o+\"+\",A=\"(?:\\\\/\"+k+\")*\",S=\"\\\\/(?:\"+R+A+\")?\",O=R+A,E=\"[\"+s+a+n+\"@]+\"+A,D=\"(?:\\\\/\\\\/\\\\/\"+k+A+\")\";return e.hierPart=\"(?:(?:\\\\/\\\\/\"+x+A+\")|\"+S+\"|\"+O+\"|\"+D+\")\",e.hierPartCapture=\"(?:(?:\\\\/\\\\/\"+j+A+\")|\"+S+\"|\"+O+\")\",e.relativeRef=\"(?:(?:\\\\/\\\\/\"+x+A+\")|\"+S+\"|\"+E+\"|)\",e.relativeRefCapture=\"(?:(?:\\\\/\\\\/\"+j+A+\")|\"+S+\"|\"+E+\"|)\",e.query=\"[\"+i+\"\\\\/\\\\?]*(?=#|$)\",e.queryWithSquareBrackets=\"[\"+i+\"\\\\[\\\\]\\\\/\\\\?]*(?=#|$)\",e.fragment=\"[\"+i+\"\\\\/\\\\?]*\",e}};a.rfc3986=a.generate(),t.ip={v4Cidr:a.rfc3986.ipv4Cidr,v6Cidr:a.rfc3986.ipv6Cidr,ipv4:a.rfc3986.ipv4address,ipv6:a.rfc3986.ipv6address,ipvfuture:a.rfc3986.ipvFuture},a.createRegex=function(e){const t=a.rfc3986,r=\"(?:\\\\?\"+(e.allowQuerySquareBrackets?t.queryWithSquareBrackets:t.query)+\")?(?:#\"+t.fragment+\")?\",i=e.domain?t.relativeRefCapture:t.relativeRef;if(e.relativeOnly)return a.wrap(i+r);let o=\"\";if(e.scheme){s(e.scheme instanceof RegExp||\"string\"==typeof e.scheme||Array.isArray(e.scheme),\"scheme must be a RegExp, String, or Array\");const r=[].concat(e.scheme);s(r.length>=1,\"scheme must have at least 1 scheme specified\");const a=[];for(let e=0;e<r.length;++e){const i=r[e];s(i instanceof RegExp||\"string\"==typeof i,\"scheme at position \"+e+\" must be a RegExp or String\"),i instanceof RegExp?a.push(i.source.toString()):(s(t.schemeRegex.test(i),\"scheme at position \"+e+\" must be a valid scheme\"),a.push(n(i)))}o=a.join(\"|\")}const l=\"(?:\"+(o?\"(?:\"+o+\")\":t.scheme)+\":\"+(e.domain?t.hierPartCapture:t.hierPart)+\")\",c=e.allowRelative?\"(?:\"+l+\"|\"+i+\")\":l;return a.wrap(c+r,o)},a.wrap=function(e,t){return{raw:e=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${e}`,regex:new RegExp(`^${e}$`),scheme:t}},a.uriRegex=a.createRegex({}),t.regex=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.scheme||e.allowRelative||e.relativeOnly||e.allowQuerySquareBrackets||e.domain?a.createRegex(e):a.uriRegex}},1447:(e,t)=>{\"use strict\";const r={operators:[\"!\",\"^\",\"*\",\"/\",\"%\",\"+\",\"-\",\"<\",\"<=\",\">\",\">=\",\"==\",\"!=\",\"&&\",\"||\",\"??\"],operatorCharacters:[\"!\",\"^\",\"*\",\"/\",\"%\",\"+\",\"-\",\"<\",\"=\",\">\",\"&\",\"|\",\"?\"],operatorsOrder:[[\"^\"],[\"*\",\"/\",\"%\"],[\"+\",\"-\"],[\"<\",\"<=\",\">\",\">=\"],[\"==\",\"!=\"],[\"&&\"],[\"||\",\"??\"]],operatorsPrefix:[\"!\",\"n\"],literals:{'\"':'\"',\"`\":\"`\",\"'\":\"'\",\"[\":\"]\"},numberRx:/^(?:[0-9]*(\\.[0-9]*)?){1}$/,tokenRx:/^[\\w\\$\\#\\.\\@\\:\\{\\}]+$/,symbol:Symbol(\"formula\"),settings:Symbol(\"settings\")};t.Parser=class{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t[r.settings]&&t.constants)for(const e in t.constants){const r=t.constants[e];if(null!==r&&![\"boolean\",\"number\",\"string\"].includes(typeof r))throw new Error(`Formula constant ${e} contains invalid ${typeof r} value type`)}this.settings=t[r.settings]?t:Object.assign({[r.settings]:!0,constants:{},functions:{}},t),this.single=null,this._parts=null,this._parse(e)}_parse(e){let s=[],n=\"\",a=0,i=!1;const o=e=>{if(a)throw new Error(\"Formula missing closing parenthesis\");const o=s.length?s[s.length-1]:null;if(i||n||e){if(o&&\"reference\"===o.type&&\")\"===e)return o.type=\"function\",o.value=this._subFormula(n,o.value),void(n=\"\");if(\")\"===e){const e=new t.Parser(n,this.settings);s.push({type:\"segment\",value:e})}else if(i){if(\"]\"===i)return s.push({type:\"reference\",value:n}),void(n=\"\");s.push({type:\"literal\",value:n})}else if(r.operatorCharacters.includes(n))o&&\"operator\"===o.type&&r.operators.includes(o.value+n)?o.value+=n:s.push({type:\"operator\",value:n});else if(n.match(r.numberRx))s.push({type:\"constant\",value:parseFloat(n)});else if(void 0!==this.settings.constants[n])s.push({type:\"constant\",value:this.settings.constants[n]});else{if(!n.match(r.tokenRx))throw new Error(`Formula contains invalid token: ${n}`);s.push({type:\"reference\",value:n})}n=\"\"}};for(const t of e)i?t===i?(o(),i=!1):n+=t:a?\"(\"===t?(n+=t,++a):\")\"===t?(--a,a?n+=t:o(t)):n+=t:t in r.literals?i=r.literals[t]:\"(\"===t?(o(),++a):r.operatorCharacters.includes(t)?(o(),n=t,o()):\" \"!==t?n+=t:o();o(),s=s.map(((e,t)=>\"operator\"!==e.type||\"-\"!==e.value||t&&\"operator\"!==s[t-1].type?e:{type:\"operator\",value:\"n\"}));let l=!1;for(const e of s){if(\"operator\"===e.type){if(r.operatorsPrefix.includes(e.value))continue;if(!l)throw new Error(\"Formula contains an operator in invalid position\");if(!r.operators.includes(e.value))throw new Error(`Formula contains an unknown operator ${e.value}`)}else if(l)throw new Error(\"Formula missing expected operator\");l=!l}if(!l)throw new Error(\"Formula contains invalid trailing operator\");1===s.length&&[\"reference\",\"literal\",\"constant\"].includes(s[0].type)&&(this.single={type:\"reference\"===s[0].type?\"reference\":\"value\",value:s[0].value}),this._parts=s.map((e=>{if(\"operator\"===e.type)return r.operatorsPrefix.includes(e.value)?e:e.value;if(\"reference\"!==e.type)return e.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(e.value))throw new Error(`Formula contains invalid reference ${e.value}`);return this.settings.reference?this.settings.reference(e.value):r.reference(e.value)}))}_subFormula(e,s){const n=this.settings.functions[s];if(\"function\"!=typeof n)throw new Error(`Formula contains unknown function ${s}`);let a=[];if(e){let t=\"\",n=0,i=!1;const o=()=>{if(!t)throw new Error(`Formula contains function ${s} with invalid arguments ${e}`);a.push(t),t=\"\"};for(let s=0;s<e.length;++s){const a=e[s];i?(t+=a,a===i&&(i=!1)):a in r.literals&&!n?(t+=a,i=r.literals[a]):\",\"!==a||n?(t+=a,\"(\"===a?++n:\")\"===a&&--n):o()}o()}return a=a.map((e=>new t.Parser(e,this.settings))),function(e){const t=[];for(const r of a)t.push(r.evaluate(e));return n.call(e,...t)}}evaluate(e){const t=this._parts.slice();for(let s=t.length-2;s>=0;--s){const n=t[s];if(n&&\"operator\"===n.type){const a=t[s+1];t.splice(s+1,1);const i=r.evaluate(a,e);t[s]=r.single(n.value,i)}}return r.operatorsOrder.forEach((s=>{for(let n=1;n<t.length-1;)if(s.includes(t[n])){const s=t[n],a=r.evaluate(t[n-1],e),i=r.evaluate(t[n+1],e);t.splice(n,2);const o=r.calculate(s,a,i);t[n-1]=0===o?0:o}else n+=2})),r.evaluate(t[0],e)}},t.Parser.prototype[r.symbol]=!0,r.reference=function(e){return function(t){return t&&void 0!==t[e]?t[e]:null}},r.evaluate=function(e,t){return null===e?null:\"function\"==typeof e?e(t):e[r.symbol]?e.evaluate(t):e},r.single=function(e,t){if(\"!\"===e)return!t;const r=-t;return 0===r?0:r},r.calculate=function(e,t,s){if(\"??\"===e)return r.exists(t)?t:s;if(\"string\"==typeof t||\"string\"==typeof s){if(\"+\"===e)return(t=r.exists(t)?t:\"\")+(r.exists(s)?s:\"\")}else switch(e){case\"^\":return Math.pow(t,s);case\"*\":return t*s;case\"/\":return t/s;case\"%\":return t%s;case\"+\":return t+s;case\"-\":return t-s}switch(e){case\"<\":return t<s;case\"<=\":return t<=s;case\">\":return t>s;case\">=\":return t>=s;case\"==\":return t===s;case\"!=\":return t!==s;case\"&&\":return t&&s;case\"||\":return t||s}return null},r.exists=function(e){return null!=e}},9926:()=>{},5688:()=>{},9708:()=>{},1152:()=>{},443:()=>{},9848:()=>{},5934:e=>{\"use strict\";e.exports=JSON.parse('{\"version\":\"17.11.0\"}')}},t={},function r(s){var n=t[s];if(void 0!==n)return n.exports;var a=t[s]={exports:{}};return e[s](a,a.exports,r),a.exports}(5107);var e,t}));\n\n//# sourceURL=webpack://js.package/./node_modules/joi/dist/joi-browser.min.js?");

/***/ }),

/***/ "./node_modules/lz-string/libs/lz-string.js":
/*!**************************************************!*\
  !*** ./node_modules/lz-string/libs/lz-string.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.5\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n\n//# sourceURL=webpack://js.package/./node_modules/lz-string/libs/lz-string.js?");

/***/ }),

/***/ "?9157":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js.package/crypto_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;